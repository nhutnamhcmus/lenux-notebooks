{
  
    
        "post0": {
            "title": "What Are Some Knowledge Graph Data Models",
            "content": "ĐỒ THỊ TRI THỨC - KNOWLEDGE GRAPH . Đây là bản dịch từ Course CS520: Knowledge Graphs | Data Models, Knowledge Acquisition, Inference and Applications | . Department of Computer Science, Stanford University, Spring 2021 . Knowledge graphs have emerged as a compelling abstraction for organizing world’s structured knowledge over the internet, capturing relationships among key entities of interest to enterprises, and a way to integrate information extracted from multiple data sources. Knowledge graphs have also started to play a central role in machine learning and natural language processing as a method to incorporate world knowledge, as a target knowledge representation for extracted knowledge, and for explaining what is being learned. This class is a graduate level research seminar and will include lectures on knowledge graph topics (e.g., data models, creation, inference, access) and invited lectures from prominent researchers and industry practitioners. The seminar emphasizes synthesis of AI, database systems and HCI in creating integrated intelligent systems centered around knowledge graphs. . Mục đích: Là tìm hiểu cũng như trau dồi kiến thức chuyên môn trong lĩnh vực Knowledge Graph cũng như từ vựng tiếng Anh. Không vì mục đích kinh doanh hay bất cứ mục đích về lợi nhuận, tất cả là vì mục đích chia sẻ kiến thức và học tập. . Mọi thông tin về những chủ đề được note lại có thể tìm thấy ở đây: . https://web.stanford.edu/class/cs520/2020/notes/Table_Of_Contents.html . Video của các buổi seminar cũng được công khai trên địa chỉ Youtube: . https://www.youtube.com/playlist?list=PLDhh0lALedc5paY4N3NRZ3j_ui9foL7Qc . Mọi vấn đề về dịch thuật, thuật ngữ xin để lại comment hoặc gửi về địa chỉ email: lenam.fithcmus@gmail.com với tiêu đề . [ISSUES OF KG TRANSLATION] . WHAT ARE SOME GRAPH DATA MODELS? . 1. Giới thiệu . Hai mô hình dữ liệu đồ thị phổ biến là mô hình Resource Description Framework (RDF) và mô hình Property Graph (PG). Ngôn ngữ truy vấn cho RDF là SPARQL, và ngôn ngữ truy vấn cho mô hình Property Graph là Cypher. . Trong chương này, chúng ta sẽ trình bày một cách tổng quan bình thường cả hai mô hình dữ liệu và cho những ví dụ truy vấn với chúng. Chúng ta xem xét chuyển đổi biểu diễn dữ liệu bằng một trong các mô hình sang biểu diễn dữ liệu bằng mô hình khác, và cũng so sánh những dữ liệu đồ thị này bằng cách dùng mối quan hệ mô hình dữ liệu thông thường. . 2. Resource Description Frame - Khung mô tả tài nguyên . RDF (Resource Description Frame - Khung mô tả tài nguyên) là một khung (framework) cho việc biểu diễn thông tin (representation information) trên web. Mô hình dữ liệu RDF (RDF Data Model) và ngôn ngữ truy vấn của nó SPARQL được chuẩn hoá bởi World Wide Web Consortium . 2.1 RDF Data Model - Mô hình dữ liệu RDF . Một bộ ba RDF, thành phân cơ sở của biểu diễn trong mô hình này, bao gồm một chủ thể (subject), một thuộc tính (predicate) và một đối tượng (object). Một tập bộ ba như vậy được gọi là đồ thị RDF (RDF Graph). Chúng ta có thể trực quan hoá một bộ ba RDF như một node và một cạnh liên kết có hướng, mà mỗi bộ ba như vậy biểu diễn một đồ thị node-edge-node (nút-cạnh-nút) . . Có thể chia thành ba loại node: . - IRIs - Internationalized Resource Identifier: được sử dụng để xác định duy nhất những tài nguyên trên web . - literals: là một giá trị của một kiểu dữ liệu xác định, ví dụ như: string – chuỗi, integer - số nguyên, … . - Blanks nodes: Là một node mà không có bộ định danh, và tương tự như một ẩn danh (anonmyous) hoặc một biến giá trị tồn tại (existential variable) . Một ví dụ minh hoạ của biểu diễn thông tin sử dụng RDF, chúng ta lấy ví dụ biểu diễn tri thức quan hệ giữa con người. Trong ví dụ này, một người với tên art, được đại diên bởi IRI http://example.org/art. Trong định nghĩa sử dụng IRIs dưới đây có thể được viết tắt bởi một tiền tố.Ví dụ như, chúng ta định nghĩa foaf như một tiền tố cho &lt;&lt;http://xmlns.com/foaf/0.1/&gt;&gt;. Quan hệ tri thức (knows) được định nghĩa bởi IRI http://xmlns.com/foaf/0.1/knows . @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; . @prefix ex: &lt;http://example.org/&gt; . ex:art foaf:knows ex:bob . ex:art foaf:knows ex:bea . ex:bob foaf:knows ex:cal . ex:bob foaf:knows ex:cam . ex:bea foaf:knows ex:coe . ex:bea foaf:knows ex:cory . ex:bea foaf:age 23 . ex:bea foaf:based_near _:o1 . Hai bộ ba minh hoạ cuối cùng, một nút tầm thường (literal node) và một nút trống (blank node).Giá trị của foaf:age là một số nguyên 23, một ví dụ về một literal. Một chuỗi là một kiểu dữ liệu tầm thường phổ biến khác. Giá trị của foaf:based_near là một không gian ẩn danh mà được biểu thị bởi dấu gạch dưới (underscore) như một nút định danh. o1 ở đây là một dữ liệu định danh nổi bộ không có ý nghĩa, nằm bên ngoài ngữ cảnh của đồ thị hiện tại. . Bộ từ vựng RDF là một bộ sưu tập (collection) của những IRI dự định sử dụng trong đồ thị RDF (RDF Graph). IRIs trong bộ từ vựng RDF thường bắt đầu với một chuỗi con chung gọi là một namespace (không gian tên) IRI. Trong ví dụ ở trên, &lt;&lt;http://xmlns.com/foaf/0.1/&gt;&gt; là một không gian tên tiền tố (namespace prefix). Trong một vài không gian tên (namespace), IRIs được liên kết theo quy ước với một tên ngắn được gọi là tiền tố không gian tên (namespace prefix). Trong ví dụ bên trên, chúng ta định nghĩa foaf và ex như tiền tố không gian tên (namespace prefix) . Đồ thị RDF (RDF Graphs) mang tính chất hữu cơ theo nghĩa là chúng cung cấp một bức tranh tổng quan dữ liệu tĩnh. Với phần mở rộng từ vựng phù hợp, chúng có thể diễn đạt thông tin về các sự kiện hoặc các thuộc tính động khác của các thực thể. . Một kho dữ liệu RDF (RDF Dataset) là một tập của nhiều đồ thị RDF (RDF Graphs) và bao gồm chính xác một đồ thị mặc định có thể để trống và không cần đặt tên và một hoặc nhiều đồ thị được đặt tên. Mỗi đồ thị được đặt tên bao gồm một IRI hoặc một nút trống thể hiện tên của nó và đồ thị RDF. . 2.2 SPARQL Query Language - Ngôn ngữ truy vấn SPARQL . SPARQL (đọc là “sparkle” :v xờ pắc kơ le), viết tắt của SIMPle Protocol and RDF Query Language) là một ngôn ngữ truy vấn để truy xuất và thao tác dữ liệu được lưu trữ trong Resource Description Framework (RDF). SPARQL thể được sử dụng để thể hiện các truy vấn trên nhiều nguồn dữ liệu khác nhau, cho dù dữ liệu được lưu trữ nguyên bản dưới dạng RDF hay được xem dưới dạng RDF thông qua phần mềm trung gian. SPARQL chứa các khả năng truy vấn bắt buộc và tuỳ chọn mẫu đồ thị (graph patterns) với liên kết (conjunctions) và phi liên kết (disconjuntions) của chúng. SPARQL cũng hỗ trợ mở rộng truy vấn giá trị kiểm tra và ràng buộc bởi nguồn đồ thị RDF. Kết quả của truy vấn SPARQL có thể là các tập hợp hoặc những đồ thị RDF (RDF Graphs) . Hầu hết dạng của một truy vấn SPARQL bao gồm một tập bộ ba mẫu (a set of triple patterns) được gọi là một mẫu đồ thị cơ sở (a basic graph pattern). Bộ ba mẫu giống như bộ ba RDF ngoại trừ rằng mỗi chủ thể (subject), thuộc tính (predicate) và đối tượng (object) có thể là một biến (variable). Một mẫu đồ thị cơ sở (Basic Graph Pattern) khớp với một đồ thị con (Subgraph) của dữ liệu RDF khi những thuật ngữ RDF từ đồ thị con đó có thể được thay thế cho các biến trong mẫu đồ thị (graph patterns) và kết quả là đồ thị RDF tương dương với đồ thị con. . Ví dụ dưới đây cho thấy một truy vấn SPARQL dựa trên dữ liệu đồ thị được hiển thị ở trên và các truy vấn tri thức con người bởi một người. Truy vấn bao gồm hai phần: mệnh đề SELECT xác định các biến sẽ xuất hiện trong kết quả truy vấn và mệnh đề WHERE cung cấp mẫu biểu đồ để khớp với biểu đồ dữ liệu. Mẫu đồ thị trong ví dụ này bao gồm một bộ ba duy nhất với một biến duy nhất (? Người) ở vị trí đối tượng. . SELECT ?person . WHERE . &lt;http://example.org/art&gt; &lt;http://xmlns.com/foaf/0.1/knows&gt; ?person . Câu truy vấn trả về tập kết quả trên dữ liệu đồ thị của chúng ta .   . ?person1 | . &lt;http://example.org/bob&gt; | . &lt;http://example.org/bea&gt; | . Mẫu đồ thị (Graph Pattern) có thể chứa nhiều bộ ba. Lấy ví dụ như câu truy vấn sau, chúng ta hỏi những bạn của bạn của art (art’s friends of friends) . SELECT ?person ?person1 . WHERE . &lt;http://example.org/art&gt; &lt;http://xmlns.com/foaf/0.1/knows&gt; ?person . ?person &lt;http://xmlns.com/foaf/0.1/knows&gt; ?person1 . Câu truy vấn trả về tập kết quả trên dữ liệu đồ thị của chúng ta .     . ?person1 | ?person2 | . &lt;http://example.org/bob&gt; | &lt;http://example.org/cal&gt; | . &lt;http://example.org/bob&gt; | &lt;http://example.org/cam&gt; | . &lt;http://example.org/bea&gt; | &lt;http://example.org/coe&gt; | . &lt;http://example.org/bea&gt; | &lt;http://example.org/cory&gt; | . Mỗi lời giải đưa ra một cách trong đó các biến đã chọn có thể được liên kết với các thuật ngữ RDF để mẫu truy vấn khớp với dữ liệu. Tập hợp kết quả đưa ra tất cả các lời giải khả thi. Trong ví dụ trên, hai tập hợp con dữ liệu khác nhau cung cấp các kết quả phù hợp dẫn đến các câu trả lời. Các ví dụ trên minh họa khớp mẫu đồ thị cơ bản; tất cả các biến được sử dụng trong mẫu truy vấn phải được ràng buộc trong mọi lời giải. . Truy vấn SPARQL có thể trả về những node trống (Blank Nodes) trong kết quả. Định danh cho những node trống (Blank Nodes) được dùng trong kết quả có thể không giống như định danh sử dụng trong đồ thị RDF gốc. Lớp WHERE trong một truy vấn SPARQL cung cấp một cách khớp dựa trên những kiểu tầm thường và để lọc những kết quả dựa trên những ràng buộc số học. . Các câu truy vấn SPARQL có rất nhiều dạng. Dạng mệnh đề SELECT mà chúng ta xem xét đến bây giờ trả về những biến ràng buộc. Dạng mệnh đề CONSTRUCT có thể được dùng trong khởi tạo những kết quả mà định nghĩa một đồ thị RDF (RDF Graph). Những câu truy vấn cũng có thể chỉ định nhiều hơn một mẫu đồ thị (graph pattern) mà tất cả chúng hoặc một vài trong chúng phải khớp với dữ liệu RDF. Những kết quả truy vấn cũng có thể được xử lý thêm bằng cách cung cấp một cách trực tiếp các lệnh để sắp xếp chúng, loại bỏ trùng lặp kết quả, hoặc giới hạn số lượng các kết quả được trả về. . 3. Property Graphs - Đồ thị thuộc tính . Mô hình dữ liệu thuộc tính được sử dụng bởi nhiều hệ thống cơ sở dữ liệu đồ thị. Không giống như RDF được thúc đẩy bởi nhu cầu mô hình hoá thông tin dữ liệu trên web, hệ thống sơ cở dữ liệu xử lý dữ liệu đồ thị tổng quát. Những hệ thống cơ sở dữ liệu đồ thị (Graph Database Systems) tách biệt bản thân chúng với cơ sở dữ liệu quan hệ truyền thống (Traditional Relational Databases) với sự phụ rất ít vào một lược đồ được định nghĩa từ trước, và tối ưu sự vận hành nhờ vào duyệt đồ thị (Graph Traversals). Trong mục này, chúng ta sẽ xem xét mô hình dữ liệu đồ thị thuộc tính và ngôn ngữ Cypher được dùng để truy vấn nó. . 3.1 Mô hình dữ liệu đồ thị thuộc tính (Property Graph Data Model) . Một mô hình dữ liệu đồ thị thuộc tính (Property Graph Data Model) bao gồm các nút (node), những mối quan hệ (relationships) và những thuộc tính (properties). Mỗi một nút có một nhãn và một tập các thuộc tính dưới dạng bất kỳ những cặp key-value. Các key là những chuỗi (string) và các value là kiểu dữ liệu bất kỳ. Một quan hệ là một cạnh liên kết có hướng giữa hai node (nút), có một nhãn và có thể có một tập các thuộc tính. . Trong đồ thị thuộc tính sau đây art và bea là hai node. Node cho bea có hai thuộc tính: age và based_near. Hai nút (node) được nối bằng một cạnh liên kết với nhãn là knows. Cạnh liên kết này có thuộc tính since chỉ năm mà art và bea quen biết nhau . . Trong lúc định nghĩa một thuộc mô hình dữ liệu đồ thị thuộc tính, chúng ta phải quyết định những nút (nodes), những cạnh liên kết (edges) và những thuộc tính (properties). Ví dụ như chúng ta có thể hỏi tại sao không biểu diễn một thành phố như một nút, và khởi tạo một nhãn based_near giữa một người (a person) và một thành phố (a city) thay vì tạo ra một thuộc tính của một nút biểu diễn một người. Một cách tổng quát, bất kỳ giá trị nào có liên hệ với nhiều nút (nodes) khác trong một đồ thị sao cho có yêu cầu ứng dụng để duyệt trên các mối quan quan hệ đó một cách hiệu quả, hoặc chúng cần liên kết các thuộc tính bổ sung với cách nó liên hệ với những nút khác, bản thân nó nên được biểu diẽn như một nút. . . 3.2 Cypher Query Language . Cypher là một ngôn ngữ dùng trong truy vấn dữ liệu được biểu diễn trong một mô hình dữ liệu đồ thị thuộc tính. Những khái niệm thiết kế từ Cypher đang được xem xét để trở thành một chuẩn ISO cho một ngôn ngữ truy vấn đồ thị. Ngoài việc truy vấn, Cypher cũng có thể được sử dụng để khởi tạo (create), cập nhật (update) và loại bỏ (delete) dữ liệu từ một cơ sở dữ liệu đồ thị. Trong phần này, chúng ta sẽ điểm qua một vài khả năng truy vấn của Cypher . Ví dụ sau đây về truy vấn Cypher dựa trên dữ liệu đồ thị được đề cập từ đầu và những truy vấn cho những người được quen biết bởi art. Câu truy vấn gồm hai phần: mệnh đề MATCH chỉ định một mẫu đồ thị (graph patterns) mà nên khớp dựa trên dữ liệu đồ thị và mệnh đề RETURN chỉ định câu truy vấn nên trả về cái gì. Mẫu đồ thị (graph pattern) được chỉ định trong định nghĩa ASCII cho đồ thị: Mỗi một nút được viết trong dấu ngoặc đơn (parentheses) và mỗi một cạnh liên kết được viết bởi một dấu mũi tên (arrow). Cả thông số nút (node) và quan hệ (relation) đều bao gồm các kiểu tương ứng của chúng và bất kỳ thuộc tính bổ sung nào cần được đối sánh. . MATCH (p1:Person {name: art}) -[:knows]-&gt; (p2: Person) . RETURN p2 . Ví dụ dưới đây, chúng ta thấy cách mà Cypher truy vấn với câu hỏi cho tất cả những người bạn của một người biết nhau từ năm 2010 . MATCH (p1:Person {name:art}) -[:knows {since: 2010}]-&gt; (p2: Person) . RETURN p2 . Từ câu truy vấn ở trên, chúng ta có thể thấy việc liên kết các thuộc tính với những quan hệ cũng dễ dàng như liên kết chúng với các nút. Một người có thể có nhiều người bạn từ những năm trước 2010, và nếu chúng ta muốn truy vấn bao gồm những người bạn đó, chúng ta có thể thêm một mệnh đề WHERE . MATCH (p1:Person {name:art}) -[:knows {since: Y}]-&gt; (p2: Person) . WHERE Y &lt;= 2010 . RETURN p2 . Thông qua mệnh đề WHERE, có thể chỉ định nhiều ràng buộc bộ lọc giống như các mẫu có thể sử dụng để giới hạn các kết quả truy vấn. Hơn nữa,Cypher cung cấp cấu trúc ngôn ngữ cho việc đếm các kết quả (counting results), gom nhóm dữ liệu bởi những giá trị (grouping data by values), tìm giá trị cực đại/ cực tiểu (minimum/ maximum values) và một số toán tử toán học khác. . 4. Comparison of Data Models - So sánh các mô hình dữ liệu . Trong mục này, chúng ta sẽ bắt đầu so sánh RDF và mô hình dữ liệu đồ thị thuộc tính. Chúng ta cũng sẽ so sánh cả hai thứ này với mô hình dữ liệu quan hệ. . 4.1 Comparison of RDF and Property Graph Data Models . Ngoài các đặc trưng của RDF được đề cập trong những mục trước, nó có nhiều tầng (layers) bổ sung, ví dụ như lược đồ RDF, Web Ontology Language (OWL),… Trong phần này, chúng ta không cần phải đề cập đến những đặc trưng cao cấp này. . Những điểm chính khác biệt giữa mô hình RDF cơ bản và mô hình dữ liệu đồ thị thuộc tính (Property Graph Model) . - Mô hình dữ liệu đồ thị thuộc tính (Property Graph Model) cho phép những cạnh liên kết có những thuộc tính . - Mô hình dữ liệu đồ thị thuộc tính (Property Graph Model) không yêu cầu IRIs và không hỗ trợ những node trống (blank node). . Để hỗ trợ thuộc tính cạnh, mô hình RDF hỗ trợ một mở rộng (extension) gọi là reification. Chúng ta sẽ đề cập phần mở rộng (extension) này và sau đó mô tả các cách khác nhau mà dữ liệu được biểu diễn trong mô hình dữ liệu này có thể được chuyển đổi (convert) sang một dạng khác. . Để hiểu sự tái tổ chức - reification trong RDF, xem xét một tình huống mà chúng ta cần biểu diễn nguồn gốc của một bộ ba sau đây. Bộ ba này xác nhận trọng lượng của một mặt hàng. Chữ “2,4” ^^ xsd: decimal biểu thị số 2,4 thuộc kiểu xsd: decimal. Chúng ta quan tâm đến người chỉ định thức hiện phép đo này . exproducts:item10245 exterms:weight “2.4”^^xsd:decimal . Chúng ta có thể liên kết những thông tin xuất xứ với bộ ba phía trên bằng cách dùng từ vựng RDF reification. Từ vựng RDF reification bao gồm kiểu rdf:Statement, thuộc tính rdf:subject, rdf:predicate và rdf:object. Bẳng cách bộ từ vựng reification, một tái tổ chức của một mệnh đề về trọng lượng của một mặt hàng nên được cho bởi phép gán mệnh đề IRI giống như exproducts:triple12345 (vì vậy các câu lệnh có thể được viết mô tả nó), và sau đó mô tả mệnh đề như bên dưới đây. Bộ ba cuối cùng trong danh sách chỉ định thông tin xuất xứ mong muốn bằng cách xác nhận số nhận dạng cho người đã tạo bộ ba ban đầu. .   . exproducts:triple12345 rdf:type rdf:Statement . | . exproducts:triple12345 rdf:subject exproducts:item10245 . | . exproducts:triple12345 rdf:predicate exterms:weight . | . exproducts:triple12345 rdf:object “2.4”^^xsd:decimal . | . exproducts:triple12345 dc:creator exstaff:85740 . | . Những mệnh đề này nói rằng tài nguyên được định danh bởi IRI exproducts:triple12345 là một mệnh đề RDF, mà chủ thể của mệnh đề tham chiếu đến tài nguyên được định danh bởi exterms:weight và đối tượng của mệnh đề tham chiều tới giá trị thập phân được định danh bởi kiểu của chữ “2.4” ^^xsd:decimal. Cuối cùng mệnh đề xác nhận rằng exproducts:triple12345 được cung cấp bởi người với IRI là exstaff:8574 . Với từ vựng tái tổ chức, nó có thể dịch một cách máy móc dữ liệu trong mô hình đồ thị thuộc tính sang RDF. Mỗi node và giá trị thuộc tính của nó trong dữ liệu đồ thị thuộc tính trở thành một bộ ba. Mỗi cạnh liên kết trong dữ liệu đồ thị thuộc tính cũng trở thành một bộ ba RDF. Mọi cạnh liên kết trong dữ liệu đồ thị thuộc tính có thuộc tính được tái tổ chức, và những thuộc tính của cạnh liên kết trở thành bộ ba của cạnh được tái tổ chức bằng cách sử dụng từ vựng tái tổ chức như giải thích bên trên :v . Để dịch dữ liệu được biểu diễn trong mô hình RDF sang mô hình đồ thị thuộc tính, cách tiếp cận dễ dàng nhất là ánh xạ mỗi node và mỗi cạnh tương ứng với node và một cạnh trong đồ thị thuộc tính. Một tái tổ chức khả thi là chúng ta chỉ tạo các nút thuộc tính mới cho những nút là IRI hoặc nút trống. Với bất kỳ một bộ ba nào trong RDF mà mục tiêu là chữ (literal), chúng ta tạo cho chúng một thuộc tính của node trong dữ liệu đồ thị thuộc tính. . Ngoài ra để chuyển đổi dữ liệu giữa các mô hình RDF và đồ thị thuộc tính, chúng ta cũng quan tâm đến chuyển đổi hình thức cú pháp của dữ liệu và các câu truy vấn. Với mô hình dữ đồ thị thuộc tính, không có một chuẩn cú pháp cho những biểu thức, do vậy một trình dịch tùy chỉnh cần được viết cho định dạng mà người đó đang làm việc với. Một lần dịch lược đồ là cố định giữa hai mô hình, nên dịch giữa SPARQL và Cypher cũng đơn giản. . 4.2 Comparison of Graph Models and Relational Data Model - So sánh mô hình đồ thị và mô hình dữ liệu quan hệ . Chúng ta có thể định nghĩa một phép dịch và và từ dữ liệu được thể hiện bằng cách sử dụng mô hình dữ liệu quan hệ sang dữ liệu được thể hiện bằng cách sử dụng mô hình RDF và mô hình đồ thị thuộc tính. Một số ý kiến rằng các mô hình đồ thị thì dễ dàng hiểu hơn đối với con người và các ngôn ngữ truy vấn đồ thị thì gọn hơn với những những truy vấn xác định. Về nguyên tắc, chúng ta có thể cài đặt một một giao diện người dùng để trực quan hoá lược đồ quan hệ, và cài đặt trình biên dịch truy vấn mà có thể ánh xạ câu truy vấn được viết bằng ngôn ngữ truy vấn đồ thị thành một dạng tương đương mà có thể thực hiện trên những bảng quan hệ. Nếu một ứng dụng yêu cầu điều hướng mối quan hệ, một cơ sở dữ liệu đồ thị có những cạnh liên kết có lợi thế vì nó tối ưu được trong việc duyệt đồ thị. Cho phần còn lại của mục này, chúng ta xem xét một ví dụ cụ thể xem cách mà những câu truy vấn đồ thị nhỏ gọn hơn so với những câu truy vấn quan hệ tương ứng, và kết luận bằng cách đề cặp một số hệ thông quan hệ cố gắng hỗ trợ xử lý đồ thị . Để hiểu sự tương phản giữa truy vấn đồ thị và truy vấn quan hệ, chúng ta xem xét một ví dụ đơn giản trong đó chúng ta có 3 bảng: một bảng Employee, một bảng Department và một bảng kết Employee_Department. Một nhân viên (employee) có thể được liên kết với nhiều phòng ban (Department) vì chúng được lưu trữ trong các bảng riêng biệt. Hai bảng liên hệ bằng một bảng kết gồm các khoá ngoại employee id và department id. . . Giả định rằng chúng ta muốn xuất ra danh sách những nhân viên thuộc phòng ban IT (có thể có thể nói là vua của các phòng ban :)) Câu truy vấn SQL thực hiện nhiệm vụ này đầu tiên cần kết bảng employee và bảng department và sau đó lọc ra những kết quả trên tên của phòng ban (department) .   . SELECT name FROM Employee | . LEFT JOIN Employee_Department | . ON Employee.Id = Employee_Department.EmployeeId | . LEFT JOIN Department | . ON Department.Id = Employee_Department.DepartmentId | . WHERE Department.name = “IT” | . Nếu chúng ta muốn biểu diễn thông tin tương tự bằng cách sử dụng một mô hình dữ liệu đồ thị, chúng ta sẽ cần một node cho department và employee. Employee ssn và department name sẽ là những thuộc tính của node. Bảng Employee_Department sẽ được nắm bắt bằng một mối quan hệ trong biểu diễn đồ thị thuộc tính. Nếu bảng bảng Employee_Department có những thuộc tính bổ sung, chúng sẽ được biểu diễn như thuộc tính cạnh liên kết trong mô hình dữ liệu đồ thị. Một mẫu node với một thuộc tính đồ thị như sau: . . Chúng ta có thể truy vấn dữ liệu bằng cách sử dụng câu truy vấn Cypher sau đây .   . MATCH (p:Employee) -[:works_in]-&gt; (d:Department) | . WHERE d = “IT” | . RETURN p | . Truy vấn Cypher ở trên nhỏ gọn hơn nhiều so với truy vấn SQL của nó. Sự nhỏ gọn này bắt nguồn từ thực tế là các phép nối được nắm bắt một cách tự nhiên bằng cách sử dụng các mẫu đồ thị (graph patterns). . Gần đây, có nhiều hệ thống biểu diễn dữ liệu quan hệ theo cách không có lược đồ bằng cách biểu diễn mỗi thuộc tính nút dưới dạng bộ ba trong một bảng và mỗi thuộc tính cạnh dưới dạng bốn bộ trong bảng thứ hai. Những hệ thống như vậy, cung cấp một bộ lập kế hoạch truy vấn cho phép truy vấn bằng một ngôn ngữ giống Cypher mà có thể tính toán hiệu quản qua hai bảng quan hệ. Những hệ thống như thế có khả năng tận dụng công nghệ quan hệ hiện có và cũng có thể thực hiện tối ưu hóa khi một số dữ liệu kế thừa nằm trong bảng quan hệ truyền thống. . 5. Limitations of a Graph Data Model - Giới hạn của một mô hình dữ liệu đồ thị . Một mô hình dữ liệu đồ thị không hẳn là một lựa chọn thích hợp nhất khi ứng dụng bao gồm chủ yếu là dữ liệu số, và chỉ dựa vào mối quan hệ nhị phân. Ví dụ như, mô hình quan hệ thì hiệu quả hơn trong việc nắm bắt những dữ liệu chuỗi thời gian (time series data) giống như sự phát triển dân số của một quốc gia. Mặc dù chúng ta có thể biểu diễn những dữ liệu như thế bằng cách sử dụng một đồ thị, nhưng kết quả trong một số lượng lớp bộ ba mà không nhất thiết mang lại cho chúng ta lợi thế về sự hiểu biết khái niệm tốt hơn và / hoặc hiệu suất truy vấn nhanh hơn thông qua duyệt đồ thị . Có rất nhiều mối quan hệ không thể được biểu diễn một cách tự nhiên bằng mối quan hệ nhị phân. Ví du như, mối quan hệ của đối tượng A là giữa đối tượng B và C tức là một mối quan hệ ba ngôi. Một quan hệ ba ngôi có thể được biến đổi thành một tập hợp các quan hệ nhị phân bằng cách sử dụng kỹ thuật tái tổ chức (reification technique), nhưng mà làm như thế, chúng ta sẽ đánh mất đi lợi thế của việc hiểu khái niệm (better conceptual understanding) mà chúng ta nhận được từ mô hình dữ liệu đồ thị. Đồ thị cũng không phải là một biểu diễn tự nhiên nhất cho các phương toán học và phản ứng hoá học, khi tồn tại các biểu diễn cụ thể theo miền dễ hiểu . Bài tập: . …Sẽ cập nhật sau… . Bài giảng gốc: https://web.stanford.edu/class/cs520/2020/notes/What_Are_Graph_Data_Models.html .",
            "url": "https://nhutnamhcmus.github.io/lenux-notebooks/2021/06/26/what-are-some-knowledge-graph-data-models.html",
            "relUrl": "/2021/06/26/what-are-some-knowledge-graph-data-models.html",
            "date": " • Jun 26, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "How To Create A Knowledge Graph From Data",
            "content": "ĐỒ THỊ TRI THỨC - KNOWLEDGE GRAPH . Đây là bản dịch từ Course CS520: Knowledge Graphs | Data Models, Knowledge Acquisition, Inference and Applications | . Department of Computer Science, Stanford University, Spring 2021 . Knowledge graphs have emerged as a compelling abstraction for organizing world’s structured knowledge over the internet, capturing relationships among key entities of interest to enterprises, and a way to integrate information extracted from multiple data sources. Knowledge graphs have also started to play a central role in machine learning and natural language processing as a method to incorporate world knowledge, as a target knowledge representation for extracted knowledge, and for explaining what is being learned. This class is a graduate level research seminar and will include lectures on knowledge graph topics (e.g., data models, creation, inference, access) and invited lectures from prominent researchers and industry practitioners. The seminar emphasizes synthesis of AI, database systems and HCI in creating integrated intelligent systems centered around knowledge graphs. . Mục đích: Là tìm hiểu cũng như trau dồi kiến thức chuyên môn trong lĩnh vực Knowledge Graph cũng như từ vựng tiếng Anh. Không vì mục đích kinh doanh hay bất cứ mục đích về lợi nhuận, tất cả là vì mục đích chia sẻ kiến thức và học tập. . Mọi thông tin về những chủ đề được note lại có thể tìm thấy ở đây: . https://web.stanford.edu/class/cs520/2020/notes/Table_Of_Contents.html . Video của các buổi seminar cũng được công khai trên địa chỉ Youtube: . https://www.youtube.com/playlist?list=PLDhh0lALedc5paY4N3NRZ3j_ui9foL7Qc . Mọi vấn đề về dịch thuật, thuật ngữ xin để lại comment hoặc gửi về địa chỉ email: lenam.fithcmus@gmail.com với tiêu đề . [ISSUES OF KG TRANSLATION] . HOW TO CREATE A KNOWLEDGE GRAPH FROM DATA . 1. Giới thiệu . Những tổ chức lớn tạo ra lượng lớn dữ liệu nội bộ và cũng tiêu thụ dữ liệu được tạo ra bởi các nhà cung cấp bên thứ ba (third party providers). Nhiều nhà cung cấp dữ liệu có được dữ liệu bằng cách xử lý nhưng nguồn phi cấu trúc, và đầu tư một nổ lực đáng kể trong việc cung cấp nó trong một dạng có cấu trúc cho việc sử dụng của người dùng. Để sử dụng hiệu quả những dữ liệu bên ngoài, nó phải liên quan tới dữ liệu bên trong công ty, Như tích hợp dữ liệu cho phép nhiều trường hợp sử dụng phổ biến như 360 view of a customer - góc nhìn 360 độ của khách hàng, fraud detection - phát hiện gian lận, risk assessment - đánh giá rủi ro, loan approval - phê duyệt khoản vay, .. Với chương này, chúng ta sẽ thảo luận vấn đề khởi tạo một đồ thị tri thức bằng cách tích hợp dữ liệu có sẵn từ những nguồn có cấu trúc. Chúng ta sẽ xem xét vấn đề của việc rút trích dữ liệu từ những nguồn dữ liệu phi cấu trúc trong chương tiếp theo :v . Khi kết hợp dữ liệu từ nhiều nguồn vào một đồ thị tri thức, chúng ta có thể thực hiện một số thiết kế sơ đồ như chúng ta đã thảo luận trong chương trước :v Chúng ta cũng bắt đầu mà không cần lược đồ vì việc tải dữ liệu bên ngoài thẳng vào như bộ ba vào một đồ thị tri thức rất dễ dàng. Thông thường, thiết kế ban đầu của lược đồ dựa trên trường hợp cụ thể mà người ta muốn giải quyết. Ở mức độ tồn tại ban đầu của lược đồ như thế, chúng ta phải quyết định các thành phần dữ liệu từ một nguồn dữ liệu mới nên được thêm vào đồ thị tri thức như thế nào. Điều này thường được biết đến là vấn đề schema mapping - vấn đề ánh xạ lược đồ. Hơn nữa, để liên hệ lược đồ của hai nguồn, chúng ta cũng phải giải quyết khả năng mà một thực thể trong dữ liệu đến (ví dụ như một Company) có thể đã tồn tại trong đồ thị tri thức của chúng ta. Vấn đề suy luận nếu hai thực thể trong dữ liệu có thể cùng là một thực thể trong thế giới thực được gọi là vấn đề record linkage - mẫu ghi liên kết. Vấn đề mẫu ghi liên kết cũng xuất hiện khi các nhà cung cấp dữ liệu bên thứ ba gửi những nguồn cấp dữ liệu mới (a new data feeds), và đồ thị tri thức của chúng ta phải được cập nhật (up-to-daye) với những nguồn dữ liệu mới này. . Trong chương này, chúng ta sẽ cùng thảo luận những tiếp cận hiện tại cho giải quyết vấn đề ánh xạ lược đồ và vấn đề mẫu ghi liên kết. Chúng ta sẽ nêu những thuật toán state-of-the-art và thảo luận về mức độ hiệu qủa của chúng trong những vấn đề của ngành :v . 2. Ánh xạ lược đồ - Schema Mapping . Ánh xạ lược đồ giả định rằng tồn tại một lược đồ mà sẽ được sử dụng cho viêc lưu trữ dữ liệu mới đến từ một nguồn khác. Ánh xạ lược đồ sau đó xác định những quan hệ và thuộc tính nào trong cơ sở dữ liệu đầu vào tương ứng với những thuộc tính và quan hệ trong đồ thị tri thức. Tồn tại những kỹ thuật cho bootstrapping schema mappings. Bootstrapped schema mappings có thể được điều chỉnh thông qua sự can thiệp của con người. . Chúng ta sẽ bắt đầu thảo luận về ánh xạ lược đồ bằng cách nêu ra một số thách thức và nhận định liệu chúng ta có nên chuẩn bị cho việc phần lớn quá trình này có thể thực hiện thủ công và tốn nhiều công sức. Sau đó, chúng ta mô tả một tiếp cận cho việc chỉ định ánh xạ giữa lược đồ nguồn đầu vào và lược đồ của đồ thị tri thức. Chúng ta sẽ kết thúc mục này bằng đề cập một vài kỹ thuật có thể được sử dụng cho bootstrap schema mapping. . 2.1 Những thách thức với Ánh xạ lược đồ - Schema Mapping . Những thách thức chính trong tự động ánh xạ lược đồ . - (1) Khó để hiểu lược đồ . - (2) Độ phức tạp của việc ánh xạ . - (3) Ít dữ liệu huấn luyện có sẵn . Chúng ta sẽ thảo luận chi tiết hơn những thách thức này . Lược đồ cơ sở dữ liệu quan hệ thương mại (Commercial relational database schemas) có thể rất lớn bao gồm hàng ngàn quan hệ và hàng vạn thuộc tính. Thỉnh thoảng, tên của những quan hệ và thuộc tính không có ngữ nghĩa (ví dụ, segment1, segment2 @@ ) mà không liên quan gì bản thân chúng với bất kỳ dự đoán tự động thực tế nào của ánh xạ. . Ánh xạ giữa lược đồ đầu vào và lược đồ trong đồ thị tri thức không phải lúc nào cũng đơn giản là ánh xạ 1-1 (one-to-one mapping). Ánh xạ có thể liên quan tới những tính toán, áp dụng logic kinh doanh và có những luật đặc biệt cho việc xử lý tình huống như là missing values. Nó trở thành một sự kỳ vọng quá cao đối với bất kỳ quá trình xử lý tự động nào suy diễn những phép ánh xạ phức tạp như vậy. . Cuối cùng, nhiều giải pháp ánh xạ tự động dựa trên các kỹ thuật Máy học (Machine Learning techniques) yêu cầu một lượng lớn dữ liệu huấn luyện để hoạt động một cách hiệu quả. Như lược đồ thông tin, bằng định nghĩa, nhỏ hơn nhiều dữ liệu bản thân nó, rất là viễn vong để kỳ vọng rằng chúng sẽ có một lượng lớn ánh xạ lược đồ sẵn có để một thuật toán ánh xạ có thể được huấn luyện. . 2.2 Xác định Ánh xạ lược đồ - Specifying Schema Mapping . Trong phần này, chúng ta sẽ đề cập một phương pháp tiếp cận khả thi để xác định ánh xạ giữa nguồn dữ liệu đầu vào và một mục tiêu trong lược đồ đồ thị tri thức. Chúng ta sẽ lấy một ví dụ trong lĩnh vực dụng cụ nấu ăn. Chúng ta có thể tưởng tượng những nhà cung cấp khác nhau cung cấp các mặt hàng trên một trang thương mại điện tử (E-commerce site) có mong muốn tổng hợp và quảng bá đến khách hàng của họ. Chúng ta sẽ xem xét hai nguồn ví dụ và sau đó thêm vào lược đồ đồ thị tri thức để mà chúng ta sẽ định nghĩa các ánh xạ. . Chúng ta hiển thị một vài mãu dữ liệu từ nguồn dữ liệu đầu tiên trong một bảng quan hệ gọi là cookware. Nó có bốn thuộc tính: name, type, material, và price . . Cơ sở dữ liệu thứ hai được hiển thị bên dưới cho thấy danh sách những sản phẩn của một nhà sản suất. Trong trường hợp này, có nhiều bảng, một bảng ứng với một thuộc tính sản phẩm. Bảng kind xác định loại của mỗi sản phẩm. Bảng base xác định mỗi sản phẩm được làm từ kim loại ăn mòn -corrosible metal (nhôm - aluminum hoặc không gỉ - stainless), kim loại không ăn mòn - noncorrosible metal (sắt - iron hoặc thép - steel) hay thứ gì đó không phải kim loại (thủy tinh hoặc gốm - ceramic). Bảng coated xác định những sản phẩm này có phủ chống dính hay không (nonstick coatings). Bảng price cho thông tin về giá bán. Không có thông về vật liệu. Công ty được chọn không cung cấp thông tìn về kim loại được sử dụng trong mỗi sản phải. Lưu ý rằng, bản coated chỉ có những giá trị dương; những sản phẩm mà không có lớp phủ chống dính không được đề cặp đến. . . Giả sử rằng lược đồ mong muốn cho đồ thị tri thức được biểu diễn như một đồ thị thuộc tính được cho ở bên dưới đây. Chúng ta có hai loại nút khác nhau: một cho sản phẩm - Product, và cái kia cho các nhà cung cấp – Supplier. Hai nút này liên kết với nhau bởi một mối quan hệ gọi là has_supplier. Mỗi nút sản phẩm có những thuộc tính là “type” và “price” . . Để xác định lược đồ ánh xạ và để xử lý cụ thể, chúng ta sẽ sử dụng định nghĩa một bộ ba để mà một xử lý tương tự có thể áp dụng bất kể chúng ta sử dụng mô hình dữ liệu đồ thị thuộc tính hay mô hình RDF cho đồ thị tri thức. Với một đồ thị tri thức RDF, chúng sẽ cần phải khởi tạo IRI, tức một quá trình trực giao để liên hệ hai lược đồ, và ở đây chúng ta bỏ qua điều này. Những bộ ba mong muốn trong mục tiêu đồ thị tri thức được liệt kê bằng bảng dưới đây. . Bất kỳ ngôn ngữ lập trình nào có thể dược sử dụng để biểu diễn ánh xạ. Ở đây, chúng ta chọn sử dụng Datalog để biểu diễn ánh xạ. Các luật dưới đây rất đơn giản. Các biến được biểu thị bằng cách sử dụng các chữ cái in hoa. Luật thứ ba thêm ràng buộc vender_1 để chỉ ra nguồn dữ liệu. . knowledge_graph(ID,type,Type) :- cookware(ID,TYPE,MATERIAL,PRICE) knowledge_graph(ID,price,PRICE) :- cookware(ID,TYPE,MATERIAL,PRICE) knowledge_graph(ID,has_supplier,vendor_1) :- cookware(ID,TYPE,MATERIAL,PRICE) . Kế đến, chúng ta xem xét những luật cho việc ánh xạ nguồn dữ liệu thứ hai. Những luật cũng khá là tương tự như những luật ánh xạ cho nguồn dữ liệu thứ nhất ngoài trừ là thông tin bây giờ thì đến từ hai bảng khác nhau trong nguồn dữ liệu . knowledge_graph(ID,type,Type) :- kind(ID,TYPE) . knowledge_graph(ID,price,PRICE) :- price(ID,PRICE) . knowledge_graph(ID,has_supplier,vendor_2) :- kind(ID,TYPE) . Tổng quát mà nói, nó không hợp lý khi sử dụng lại các bộ định danh từ cơ sở dữ liệu nguồn, và chúng ta mong muốn là tạo ra những bộ định danh mới cho việc sử dụng trong đồ thị tri thức. Trong một số trường hợp, đồ thị tri thức có thể đã chứa những đối tượng tương đương với chúng trong dữ liệu được nhập. Chúng ta sẽ xem xét vấn đề này trong phần mẫu ghi liên kết - record linkage . 2.3 Bootstrapping Schema Mapping . Như được đề cập ở phần 2.1, một tiếp cận hoàn toàn tự động để ánh xạ lược đồ đối mặt với rất nhiều khó khăn trong thực tế. Ở đây đề cập một công trình về bootrapping the schema mappings dựa trên nhiều kỹ thuật và xác nhận chúng bằng đầu vào con người. Những kỹ thuật Boostrapping cho ánh xạ lược đồ có thể được phân loại thành những loại sau đây: . - (1) Linguistic matching - Kết hợp ngôn ngữ học . - (2) Matching based on instances - Kết hợp dựa trên thể hiện . - (3) Matching based on constraints - Kết hợp dựa trên ràng buộc . Những kỹ thuật ngôn ngữ học có thể được sử dụng trên tên của một thuộc tính hoặc trên những văn bản mô tả của một thuộc tính. Các tiếp cận đầu tiên và cũng rõ ràng nhất là kiểm tra tên của hai thuộc tính là bằng nhau hay không. Chúng ta có thể có một độ tin cậy cao trong so sánh bằng nếu những tên là IRIs. Thứ hai, chúng ta có thể chuẩn hoá tên bằng cách xử lý chúng thông qua một số kỹ thuật như stemming và kiểu tra tính bằng nhau. Lấy ví dụ, thông qua xử lý, chúng ta có thể kết luận ánh xạ của CName đến Customer Name. Thứ ba, chúng ta có thể kiểm tra ánh xạ dựa trên từ đồng nghĩa - synonyms (ví dụ như là: car và automobile) hoặc từ siêu nghĩa - hypernyms (ví dụ như là book và publication). Thứ tư, chúng ta có thể kiểm tra ánh xạ dựa trên những chuỗi con chung, phát âm chung, và cách mà những từ đó được phát âm. Và cuối cùng, chúng ta có thể kết hợp những mô tả của những thuộc tính thông qua những kỹ thuật ngữ nghĩa tương đồng (semantic similarity techniques). Ví dụ, một cách tiếp cận để rút trích những từ khoá từ phần mô tả và sau đó kiểm tra độ tương đồng giữa chúng bằng cách sử dụng những kỹ thuật mà chúng ta đã nếu ra. . Trong kết hợp dựa trên những thể hiện, người ta kiểm tra loại dữ liệu có tồn tại. Ví dụ, nếu một giá trị thuộc tính cụ thể mang kiểu dữ liệu ngày tháng, nó chỉ có thể kết hợp dựa trên những thuộc tính mang những giá trị ngày tháng. Nhiều kiểu dữ liệu chuẩn hoá có thể được suy diễn bằng cách kiểu tra dữ liệu . Trong một số trường hợp, lược đồ cung cấp thông tin về những ràng buộc. Ví dụ, nếu một lược đồ xác định một thuộc tính cụ thể là đơn nhất đối với một cá thể, và phải là số, nó là một đối sánh tiềm năng hoặc các thuộc tính xác minh như số nhân viên hoặc số an sinh xã hội. . Những kỹ thuật được đề cặp ở đây là không chính xác và do đó có thể chỉ sử dụng để boostrap quá trình trình ánh xạ lược đồ. Bất kỳ ánh xạ nào cũng phải được xác minh và xác nhận bởi những người chuyên gia. . 3. Ghi liên kết - Record Linkage . Chúng ta sẽ bắt đầu thảo luận về vấn đề mẫu ghi liên kết bằng một ví dụ cụ thể. Sau đó, chúng ta sẽ đưa ra một cái nhìn tổng quan về một phương pháp tiếp cận điển hình để giải quyết vấn đề này. . 3.1 Vấn đề mẫu ghi liên kết - A Sample Record Linkage Problem . Giả sử rằng chúng ta có dữ liệu với hai bảng. Vấn đề mẫu ghi liên kết liên quan tới việc dự đoán mẫu ghi $a_1$ giống với mẫu ghi $b_1$ và mẫu ghi $a_3$ giống với mẫu ghi $b_2$. Giống như việc ánh xạ lược đồ, đây là những dự đoán không chính xác và cần phải được xác nhận bởi con người. . . Một đồ thị tri thức lớn có thể chứa lượng thông tin trên 10 triệu công ty. Nó có thể nhận một nguồn cung cấp dữ liệu, mà được rút trích từ văn bản ngôn ngữ tự nhiên. Những nguồn cung cấp dữ liệu như thế có thể chứa hơn 100,000 công tin. Cho dù nếu một đồ thị tri thức có một phương thức chuẩn hoá để tham chiếu đến những công tin, nhưng nguồn dữ liệu mới được rút trích từ văn bản sẽ không có những bộ định danh chuẩn hoá. Tác vụ mẫu ghi liên kết là liên hệ những công ty mà chứa những nguồn cung cấp mới với những công ty đã tồn tại trong đồ thị tri thức. Vì các khối dữ liệu rất lớn, thực hiện tác vụ này một cách hiểu quả là điều tối quan trọng. . 3.2 Phương pháp tiếp cận giải quyết vấn đề mẫu ghi liên kết . Độ hiệu quả của mẫu ghi liên kết (record linkage) liên quan tới hai bước: blocking và matching. Bước blocking liên quan tới một tính toán nhanh để chọn ra một tập con những mẫu ghi từ nguồn và mục tiêu mà sẽ được xem trong suốt một bước đối sánh chính xác và tốn kém hơn. Trong bước matching, chúng tôi đối sánh theo từng cặp với tập hợp con các bản ghi đã được chọn trong quá trình blocking. Trong ví dụ được đề cập ở trên, chúng ta có thể sử dụng một chiến lược blocking xem xét đối sánh chỉ những mẫu ghi mà phù hợp với trạng thái. Với chiến lược đó, chúng ta chỉ cần phải xem xét sự phù hợp $a_1$ với $b_1$, $a_3$ với $b_2$ do đó giảm đáng kể số lần so sánh phải thực hiện. . Cả hai bước blocking và matching thực hiện bằng cách học một random forest thông qua một quá trình học chủ động (active learning process). Một random forest là một tập của các luật quyết định mà được cho bởi những dữ đoán cuối cùng thông qua đa số phiếu được bầu được trả về bởi những luật riêng lẻ. Active learning (Học chủ động) là một quá trình học mà được xây dựng random forest bằng cách chủ động theo dõi hiệu suất của nó trên tập dữ liệu kiểm tra và lựa chọn có chọn lọc những mẫu huấn luyện mới để cải thiện hiệu suất của nó. Chúng ta sẽ giải thích chi tiết hơn hai bước này ở phần kế tiếp. . 3.3 Random Forests . Những luật blocking dựa trên hàm kiểm tra chuẩn hoá độ tương đồng, giống như, độ phụ hợp chính xác - exact match, tương đồng Jaccard - Jaccarc Similarity, tương đồng chồng chéo - overlap similarity, tương đồng cosin - cosine similarity, … Lấy ví dụ, nếu chúng ta đã kiểm tra tương đồng chồng chéo giữa “Prolific Consulting” và “Prolific Consulting Inc.”, đầu tiên chúng ta sẽ thu thập những token trong mỗi chúng, và sau đó kiểm tra những token nào là chung, cho chung ta một điểm tương đồng là 2/3 . Chúng ta biểu diễn một phần của một random forest cho blocking. Một random forest có thể được quan sát như một tập các luật. Random forest được hiển thị bên dưới là một tập của hai tập hợp luật. Các đối số của mỗi vị từ là hai giá trị được so sánh. . . Có nhiều nguyên lý tổng quát cho việc tự động hoá việc chọn hàm tương đồng (similarity functions) cho luật blocking. Ví dụ, với những thuộc tính mang giá trị số học như tuổi – age, trọng lượng – weight, giá cả – price, … những hàm tương đồng ứng viên có thể là: khớp chính xác - exact match, hiệu tuyệt đối - absolute difference, hiệu tương đối - relative difference, và khoảng cách Levenstein - Levenstein distance. Với những thuộc tính mang giá trị chuỗi (string), người ta thường dùng edit distance, cosine similarity, Jaccard similarity, và TF/IDF functions. . 3.4 Active Learning of Random Forests . Chúng ta có thể áp dụng Random Forest cho những luật blocking thông qua theo đổi quá trình học chủ động (active learning process). Chúng ta chọn một cách ngẫu nhiên một tập những cặp từ hai bộ dữ liệu. Bằng cách áp dụng hàm tương đồng lên mỗi thành phần của cặp, chúng ta có được một tập những đặc trưng cho mỗi cặp đó. Sử dụng những đặc trưng này, chúng ta sử dụng một Random Forest. Chúng ta áp dụng những luật có được lên một cặp mới được chọn từ tập dữ liệu, và đánh giá hiệu suất của chúng. Nếu hiệu suất dưới một ngưỡng (threshold) nhất định, chúng ta lặp lại chu trình, bằng cách cung cấp bổ sung những mẫu có nhãn cho đến khi hiệu suất chấp nhận được được tìm thấy. Chúng ta sẽ minh hoạ quá trình này bằng ví dụ ngay sau đây. . . Chúng ta giả định rằng bộ dữ liệu đầu tiên chứa ba thành phần: $a$, $b$, và $c$ và bộ dữ liệu thứ hai chứa hai thành phần $d$ và $e$. Từ bộ dữ liệu này, chúng ta lấy hai cặp $(a, d)$ và $(c, d)$ được gán nhãn tương đồng và không tương đồng bởi người dùng. Trên cặp này, chúng ta áp dụng những hàm tương đồng mà mỗi hàm sẽ cho ra kết quả là một đặc trưng của cặp. Sau đó chúng ta sử dụng những đặc trưng này để học một random forest. Chúng ta áp dụng những luật đã được học cho những bộ ba không nằm trong tập huấn luyện và hỏi người dùng để xác minh kết quả. Người dùng thông báo cho chúng ta biết là cặp $(b, d)$ là không đúng. Chúng ta thêm $(b, d)$ vào tập dữ liệu huấn luyện của chúng ta, và chúng ta lặp lại quá trình với vòng lặp tiếp theo. Sau một số vòng lặp, chúng ta dự đoán xem quá trình hội tụ chưa và cho chúng ta một Random forest để chúng ta có thể sử dụng một cách hiệu quản trong bước blocking. . Khi một Random forest đã được học, chúng ta có thể biểu diễn mỗi một luật cho người dùng. Dựa trên xác minh của người dùng, chúng ta chọn ra những luật sẽ được sử dụng trong những bước tiếp theo. . 3.5 Applying the Rules . Sau khi chúng ta học được những luật, bước kế tiếp là áp dụng chúng lên dữ liệu thật sự. Khi kích thước dữ liệu là cực lớn, nó vẫn không thể áp dụng những luật blocking cho tất cả các cặp đối tượng. Do đó, chúng ta phải dùng đến lập chỉ mục (resort to indexing). Giả sử sằng, một trong các luật yêu cầu chỉ mục Jaccard nên phải lớn hơn $0.7$, và chúng ta đang tìm kiếm phù hợp với bộ phim Sound of Music. Vì độ dài của tên bộ phim là $3$, chúng ta chỉ cần phải xem xét những bộ phim trong dữ liệu của chúng ta mà độ dài của chúng nằm giữa $3 times 0.7$ và $3/0.7$, tức là nằm giữa 2 và 4. Nếu chúng ta đã lập chỉ mục tập dữ liệu về kích thước của phim, nó rất hiệu quả để chọn được những bộ phim mà kích thước tên nằm giữa $2$ và $4$, và lọc tập hơn thông qua việc áp dụng những luật blocking. . 3.6 Performing the Matching . Bước blocking tạo ra một tạp những tập được tinh giảm đi rất nhiều mà đã được kiểm tra xem chúng có khớp với nhau hay không. Cấu trúc chung cho quá trình matching khá là tương tự với lần đầu chúng ta xác định một tập những đặc trưng, học một random forest, và thông qua quá trình active learning mà tinh chỉnh nó. Điểm khác biệt mấu chốt giữa bước blocking và matching là quá trình matching cần phải chính xác và cần nhiều tính toán. Bởi vì đây là bước cuối cùng trong mẫu ghi liên kết (record linkage) và chúng ta cần có độ tin cậy cao rằng hai thực thể phải chắc chắn khớp với nhau. . 4. Tổng kết . Trong chương này, chúng ta đề cập đến vấn đề khởi tạo một đồ thị tri thức bằng cách tích hợp dữ liệu đến từ những nguồn có cấu trúc. Lược đồ tích hợp của đồ thị tri thức có thể được tinh chỉnh và đánh giá theo mỗi yêu cầu của doanh nghiệp. Việc ánh xạ giữa những lược đồ của những nguồn khác nhau có thể được boostrapped thông qua những kỹ thuật thuật tự động, những chúng cần có xác mình đầu vào của con người. Record linkage - mẫu ghi liên kết là sự tích hợp dự liệu ở mức thể hiện, nơi mà chúng ta cần phải dự đoán đối sánh giữa hai thể hiện trong trường hợp không có bộ định danh duy nhất. Phương pháp tiếp cận chung nhất cho record linkage là học một Random Forest thông qua quá trình active learning. Với những ứng dụng yêu cầu độ chính xác cao, tính toán record linkage một cách tự động vẫn cần đến sự xác minh của con người. . Bài tập: . …Sẽ cập nhật sau… . Bài giảng gốc: https://web.stanford.edu/class/cs520/2020/notes/How_To_Create_A_Knowledge_Graph_From_Data.html .",
            "url": "https://nhutnamhcmus.github.io/lenux-notebooks/2021/06/26/how-to-create-a-knowledge-graph-from-data.html",
            "relUrl": "/2021/06/26/how-to-create-a-knowledge-graph-from-data.html",
            "date": " • Jun 26, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "How Create A Knowledge Graph",
            "content": "ĐỒ THỊ TRI THỨC - KNOWLEDGE GRAPH . Đây là bản dịch từ Course CS520: Knowledge Graphs | Data Models, Knowledge Acquisition, Inference and Applications | . Department of Computer Science, Stanford University, Spring 2021 . Knowledge graphs have emerged as a compelling abstraction for organizing world’s structured knowledge over the internet, capturing relationships among key entities of interest to enterprises, and a way to integrate information extracted from multiple data sources. Knowledge graphs have also started to play a central role in machine learning and natural language processing as a method to incorporate world knowledge, as a target knowledge representation for extracted knowledge, and for explaining what is being learned. This class is a graduate level research seminar and will include lectures on knowledge graph topics (e.g., data models, creation, inference, access) and invited lectures from prominent researchers and industry practitioners. The seminar emphasizes synthesis of AI, database systems and HCI in creating integrated intelligent systems centered around knowledge graphs. . Mục đích: Là tìm hiểu cũng như trau dồi kiến thức chuyên môn trong lĩnh vực Knowledge Graph cũng như từ vựng tiếng Anh. Không vì mục đích kinh doanh hay bất cứ mục đích về lợi nhuận, tất cả là vì mục đích chia sẻ kiến thức và học tập. . Mọi thông tin về những chủ đề được note lại có thể tìm thấy ở đây: . https://web.stanford.edu/class/cs520/2020/notes/Table_Of_Contents.html . Video của các buổi seminar cũng được công khai trên địa chỉ Youtube: . https://www.youtube.com/playlist?list=PLDhh0lALedc5paY4N3NRZ3j_ui9foL7Qc . Mọi vấn đề về dịch thuật, thuật ngữ xin để lại comment hoặc gửi về địa chỉ email: lenam.fithcmus@gmail.com với tiêu đề . [ISSUES OF KG TRANSLATION] . HOW TO CREATE A KNOWLEDGE GRAPH? . 1. Giới thiệu . Ta có thể bắt đầu với đồ thị tri thức mà không cần thiết kế trước lược đồ (schema) của nó và phát triển cả lược đồ (schema) lẫn các thể hiện (instances) của nó trong suốt quá trình xử lý. Ở mức độ một bản thiết kế trước lược đồ đồ thị tri thức trong thực tế, nó có thể cải thiện đáng kể tính hữu dụng của nó. Giống như một thiết kế liên quan đến việc đưa ra một lựa chọn hợp lý những node, nhãn nút, những thuộc tính node, những quan hệ và những thuộc tính quan hệ. . Đầu vào cho quần thể đồ thị tri thức có thể đến từ một hoặc nhiều nguồn bao gồm dữ liệu có cấu trúc (structured data), dữ liệu bán cấu trúc (semi structured data), văn bản (free text) hoặc hình ảnh (images) hoặc được nhập trực tiếp bởi con người (direct authoring by human input). Khi chúng ta đang làm việc với nguồn dữ liệu có cấu trúc (structured data) và dữ liệu bán cấu trúc (semi structured data), chúng phải thực hiện tác vụ ánh xạ lược đồ (schema mapping task) (tức là, liên hệ lược đồ trong nguồn dữ liệu đầu vào với lược đồ của đồ thị tri thức) và tác vụ ghi liên kết (record linkage task) (tức là liên hệ những thể hiện mới với những thể hiện đã tồn tại từ trước trong đồ thị tri thức). Những những tác vụ cũng đối mặt trong suốt quá trình tích hợp dữ liệu (data integration) với chỉ một khác biệt là dữ liệu tích hợp được thể hiện trong mô hình dữ liệu đồ thị. Khi chúng ta đang làm việc với nguồn dữ liệu phi cấu trúc (unstructured sources), chúng ta phải giải quyết vấn đề rút trích thông tin trong tác vụ rút trích thực thể (entity extraction) và rút trích quan hệ (relation extraction) . Sự lựa chọn phương pháp sử dụng trong quần thể đồ thị tri thức phụ thuộc vào quy mô của vấn đề và độ chính xác mong muốn. Nếu một đồ thị tri thức được sử dụng trên quy mô web cho truy xuất thông tin (information retrieval), độ chính xác không cần phải hoàn hảo, và không sử dụng định danh con người cho mọi bộ ba của đồ thị. Nếu một đồ thị tri thức được sử dụng trong doanh nghiệp, nơi mà độ chính cần phải càng chính xác càng tốt (tiệm cần hoàn hảo), định danh con người là cần thiết ngay cả khi nó được thực hiện ngay trước khi thông tin được sử dụng. Độ chính xác luôn được mong muốn bất kể là doanh nghiệp hay cài đặt WW, để đảm bảo hiệu quả chi phí (cost effectiveness) và khả năng mở rộng (scalability), phải chú trọng đến nguồn cung cấp từ cộng đồng và các phương pháp giảm thiểu chi phí trong việc lấy thông đầu vào từ con người . 2. Thiết kế đồ thị tri thức . Cả đồ thị thuộc tính (Property Graph) và mô hình dữ liệu RDF (RDF Data Model) có một tập các vấn đề thiết kế, một vài trong số đó thường gặp ở cả hai, trong khi số khác thì chỉ cần ở một loại duy nhất. . Lấy ví dụ, cả hai mô hình đều cần phải sử dụng tái tổ chức cho những tình huống không thể mô hình hoá trực tiếp bằng cách sử dụng bộ ba. Một mô hình RDF (RDF Model) cần phải áp dụng một lược đồ cho IRIs điều mà không cần thiết với đồ thị thuộc tính (Property Graphs). Trong mô hình đồ thị thuộc tính (Property Graph Model), chúng ta cần phải quyết liệu rằng một giá trị có nên được biểu diễn như một thuộc tính (property) hay như một nút (node), trong khi sự phân biệt này không cần thiết trong một mô hình RDF. Trong phần này, chúng ta sẽ tìm hiểu tổng quan một số vấn đề thiết kế gặp phải với hai mô hình này. . 2.1 Thiết kế một RDF Graph - Design of an an RDF Graph . Các nguyên tắc tạo biểu đồ tri thức cho dữ liệu RDF trên WWW được gọi là các nguyên tắc dữ liệu được liên kết - linked data principles như sau: . - Sử dụng URIs như tên gọi cho mọi thứ . - Sử dụng HTTP URIs nên mọi người có thể tra cứu những tên gọi này . - Khi một người nào đó tra cứu một URI, cung cấp những thông tin hữu ích, sử dụng các chuẩn (RDF, SPARQL) . - Bao gồm liên kết đến những URIs khác, nên họ có thể khám phá nhiều thứ hơn . 2.1.1 Sử dụng URI như định danh cho các sự vật . Để xuất bản một đồ thị tri thức lên WWW, đầu tiên chúng ta phải định danh những thành phần quan tâm trong miền của chúng ta. Chúng là những thứ mà những thuộc tính và quan hệ của chúng, chúng ta muốn mô tả trên đồ thị. Trong thuật ngữ WWW (WWW terminology), tất cả nhưng thành phần quan tâm ấy được gọi là tài nguyên – resources. Những tài nguyên có hai loại: tài nguyên thông tin (information resources) và tài nguyên phi thông tin (non-information resources). Tất cả những tài nguyên mà chúng ta tìm kiếm trên WWW truyền thống như tài liệu (documents), hình ảnh (images) và những tập tin phương tiện (media files) là những tài nguyên thông tin (information resources) . Nhưng nhiều thứ chúng ta muốn trong đồ thi tri thức không phải con người (People), sản phẩm vật lý (physical product), nơi chốn (places), proteins, những khái niệm khoa học (scienctific concepts), …. Như một quy luật chung, tất cả “những thực thể thế giới thực” mà tồn tại bên ngoài WWW đều là tài nguyên phi thông tin (non-information resources) . Những người xuất bản đồ thị tri thức nên xây dựng URI để chia sẻ theo một cách đơn giản, ổn định và dễ quản lý. Nói gọn hơn, URI dễ nhớ sẽ không dễ bị hư hại khi được gửi trong email và nói chung dễ nhớ hơn :v Sau khi chúng ta cài đặt một URL để định danh một tài nguyên xác định, nó sẽ duy trì càng lâu càng tốt. Để đảm bảo tính bền bỉ lâu dài, tốt nhất là giữ các bit và phần cụ thể về triển khai, chẳng hạn như “.php”, và “.asp” ra ngoài URIs. Cuối cùng, URI nên được định nghĩa theo cách mà chúng có thể được quản lý bởi những người xuất bản (Developer chẳng hạn) . 2.1.2 Sử dụng HTTP URIs để mà con người có thể tra cứu chúng . Chúng ta định danh những tài nguyên bằng cách sử dụng Uniform Resources Identifiers (URIs) - Bộ định danh tài nguyên nguyên đồng nhất. Chúng ta tự hạn chế chỉ sử dụng các URI HTTP và tránh các lược đồ URI khác như Uniform Resource Names (URN) và Digital Object Identifiers (DOI). . Quá trình xử lý của việc tra cứu tên gọi là tham chiếu URI - URI dereferencing. Khi chúng ta tham chiếu một URI cho một đối tượng thông tin, chúng ta mong đợi có được biểu diễn trạng thái hiện tại của nó (ví dụ như là một tài liệu văn bản, một hình ảnh, một video, …) Nhưng khi chúng ta tham chiếu một tài nguyên phi thông tin, chúng ta có thể nhận được mô tả trong biểu diễn RDF trong một định nghĩa XML . 2.1.3 Khi một ai đó tra cứu một URI, cung cấp những thông tin hữu ích sử dụng RDF và SPARQL . Khi một ai đó tra cứu một URI, nhà cung cấp nên trả về một đồ thị tri thức trong RDF. Dữ liệu nên tái sử dụng những từ vựng được chuẩn hoá để đặt tên những IRIs được sử dụng trong mô tả dữ liệu RDF. Những từ vựng hữu ích có sẵn cho việc mô tả dữ liệu danh mục, những tổ chức và dữ liệu đa chiều (multidimensional data), như là thống kê trên Web. Một nổ sự mã nguồn mở gọi là Schema.Org công bố bởi cộng đồng từ vựng mã nguồn mở cho việc sử dụng trên khắp Web. Chúng ta xem xét một vài ví dụ về những từ vựng đấy . Dữ liệu RDF sau đây mô tả một đoạn về cơ cấu tổ chức của Văn phòng Nội các Vương quốc Anh. . @prefix uk_cabinet: &lt;http://reference.data.gov.uk/id/department/&gt; . uk_cabinet:co rdf:type org:Organization . uk_cabinet:co skos:prefLabel “Cabinet Office” . uk_cabinet:co org:hasUnit uk_cabinet:cabinet-office-communications . uk_cabinet:cabinet-office-communications rdf:type org:OrganizationUnit . uk_cabinet:cabinet-office-communications skos:prefLabel “Cabinet Office Communications” . uk_cabinet:cabinet-office-communications org:hasPost uk_cabinet:post_246 . uk_cabinet:post_246 skos:prefLabel “Deputy Director, Deputy Prime Minister’s Spokesperson” . Dữ liệu phía trên, bộ ba đầu tiên sử dụng lớp org:Organization từ Organization Ontology. . Bộ ba thứ hai sử dụng quan hệ skos:prefLabel được vẽ từ SKOS ontology. SKOS chuẩn hoá cho một Simple Knowledge Organization System, và cung cấp một vài quan hệ chung hữu ích như skos:prefLabel cho việc mô tả dữ liệu. Trong trường hợp này, skos:prefLabel đơn giản cho phép chúng ta liên hệ một nhãn văn bản uk_cabinet:co. . Bộ ba thứ ba sử dụng quan hệ org:hasUnit từ Organization ontology một tả một đơn vị trong UK Cabinet office . Hai bộ ba tiếp theo bổ sung khẳng định về đơn vị này . Bộ ba thứ sáu sử dụng quan eh65 org:hasPost mô tả vị trị với một phòng ban (department) . Và hai bộ ba cuối cùng cho thông tin bổ sung về vị trị đó . Không phải lúc nào cũng có thể tìm thấy những từ vựng tồn tại trước đó có thể được sử dụng trong khởi tạo RDF dataset. Nếu việc khởi tạo mới một từ vựng trở nên cần thiết, chúng ta nên đảm bảo rằng nó được ghi lại, tự mô tả, có chính sách phiên bản, được định nghĩa trong nhiều ngôn ngữ, và được xuất bản bởi một nguồn đáng tin cậy để mà các tồn tại URIs sử dụng nó trong một khoảng thời gian dài. Chúng ta nói rằng một từ vựng tự mô tả nếu mỗi thuộc tính hoặc thuật ngữ có một nhãn, khái niệm và chú thích được định nghĩa. . 2.1.4 Bao gồm các tới các URIs khác, nên họ có thể khám phá nhiều thứ hơn . Trong khi xuất bản dữ liệu bằng cách sử dụng RDF, chúng ta nên cung cấp liên kết đến những đối tượng để mà tăng tính hữu ích của nó. Có 3 loại liên kết: . - Relationship links - liên kết quan hệ . - Identity links - liên kết thực thể . - Vocabulary links - liên kết từ vựng . Liên kết quan hệ (Relationship links) trỏ đến những thứ liên hệ trong những nguồn dữ liệu khác như những người khác, những nơi chỗ hoặc genes. Ví dụ, liên kết quan hệ cho phép con người có thể có trỏ đến những thông tin lai lịch về nơi mà họ sinh sống, hoặc dữ liệu thư mục về những công bố mà họ đã viết. Trong bộ ba sau đây, chúng ta thấy một liên kết mà một cá nhân trong một tập dữ liệu đươc xác nhận là sống gần một vị trí địa lý được chỉ định bằng cách sử dụng URI trong một tập dữ liệu khác. . @prefix big: &lt;http://biglynx.co.uk/people/&gt; . @prefix dbpedia: &lt;http://dbpedia.org/resource/&gt; . big:dave-smith foaf:based_near dbpedia:Birmingham . Liên kết thực thể (Identity links) trỏ đến những URI bí danh sử dụng bởi những nguồn dữ liệu khác để định danh cùng một đối tượng trong thế giới thực hoặc khái niệm trừu tượng, Liên kết thưc thể cho phép khách hàng (clients) có thể truy xuất nhiều mô tả về một thực thể và phục vụ một chức năng xã hội quan trọng vì chúng cho phép nhiều góc nhìn khác nhau về thế giới được thể hiện trên WWW. Nó là một chuẩn thực thể để sử dụng loại liên kết http://www.w3.org/2002/07/owl#sameAs để thông báo hai bí danh URI cùng tham chiếu đến cùng một nguồn. . Lấy ví dụ, nếu Dave Smith cùng muốn bảo trì một dữ liệu trang chủ ẩn danh bên cạnh dữ liệu mà Big Lynx công khai về anh ta, anh có thể thêm một liên kết http://www.w3.org/2002/07/owl#sameAs đến dữ liệu trang chủ ẩn danh, việc thông báo URI sử dụng tham chiếu đến tài liệu và URI sử dung bởi Lynx cùng tham chiếu đến cùng một thưc thể thế giới thực. Một bộ ba biểu diễn thông tin như thế được mô tả sau đây: . @prefix ds: &lt;http://www.dave-smith.eg.uk&gt; . @prefix owl: &lt;http://www.w3.org/2002/07/owl&gt; . @prefix big: &lt;http://biglynx.co.uk/people/&gt; . ds:me owl:sameAs big:dave-smith . Liên kết từ vựng trỏ trừ dữ liệu đến những định nghĩa của những thuật ngữ từ vựng được sử dụng để biểu diễn dữ liệu, giống như từ những định nghĩa này đến những định nghĩa của những thuật ngữ được liên hệt trong những từ vựng khác. Liên kết từ vựng làm cho dữ liệu tự mô tả và cho phép ứng dụng liên kết dữ liệu (Link Data) hiểu và tích hợp dữ liệu thông quan những từ vựng. Trong liên kết từ vựng được cho sau đây, lớp SmallMediumEnterprise định nghĩa bởi BigLynx được định nghĩa thành một lớp con của lớp Company trong DBpedia Ontolgy. Bằng cách tạo ra một liên kết như thế, có thể truy xuất các xác nhận khác nhau về lớp Company từ DBPedia, và sử dụng chung với lớp SmallMediumEnterprise. . @prefix dbpedia: &lt;http://dbpedia.org/ontology/&gt; . big:sme#SmallMediumEnterprise rdfs:subClassOf dbpedia:Company . 2.2 Thiết kế một đồ thị thuộc tính (Property Graph) . Thiết kế một đồ thị thuộc tính liên quan đến chọn nút (nodes), nhãn nút (node labels), thuộc tính nút (node properties), cạnh liên kết (edges) và thuộc tính cạnh liên kết (edge properties). Những câu hỏi thiết kế cơ bản là liệu có nên mô hình hoá một phần thông tin như một thuộc tính, nhãn hay như một đối tượng riêng biệt; khi nào nên đưa vào những thuộc tính quan hệ; và làm thế nào có thể xử lý những mối quan hệ đặc biệt (higher arity relationships). Chúng ta sẽ minh họa quá trình thực hiện những lựa chọn này bằng cách sử dụng các ví dụ. . 2.2.1 Lựa chọn nút (Nodes), nhãn (Labels) và thuộc tính (Properties) . Trong một mô hình đồ thị thuộc tính, những nút thường biểu diễn những thực thể trong miền, Nếu chúng dược biểu diễn với thông tin biểu diễn về con người, chúng ta sẽ khởi tạo một nút cho mỗi cá nhân (ví dụ John), và liên hệ nhãn Person với nút đó. . Có nhiều cân nhắc trong tạo ra nhiều lựa chọn hơn những nhãn nút, những thuộc tính nút và cạnh liên kết. Những cân nhắc này bao gồm: tính tự nhiên của nhãn, liệu các nhãn có thể thay đổi trong một khoảng thời gian, hiệu suất truy vấn thời gian chạy và số lượng các giá trị . Để minh hoạ sự lựa chọn liệu có nên mô hình hoá một phần thông tin thành một nhãn, thuộc tính hay thành một đối tượng riêng biệt, xem xét tác vụ biểu diễn giới tính của một người. Chúng ta có ba cách tìm năng để biểu diễn thông tin này: . - (1) Chúng ta có thể khởi tạo :Male và :Female như những nhãn và liên hệ chung với những nút Person . - (2) Chúng ta có thể khởi tạo một thuộc tính gọi là “Gender” và liên hệ nó với nút Person và cho phép nó có thể có giá trị “male” và “female” . - (3) Chúng ta có thể khởi tạo đối tượng Gender, liên hệ nó với Person bằng cách sử dụng mối quan hệ has_gender, và cho nó một thuộc tính gọi là “name” mà có thể lấy “male” và “female” như những giá trị của nó . Những nhãn trong một mô hình đồ thị thuộc tính được sử dụng để nhóm những nút thành những tập hợp. Tất cả những nút được gán nhãn với cùng nhãn sẽ thuộc về cùng một tập. Những truy vấn có thể hoạt động với những tập hợp thay vì toàn bộ đồ thị, tạo ra những câu truy vấn dễ dàng hơn, và hiệu quả hơn. Một nút có thể được gán nhãn với bất kỳ nhãn nào, kể cả rỗng, việc tạo nhãn là một tuỳ chọn bổ sung cho đồ thị. Như nhóm những nhãn nút thành một tập, nó có thể được nhìn như một lớp. Câu hỏi đặt ra là liệu có thể đưa một nhãn mới có thể được đặt lại như đưa vào một lớp mới hay không? . Khởi tạo những lớp mới Male và Female so với đưa vào một thuộc tính nút “gender” mà có thể nhận giá trị “male” và “female” biểu diễn cùng một thông tin. Một cách tổng quát, bất cứ khi nào một cụm từ xuất hiện một cách tự nhiên trong ngôn ngữ một cách thường xuyên được sử dụng trong một miền, nó là một ứng viên có thể được thêm vào như một lớp miễn là số lượng thành viên trong lớp không thay đổi theo thời gian. Như một số cài đặt tối ưu truy xuất dựa trên sử dụng nhãn, việc sử dụng nhãn có thể cho kết quả truy vấn với hiệu suất cao mà cần thiết để lọc những kết quả dựa trên thành viên trong lớp. Nếu lớp các thành viên thay đổi theo thời gian, cả nhãn hay giá trị thuộc tính nút đều không phải là lựa chọn thích hợp, chúng ta cần phải sử dụng một mối quan hệ. Chúng ta sẽ xem xét vấn đề này trong phần dưới đây :v . 2.2.2 Khi đưa vào mối quan hệ (Relationships) giữa những đối tượng (Objects) . Với những tình huống có thể mô hình hoá thay vì sử một thuộc tính nút hoặc đưa vào một đối tượng riêng biệt và mối quan hệ, ở đây, ít nhất, có hai cân nhắc khác nhau. Cân nhắc đầu tiên được giới thiệu trong phân phía trên: những thành viên trong lớp thay đổi theo thời gian. Cân nhắc thứ hai phát sinh khi chúng ta mong muốn đạt đươc hiệu năng tốt hơn. Chúng ta sẽ xem xét những tình huống này chi tiết hơn . Tiếp tục với ví dụ từ phần trước, khi giới tính của một người có thể thay đổi trong một khoảng thời gian, do đó lựa chọn của chúng ta chỉ có thể là biểu diễn thông tin như một đối tượng Gender riêng biệt mà có thể liên hệ với Person bằng cách sử dụng quan hệ has_gender. Chúng ta có thể liên hệ một mối quan hệ thuộc tính với mối quan hệ has_gender mà cho biết khoảng thời gian mà giá trị cụ thể của giới tính đó nắm giữ. Khởi tạo một nút riêng biệt Gender, tuy nhiên sẽ dẫn tới một số lượng lớn các cạnh liên kết gây lãng phí vì hầu hết mọi người thì giới tính không đổi. Trong trường hợp như thế, có thể mong muốn một kết hợp hai giải pháp trong đó, đối với hầu hết mọi người, giới tính được biểu diễn như một giá trị thuộc tính nút, nhưng với một số ít người, nó được biểu diễn như một giá trị quan hệ thuộc tính đến một nút Gender riêng biệt. . Chúng ta xem xét một tình huống mà việc truy vấn hiệu suất tốt hơn là một yếu tố quan trọng cần cân nhắc. Giả định rằng, chúng ta mong muốn mô hình hoá những bộ phim và những thể loại của chúng. Trong một thiết kế, với một nút thuộc kiểu Movie, chúng ta có thể thêm một thuộc tính “genre” mà có thể nhận những giá trị như “Action”, “SciFci”, … Trong một thiết kế khác, chúng ta có thể thêm một nút kiểu Genre mà có một thuộc tính nút là “name” mà có thể nhận những giá trị như là “Action”, “SciFci”. Sau đó chúng ta sẽ liên hệ một nút kiểu Movie với một nút kiểu Genre bằng cách sử dụng mối quan hệ has_genre. Tổng quát, chúng ta có thể liên kết nhiều hơn một thể loại với một bộ phim. Giả định rằng chúng ta mong muốn truy vấn những bộ phim mà có ít nhất một thể loại chung. Giải pháp đầu tiên là chúng ta sử dụng một thuộc tính nút “genre”, trong truy vấn này sẽ được viết bằng Cypher: . MATCH (m1:Movie), (m2:Movie) . WHERE any(x IN m1.genre WHERE x IN m2.genre) . AND m1 &lt;&gt; m2 . RETURN m1, m2 . Khi chúng ta mô hình hoá thể loại như một đối tượng riêng biệt, truy vấn tương tự cũng tự viết như sau: . MATCH (m1:Movie)-[:has_genre]-&gt;(g:Genre), . (m2:Movie)-[:has_genre]-&gt;(g) . WHERE m1 &lt;&gt; m2 . RETURN m1, m2 . Trong truy vấn thứ hai ở trên, chúng ta có khả năng sử dụng một cách trực tiếp mẫu đồ thị (graph patterns) và trong một số graph engine, truy vấn này có một hiệu suất thời gian chạy nhanh hơn (faster runtime performance) bởi vì lập chỉ mục trên các mối quan hệ. . Do đó, trong trường hợp này, người ta phải chọn giữa hai thiết kế tùy thuộc vào loại truy vấn sẽ được mong đợi. . 2.2.3 Khi đưa vào mối quan hệ (Relationships) giữa những thuộc tính (Properties) . Chúng ta đã thấy một ví dụ về một thuộc tính liên hệ với một mối quan hệ để giải quyết tình huống khi mối quan hệ thay đổi theo thời gian. Những tình huống khác mà chúng có ý nghĩa để thêm những thuộc tính với mối quan hệ bao gồm liên hệ trọng số hoặc độ tin cậy với một mối quan hệ hoặc liên hệ nguồn gốc hoặc meta data khác với mối quan hệ . Một số grah engine không chỉ mục dựa trên những mối quan hệ thuộc tính. Nếu sử dụng trường hợp như vậy mà một lượng lớn đánh giá truy vấn có thể hoàn thành mà không cần sử dụng những mối quan hệ thuộc tính, và chúng chỉ cần cho lọc kết quả cưới cùng, chúng ta không cần phải trả giá về mặt hiệu năng vì thiếu chỉ mục. Nếu truy cập đến những quan hệ thuộc tính là trọng tâm của hiệu suất truy vấn, tốt hơn nó nên được sửa đổi quan hệ, và chúng ta sẽ thảo luận ngay phần bên dưới :v . 2.2.4 Xử lý các mối quan hệ phi nhị phân (Handling non-binary Relationships) . Chúng ta thường xuyên cần phải mô hình hoá những mối quan hệ mà không phải nhị phân. Một ví dụ chung về một mối quan hệ như là mối quan hệ between được cho bởi những đối tượng A, B và C mà C là between A và B. Một tiếp cận chuẩn để biểu diễn những mối quan hệ đặc biệt cao này trong một đồ thị là tái tổ chức (reification). Chúng ta đã thảo luận trước đó về tái tổ chức (reification) trong một ngữ cảnh của RDF, nhưng kỹ thuật này cũng hữu ích và đáng kỳ vọng như nhau đối với đồ thị. Để nắm bắt mối quan hệ between, chúng ta thể vào một nút kiểu Between_Relationship mà có hai thuộc tính: bas_object (với những giá trị là A và B) và has_between_object (với giá trị C). Chúng ta có thể sử dụng tái tổ chức cho những quan hệ với bất kỳ đặc biệt nào bằng cách khởi tạo một nút kiểu mới cho quan hệ, và bằng cách thêm những thuộc tính nút cho những tham số khác nhau của quan hệ đó. . 3. Tổng kết . Bài tập: . …Sẽ cập nhật sau… . Bài giảng gốc: . https://web.stanford.edu/class/cs520/2020/notes/How_To_Create_A_Knowledge_Graph.html .",
            "url": "https://nhutnamhcmus.github.io/lenux-notebooks/2021/06/26/how-create-a-knowledge-graph.html",
            "relUrl": "/2021/06/26/how-create-a-knowledge-graph.html",
            "date": " • Jun 26, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "What Is Knowledge Graph",
            "content": "ĐỒ THỊ TRI THỨC - KNOWLEDGE GRAPH . Đây là bản dịch từ Course CS520: Knowledge Graphs | Data Models, Knowledge Acquisition, Inference and Applications | . Department of Computer Science, Stanford University, Spring 2021 . Knowledge graphs have emerged as a compelling abstraction for organizing world’s structured knowledge over the internet, capturing relationships among key entities of interest to enterprises, and a way to integrate information extracted from multiple data sources. Knowledge graphs have also started to play a central role in machine learning and natural language processing as a method to incorporate world knowledge, as a target knowledge representation for extracted knowledge, and for explaining what is being learned. This class is a graduate level research seminar and will include lectures on knowledge graph topics (e.g., data models, creation, inference, access) and invited lectures from prominent researchers and industry practitioners. The seminar emphasizes synthesis of AI, database systems and HCI in creating integrated intelligent systems centered around knowledge graphs. . Mục đích: Là tìm hiểu cũng như trau dồi kiến thức chuyên môn trong lĩnh vực Knowledge Graph cũng như từ vựng tiếng Anh. Không vì mục đích kinh doanh hay bất cứ mục đích về lợi nhuận, tất cả là vì mục đích chia sẻ kiến thức và học tập. . Mọi thông tin về những chủ đề được note lại có thể tìm thấy ở đây: . https://web.stanford.edu/class/cs520/2020/notes/Table_Of_Contents.html . Video của các buổi seminar cũng được công khai trên địa chỉ Youtube: . https://www.youtube.com/playlist?list=PLDhh0lALedc5paY4N3NRZ3j_ui9foL7Qc . Mọi vấn đề về dịch thuật, thuật ngữ xin để lại comment hoặc gửi về địa chỉ email: lenam.fithcmus@gmail.com với tiêu đề . [ISSUES OF KG TRANSLATION] . WHAT IS A KNOWLEDGE GRAPH? . 1. Giới thiệu . Đồ thị tri thức là một cấu trúc trừu tượng rất hợp lý, hấp dẫn cho việc tổ chức tri thức có cấu trúc của thế giới trên Internet, và như một cách tích hợp rút trích thông tin từ nhiều nguồn dữ liệu. Đồ thị tri thức cũng đóng vai trò trung tâm trong Machine Learning (Học Máy) như một phương pháp kết hợp tri thức nhân loại, như một mục tiêu biểu diễn tri thức (Knowledge Representation) với những tri thức đã được rút trích, và giải thích những gì học được. . Mục đích của chúng ta ở đây là để giải thích những thuật ngữ (terminology), khái niệm (concepts) và cách sử dụng của Đồ thị tri thức trong một cách hiểu đơn giản. Chúng ta không tổ chức một khảo sát toàn diện về những công trình quá khứ và hiện tại về đề tài Đồ thị tri thức. . Chúng ta sẽ bắt đầu bằng cách định nghĩa về đồ thị tri thức, một vài ứng dụng mà đóng góp vào sự phát triển phổ biến của Đồ thị tri thức, sau đó sử dụng Đồ thị tri thức vào trong Machine Learning (Học Máy). Chúng ta sẽ kết lại chương bằng một tổng kết chung về những điểm mới và khác biệt về phương pháp Đồ thị tri thức trong thời gian gần đây. . 2. Định nghĩa Đồ thị tri thức . Một Đồ thị tri thức (Knowledge Graph) là một đồ thị hữu hướng được gán nhãn (Directed labeled graph – DLG) mà những nhãn này xác định có ý nghĩa rõ ràng. . Một đồ thị hữu hướng được gán nhãn (DLG) bao gồm các nút (nodes), cạnh liên kết (edges) và nhãn (labels). Bất kỳ thứ gì đều có thể xem là một nút (node), ví dụ như con người, công ty, máy tính, … . Một cạnh liên kết (edges) kết nối một cặp nút (nodes) và thể hiện mối quan hệ được quan giữa chúng, ví dụ như mối quan hệ tình bạn giữa hai người, mối quan hệ khách hàng giữa một công ty và một người, hoặc một kết nối mạng kết nối hai máy tính. Nhãn thể hiện ý nghĩa của mối quan hệ đó, ví dụ: mối quan hệ tình bạn giữa hai người. . Tổng quát hơn, cho một tập các nút $N$, và một tập các nhãn $L$, một đồ thị tri thức là một tập hợp con của tích hữu hướng $N times L times N$. Mỗi thành phần trong tập này được gọi là một bộ ba và có thể trực quan như sau: . . Biểu diễn đồ thị hữu hướng thường được sử dụng trong nhiều cách khác nhau phụ thuộc vào nhu cầu của ứng dụng. Một đồ thị hữu hướng như tập các node biểu diễn con người, và các cạnh liên kết thể hiện mối quan hệ tình bạn giữa họ còn được gọi là một dữ liệu đồ thị. Một đồ thị hữu hướng mà những node là những lớp đối tượng (sách, báo, …) và những cạnh liên kết thể hiện mối quan hệ lớp con có thể hiểu là một phân loại học (taxonomy). Trong một số mô hình dữ liệu, A được gọi là chủ thể (subject), B được gọi là thuộc tính (predicate), và C được gọi là đối tượng (object). . Nhiều tính toán dựa trên đồ thị có thể điều chỉnh thành dạng điều hướng. Ví dụ như, trong một đồ thị tri thưc tình bạn, để tính toán bạn bè của một người bạn của một người A, chúng ta có thể điều hướng đồ thị tri thức từ A đến tất cả các node B mà liên kết với nó bằng nhãn quan hệ bạn, và sau đó, đệ quy đến tất cả node C liên kết đến B bởi mối quan hệ bạn. . Một đường đi (Path) trong một đồ thị G là một chuỗi các node $(v_1, v_2, …, v_n)$ trong đó bất kỳ một node i nào thuộc N với $1 leq i &lt; n$, tồn tại một cạnh liên kết từ $v_i$ đến $v_{i+1}$. . Một đường đi đơn (SIMPle Path) là một đường đi mà không có node nào lặp lai . Một chu trình (Cycle) là một đường đi trong đó node bắt đầu và node kết thúc là giống nhau. . Thông thường thì, chúng ta quan tâm đến chỉ một vài đường đi mà nhãn cạnh liên kết giống với tất cả các cặp node. Có thể định nghĩa nhiều thuộc tính khác trên đồ thị (thành phần liên thông, thành phần liên thông mạnh) và những cách khác nhau để duyệt đồ thị như (đường đi ngắn nhất - shortest path, đường đi Hamiltonian, ….) . 3. Những ứng dụng gần đây của Đồ thị tri thức . Có rất nhiều những ứng dụng của đồ thị tri thức cả trong nghiên cứu lẫn doanh nghiệp. Trong Khoa học máy tính, có rất nhều cách sử dụng biểu diễn đồ thị hữu hướng, ví dụ như, luồng dữ liệu đồ thị, sơ đồ quyết định nhị phân, biểu đồ trạng thái, … Ở đây chúng ta sẽ tập trung vào hai ứng ứng cụ thể dẫn đến sự phát triển phổ biến của đồ thị tri thức: tổ chức thông tin trên Internet, và tích hợp dữ liệu. . 3.1 Đồ thị tri thức trong việc tổ chức thông tin trên Internet . Chúng ta sẽ giải thích việc sử dụng một đồ thị tri thức trên trang web bằng cách lấy ví dụ cụ thể về Wikidata. Wikidata đóng vai trò là nơi lưu trữ trung tâm cho dữ liệu có cấu trúc cho Wikipedia. Để cho thấy sự tác động lẫn nhau giữa hai đối tượng, và động lực của việc sử dụng đồ thị tri thức Wikidata, ta xem xét thành phố Winterthur ở Switzerland có một trang trên Wikipedia. Trang Wikipedia cho Winterthur liệt kê những thị trấn song sinh với nó: hai ở Switzerland, một ở Czech Republic, và một ở Austria. Thành phố của Ontario ở California có một trang Wikipedia với tựa đề dựa đặt là Ontario, California, liệt kê Winterhur như thành phố kết nghĩa của nó. Những quan hệ thành phố kết nghĩa và thành phố song sinh đồng nhất cũng như tương hỗ. Như vậy, nếu một thành phố A là một thành phố kết nghĩa của một thành phố khác B thì B phải là một thành phố kết nghĩa của A.Việc suy luận này nên tự động, nhưng vì thông tin này được nêu bằng tiếng Anh trong Wikipedia, nên không dễ phát hiện ra sự khác biệt này. Ngược lại, trong Wikidata, biểu diễn của Winterthur, có một mối quan hệ được gọi là cơ quan hành chính kết nghĩa liệt kê thành phố Ontario. Vì mối quan hệ này là đối xứng, trang Wikidata cho thành phố Ontario tự động bao gồm Winterthur. Do đó, khi đồ thị kiến thức Wikidata sẽ được tích hợp hoàn toàn vào Wikipedia, những sai lệch như vậy sẽ tự nhiên biến mất. . Wikidata bao gồm dữ liệu từ nhiều nhà cung cấp độc lập, ví dụ như Library of Congress, công bố dữ liệu chứa những thông tin về Winterthur. Bằng cách sử dụng bộ định danh (identifier) Wikidata cho Winterthur, thông tin được phát hành bởi Library of Congress có thể được liên kết một cách dễ dàng với những thông tin sẵn có từ những nguồn khác. Wikidata giúp dễ dàng thiết lập các liên kết như vậy bằng cách xuất bản các định nghĩa của các mối quan hệ được sử dụng trong nó trong Schema.Org. . Từ vựng quan hệ trong Schema.Org cho chúng ta, ít nhất, ba ưu điểm. . - Thứ nhất, có thể viết các truy vấn trải dài trên nhiều tập dữ liệu . - Thứ hai, với khả năng truy vấn như vậy, có thể dễ dàng tạo các khối thông tin có cấu trúc trong Wikipedia . - Thứ ba, thông tin có cấu trúc được trả về bởi các truy vấn cũng có thể xuất hiện trong kết quả tìm kiếm, hiện là một tính năng tiêu chuẩn cho các công cụ tìm kiếm hàng đầu . Một phiên bản gần đây của Wikidata có hơn 80 triệu đối tượng, với hơn một tỷ quan hệ giữa những đối tượng này. Wikidata tạo ra những liên kết qua hơn 4872 danh mục khác nhau bằng 414 ngôn ngữ khác nhau do các nhà cung cấp dữ liệu độc lập xuất bản. Theo ước tính gần đây, 31% trang web và hơn 12 triệu nhà cung cấp dữ liệu xuất bản chú thích Schema.Org hiện đang sử dụng từ vựng của Schema.Org. . Một số đặc trưng chính của đồ thị tri thức Wikidata . - Một đồ thị với quy mô chưa từng có, và là một đồ thị tri thức lớn nhất cho đến thời điểm hiện tại . - Nó được tham gia xây dựng bởi một cộng đồng người đóng góp . - Một số dữ liệu trong Wikidata có thể đến từ những thông tin được rút trích tự động, những nó phải dễ hiểu và được xác minh theo chính sách biên tập của Wikidata . - Đó là một nỗ lực vô cùng để cung cấp các định nghĩa ngữ nghĩa của các tên quan hệ khác nhau thông qua từ vựng trong Schema.Org. . - Mục tiêu chính của việc sử dụng Wikidata là cải thiện tìm kiếm trên web . Cho dù Wikidata có nhiều ứng dụng sử dụng nó trong việc phân tích và trực quan hoá dữ liệu, nhưng sử dụng nó trên web tiếp tục vẫn là một ứng dụng hấp dẫn và dễ hiểu nhất. . 3.2 Đồ thị tri thức trong việc tích hợp dữ liệu trong doanh nghiệp . Tích hợp dữ liệu (Data Integration) là quá trình kết hợp dữ liệu từ nhiều nguồn khác nhau và cung cấp cho người dùng một cái nhìn tổng quát về dữ liệu. . Phần lớp dữ liệu doanh nghiệp nằm trong các cơ sở dữ liệu. Một cách tiếp cận trong việc tích hợp dữ liệu là dựa trên lược đồ toàn cục (global schema) để nắm bắt mối quan hệ qua lại giữa những thành phần dữ liệu được biểu diễn trên các cơ sở dữ liệu này. Hình thành một lược đồ toàn cục (global schema) là một quá trình thật sự khó khăn bởi vì có quá nhiều bảng và thuộc tính; những chuyên gia, những người mà tạo ra những cơ sở dữ liệu này không phải lúc nào cũng có mặt, và do sự thiếu thốn các tài liệu, nên khó để hiểu ý nghĩa của dữ liệu. Bởi vì thách thức trong việc hình thành một lược đồ toàn cục (global schema), nó sẽ thuận tiện hơn khi bỏ qua các vấn đề và chuyển đổi dữ liệu quan hệ (relational data) trong một cơ sở dữ liệu với một lược đồ bộ ba tổng quát, tức là đồ thị tri thức. Việc ánh xạ giữa những thuộc tính được tạo ra trên cơ sở cần thiết, ví dụ như để giải quyết các câu hỏi kinh doanh cụ thể và bản thân chúng có thể được biểu diễn trong một biểu đồ tri thức. . Nhiều tổ chức tài chính (financial institutions) quan tâm tới việc hình thành một đồ thị tri thức công ty, mà kết hợp được dữ liệu khách hàng nội bộ với dữ liệu có giấy phép từ các bên thứ ba. Một vài ví dụ về các kho dữ liệu bên thứ ba bao gồm Dunn &amp; Bradstreet, S &amp;P 500, … Một ví dụ sử dụng một đồ thị tri thức công ty là trong việc đánh giá rủi ro trong khi đưa ra các quyết định cho vay. Dữ liệu bên ngoài bao gồm thông tin như các nhà cung cấp của một công ty. Nếu một công ty đang rơi vào tình trạng tài chính khó khăn, nó tăng rủi ro cho vay của các nhà cung cấp/ đầu tư của công ty đó. Để kết hợp dữ liệu bên ngoài này với dữ liệu nội bộ, người ta phải liên hệ được những lược đồ bên ngoài với lược đồ nội bộ công ty. Hơn nữa, tên công ty sử dụng trong các nguồn bên ngoài phải có mối quan hệ với định danh khách hàng tương ứng, được sử dụng bởi các tổ chức tài chính. Trong khi sử dụng một đồ thị tri thức là một hướng tiếp cận tích hợp dữ liệu, việc xác định các mối quan hệ có thể được hoãn lại cho đến khi chúng thật sự cần. . 4. Đồ thị tri thức trong Trí tuệ nhân tạo . Đồ thị tri thức, hay được biết đến như mạng ngữ nghĩa (semantic network), đã được sử dụng trong việc biểu diễn trong Trí tuệ nhân tạo từ những ngày đầu tiên của lĩnh vực này. Trải qua nhiều năm, mạng ngữ nghĩa (semantic networks) được phát triển thành nhiều biểu diễn khác nhau như Conceptual Graphs, Description Logics và Rules Languages. Để nắm bắt những tri thức không chắc chắn, mô hình đồ thị xác suất (probabilistic graphical models) được phát minh. . Một ứng dụng được biết đến rộng rãi trong việc biểu diễn ngôn ngữ bắt nguồn từ mạng ngữ nghĩa (semantic networks) trong việc nắm bắt các Ontology (bản thể). Một Ontology là đặc tả (formal) chính thức về việc hình thành khái niệm của một miền (domain). Ontology đóng vai trò quan trọng trong trao đổi thông tin và trong việc nắm bắt tri thức tìm ân trong một miền có thể sử dụng cho việc luận và trả lời câu hỏi (answering question). . World Wide Web Consortium (W3C) được chuẩn hoá thành một họ của những biểu diễn tri thức ngôn ngữ mà bây giờ được sử dụng rộng rãi cho việc nắm bắt tri thức trên mạng Internet. Chúng ta sẽ đề cập một ngôn ngữ như thể trong phần tiếp theo, Resource Description Frame (RDF). Họ ngôn ngữ này bao gồm Web Ontology Language (OWL) và Semantic Web Rule Language (SWRL). . Giao hoà với việc biểu diễn tri thức, một thách thức chính trong AI là nút thắc thu nhận thông tin, tức là làm thế nào có thể nắm bắt tri thức trong biểu diễn được chọn trong một bối cảnh đang nở rộng. Những phương pháp tiếp cận sơ khai, dựa trên kỹ thuật tri thức (knowledge engineering). Cố gắng để tự động hoá các phần trong kỹ thuật tri thức dẫn đến những kỹ thuật như học quy nạp (inductive learning) và thế hệ hiện tại của Máy học. . Do đó, như một điều tự nhiên, đồ thị tri thức được sử dụng như một biểu diễn được lựa chọn trong lữu trữ tri thức được học một cách tự động. Ngày càng có nhiều sự quan tâm đến việc tận dụng miền tri thức được thể hiện trong đồ thị tri thức để cải thiện Máy học. . 4.1 Đồ thị tri thức như đầu ra của Máy học . Chúng ta sẽ xem xét làm thế nào mà đồ thị được sử dụng như là một mục tiêu biểu diễn đầu ra trong các thuật toán Xử lý ngôn ngữ tự nhiên và Thị giác máy tính. . Rút trích thực thể và rút trích quan hệ từ văn bản là hai tác vụ cơ sở trong Xử lý ngôn ngữ tự nhiên. Việc rút trích thông tin từ nhiều phần trong văn bản cần có mối tương quan và đồ thị tri thức cung cấp một phương tiện tự nhiên để thực hiện mục đích như vậy. . Ví dụ, từ một câu như sau: . “Albert Einstein was a German-born theoretical physicist who developed the theory of relativity.” . Chúng ta có thể rút trích những thực thể Albert Einstein, Germany, Theoretical Physicist, và Theory of Relativity, những quan hệ born in, occupation and developed. . Khi đoạn trích này của đồ thị tri thức được kết hợp vào một đồ thị tri thức lớn hơn, chúng ta sẽ nhận được các liên kết bổ sung (được hiển thị bằng các cạnh chấm chấm), chẳng hạn như Nhà vật lý lý Thuyết (Theoretical Physicist) là một loại Nhà vật lý (Physictist), nghiên cứu Vật lý và Lý Thuyết Tương Đối (Theory of Relativity) là một nhánh của Vật lý. . . Thị giác máy tính (Nguyên văn: A holy grail of Computer vision, :))chén thánh này vjp pro quá mình cũng khum biết nói sao, hj!) là sự hiểu biết về hình ảnh, hình thành một mô hình, mà có thể định danh, nhận diện vật thể (detect objects), mô tả thuộc tính (attributes) của chúng, và nhận dạng quan hệ của chúng. Sự hiểu biến về khung cảnh thế giới cho cho phép các ứng dụng quan trọng như tìm kiếm hình ảnh (image search), trả lời câu hỏi (question answering) và tương tác với robot (robotic interactions). Nhiều tiến bộ đã đạt được trong những năm gần đây hướng tới mục tiêu này, bao gồm phân loại hình ảnh (image classification) và phát hiện đối tượng (object detection). . . Lấy ví dụ, từ một ảnh phía trên, một hệ thống tri thức hình ảnh nên tổ chức một đồ thị tri thức như phía bên phải. Các nút (node) trong đồ thị tri thức là đầu ra của một bộ phát hiện đối tượng. Những nghiên cứu gần đây trong Thị giác máy tính đang tập trung vào phát triển những kỹ thuật có thể dự đoán chính xác mối quan hệ giữa những đối tượng, ví dụ như, người đàn ông kia đang cần một cái xô, và chú ngựa đang ăn từ cái xô đó, … Đồ thị tri thức ở bên phải là một ví dụ của một đồ thị tri thức (tui hơi lú rồi) . 4.2 Đồ thị tri thức như đầu vào của Máy học . Những mô hình máy học sâu phổ biến (Deep Machine Learning Models) dựa trên đầu vào dữ liệu số, những ký hiệu hoặc cấu trúc rời rạc trước tiên nên được chuyển đổi về dạng biểu diễn số. Embeddings (nhúng, nghe chuối quá, nên mình giữa lại nguyên gốc) biến đổi một ký tự đầu vào thành một vector (mảng nếu 1 chiều, ma trận nếu 2 chiều, tổng quát thì tensor) số học như một biểu diễn đã trở thành sự lựa chọn cho những mô hình máy học. Chúng ta sẽ giải thích những khái niệm này và mối quan hệ của nó với đồ thị tri thức bằng cách lấy ví dụ về word embeddings và graph embeddings. . Word embeddings được phát triển cho việc tính toán độ tương đồng giữa những từ. Để hiểu word embeddings, chúng ta xem xét một tập những câu sau đây: . I like knowledge graphs. . I like databases. . I enjoy running. . Trong những câu trong tập hợp trên, chúng ta sẽ đếm xem một từ xuất hiện kế bên một từ cách bao nhiêu lần và lưu lại kết quả vào một ma trận. Ví dụ, từ I xuất hiện kế bên từ like hai lần, kế bên từ enjoy một lần và không lần với tất cả những từ còn lại .                   . counts | I | like | enjoy | knowledge | graphs | databases | running | . | . I | 0 | 2 | 1 | 0 | 0 | 0 | 0 | 0 | . like | 2 | 0 | 0 | 1 | 0 | 1 | 0 | 0 | . enjoy | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | . knowledge | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | . graphs | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | . databases | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1 | . running | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | . . | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 0 | . Chúng ta nói rằng ý nghĩa của mỗi từ được biểu diễn bởi vector dòng tương ứng với từ đó. Để tính toán độ tương đồng giữa các từ, chúng ta có thể dễ dàng tính toán độ tương đồng giữa những vectors tương ứng với chúng. Trong thực tế, chúng ta quan tâm trong văn bản mà có thể chứa hàng triệu từ và hy vong có biểu diễn thể biểu diễn gọn hơn. Vì ma trận trên là một ma trận thưa, chúng ta có thể sử dụng những kỹ thuật từ Đại số Tuyến tính (như, SVD - singular value decompsition) để giảm chiều dữ liệu. Kết quả cho ra vector tương ứng với từ được gọi là word embedding. Thông thường thì word embedding sử dụng trong ngày nay dựa trên những vectors có độ dài khoảng 200. . Có rất nhiều biến thể và phần mở rộng của ý tưởng cơ bản được trình bày ở đây. Các kỹ thuật tồn tại để tự động học word embedding cho bất kỳ văn bản nhất định nào. . Việc sử dụng word embedding cải thiện hiệu suất của rất nhiều tác vụ Xử lý ngôn ngữ tự nhiên bao gồm rút trích thực thể (entity extraction), rút trích quan hệ (relation extraction), phân tích cú pháp (parsing), truy xuất văn bản (passage retrieval), … Một trong những ứng dụng phổ biến nhất của word embedding là trong tự động hoàn thành các câu truy vấn tìm kiếm. Word embedding cung cấp cho chúng ta một cách dễ dàng trong việc dự đoán các từ có khả năng tuần theo truy vấn một phần mà người dùng nhập . Một văn bản là một chuỗi của những từ, và word embeddings tính toán đồng hiện (co-occurrences) cửa những từ trong đó, chúng ta có thể quan sát văn bản như một đồ thị tri thức mà mỗi từ là một nút (node) và những cạnh liên kết có hướng giữa mỗi từ này với từ khác. Graph Embeddings tổng quát hoá khái niệm này cho một cấu trúc mạng tổng quát. Mục đích và tiếp cận, tuy nhiên vẫn tiếp tục giống nhau: biểu diễn mỗi node trong một đồ thị tri thức bởi một vector, do đó độ tương đồng giữa những node có thể được tính toán như một hiệu giữa các vector tương ứng với chúng. Những vector cho mỗi node được gọi là Graph Embeddings . Để tính toán knowledge graph embedding, chúng ta định nghĩa một phương thức cho việc mã hoá mỗi nút trong một đồ thị thành một vector, một hàm để tính toán độ tương đồng giữa những nút (node), sau đó tối ưu hàm mã hoá (encoding function). Việc mã hoá một nút thành một vector được gọi là node embedding . Một hàm mã hoá có thể được sử dụng là random-walk của đồ thị tri thức (thường là 32 đến 64 random-walk) và tính toán đếm đồng hiện của những node trong đồ thị tri thức tạo ra một ma trận tương tự như đếm đồng hiện của những từ trong văn bản. Có rất nhiều phương pháp cơ bản để tính toán knowledge graph embedding. Giống như chúng ta muốn mã hoá một node thành một vector, chúng ta cũng có thể mã hoá toàn bộ đồ thị thành một vector, mà được hiểu là graph embedding. Ở đây có nhiều tiếp cận tính toán graph embedding, nhưng có lẽ tiếp cận đơn giản nhất là thêm vector cho mỗi node trong đồ thị và thu được một vector biểu diễn cho toàn bộ đồ thị. . Giải thích graph embedding bằng cách giải tính word embedding trước tiên là cách dễ nhất để hiểu chúng và cách sử dụng của chúng. Graph Embedding là một trường hợp tổng quát cho word embeddings. Chúng là một con đường để một đầu vào tri thức thể hiện trong một đồ thị tri thức vào một thuật toán Máy học. Graph Embeddings không quy nạp biểu diễn tri thức, mà là cách biến biểu diễn ký hiệu thành biểu diễn số để dùng cho một thuật toán Máy học. . Chúng ta tính toán knowledge graph embeddings một lần, chúng có thể được sử dụng cho rất nhiều ứng dụng. Một cách sử dụng rõ ràng của knowledge graph embeddings được tính toán từ đồ thị tình bạn là giới thiệu những người bạn mới. Một nhiệm vụ nâng cao hơn liên quan đến dự đoán liên kết (tức là khả năng liên kết giữa hai nút). Dự đoán liên kết trong biểu đồ công ty có thể được sử dụng để xác định khách hàng mới tiềm năng. . 5. Tổng kết . Đồ thị là một cấu trúc cơ bản trong Toán học Rời Rạc (Discrete Mathematics) và có nhiều ứng dụng trong nhiều lĩnh vực của Khoa học Máy tính (Computer Science). Công dụng đáng chú ý của đồ thị trong biểu diễn tri thức và cơ sở dữ liệu tri thức ở dạng dữ liệu đồ thị (data graphs), taxonomies, ontologies. Một cách truyền thống, những ứng dụng như thế này dựa trên thiết kế top down. Như một đồ thị tri thức (knowledge graph) là một đồ thị hữu hướng được gán nhãn (Directed Labeled Graphs), chúng ta có thể tận dụng lý thuyết. thuật toán và cài đặt từ nhiều hệ thống dựa trên đồ thị trong Khoa học Máy tính. . Sự gia tăng gần đây trong việc sử dụng đồ thị tri thức dựa trên ba tiến bộ khác nhau: . - (1) Dữ liệu liên kết và chia sẻ trên web . - (2) Tính toán đồ thị trên dữ liệu . - (3) Những quá trình trong Xử lý ngôn ngữ tự nhiên và Thị giác để rút trích quan hệ từ văn bản và hình ảnh . Một điểm chung giữa ba tiến bộ này là quy mô. Đồ thị tri thức hiện nay có quy mô chưa từng có. Chúng ta đã chú nhận thấy rằng một phiên bản gần đây của Wikidata đã có hơn 80 triệu đối tượng, và hơn 1 tỉ quan hệ. Nhiều đồ thị tri thức công nghiệp ngày càng lớn hơn, lấy ví dụ như, một phiên bản gần đây của đồ thị tri thức Google đã có hơn 570 triệu thực thể, và hơn 18 tỉ quan hệ. Quy mô lớn của đồ thị tri thức tạo ra sự hiệu quả và khả năng mở rộng của các thuật toán đồ thị là điều tối quan trọng. . Việc tổ chức thông tin trên web, và trong nhều ứng dụng tích hợp dữ liệu, nó thật sự khó để đưa ra một thiết kế top-down của một lược đồ. Các ứng dụng Máy học dựa trên dữ liệu có sẵn mà có thể dự đoán hữu ích từ nó. Những sử dụng bottom-up của đồ thị tri thức không làm giảm giá trị của thiết kế từ trên xuống của lược đồ hoặc ontology. Thật vậy, dự án Wikidata tận dụng các ontology. để đảm bảo chất lượng dữ liệu, và hầu hết các dự án tích hợp dữ liệu doanh nghiệp ủng hộ việc xác định lược đồ trên cơ sở cần thiết. Ứng dụng Máy học cũng hưởng lợi ích đáng kể với việc sử dụng nguồn onotology dồi dào cho việc tạo ra các suy diễn từ thông tin mà đã học được cho dù một ontology toàn cục hay một lược đồ không yêu cầu ngay từ đầu. . Word-Embeddings và Graph-Embedding tận dụng cấu trúc một đồ thị trong dữ liệu đầu vào, nhưng chúng cần phải tổng quát hơn đồ thị tri thức ở chỗ không rõ ràng và rõ ràng cho một lược đồ hay một ontology. Ví dụ, graph embeddings có thể được sử dụng trên khắp mạnh được định nghĩa bởi trao đổi gói tin giữa các nút trên mạng Internet, và sau đó được sử dụng trong các thuật toán máy học để dự đoán các nút mạo danh. Ngược lại, với đồ thị tri thức Wikidata, đồ thị tri thức trong doanh nghiệp, và trong biểu diễn đầu ra của các thuật toán máy học, một lược đồ hay ontology có thể đóng vai trò trung tâm. . Chúng ta kết lại bằng cách quan sát sự gia tăng quan tâm về đồ thị tri thức gần đây chủ yếu được thúc đẩy bởi các yêu cầu bottom-up của một số ứng dụng kinh doanh hấp dẫn. Đồ thị tri thức trong những ứng dụng này có thể chắn chắn hưởng lợi ích từ những công trình kinh điển từ những kỹ thuật thiết kế biểu diễn top-down, và thực tế, chúng ta có thể hình dung rằng cả hai hướng này sẽ cùng hội tụ với nhau. . Bài tập: . …Sẽ cập nhật sau… . Bài giảng gốc: https://web.stanford.edu/class/cs520/2020/notes/What_is_a_Knowledge_Graph.html .",
            "url": "https://nhutnamhcmus.github.io/lenux-notebooks/2021/06/25/what-is-knowledge-graph.html",
            "relUrl": "/2021/06/25/what-is-knowledge-graph.html",
            "date": " • Jun 25, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://nhutnamhcmus.github.io/lenux-notebooks/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://nhutnamhcmus.github.io/lenux-notebooks/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": ". My full name is Le Nhut Nam (Vietnamese format). I am a junior student who majoring in Computer Science at the VNU-HCM, University of Science. . My fields of interest are Data Science and Computer Vision especially in Digital Image &amp; Video processing. Currently, I’m focusing on research Graph Theory, Graph Convolution Neural Networks. . Besides that, I also learn some new technologies by watching Youtube, reading articles, etc. I have a good knowledge about C/C++, Python 3. . Aside from that, I also know basics concept in Java, but I do not use it much, but it is a mandatory programming language in my curriculum so I can review it quickly for working purposes. My foreign language skill is not quite excellent at all but I think I have a good skill at reading &amp; listing. I like to making friends and drink coffee. . This website is powered by fastpages 1 and its content can be written in English or Vietnamese depend on me. I just want to share what I learned, found and researched during my working. I hope these articles can be someone who gets stuck in the field which I am researching. ^^! . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://nhutnamhcmus.github.io/lenux-notebooks/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://nhutnamhcmus.github.io/lenux-notebooks/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}
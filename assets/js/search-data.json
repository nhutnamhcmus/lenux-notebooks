{
  
    
        "post0": {
            "title": "What Are Some Inference Algorithms",
            "content": "ĐỒ THỊ TRI THỨC - KNOWLEDGE GRAPH . Đây là bản dịch từ Course CS520: Knowledge Graphs | Data Models, Knowledge Acquisition, Inference and Applications | . Department of Computer Science, Stanford University, Spring 2021 . Knowledge graphs have emerged as a compelling abstraction for organizing world’s structured knowledge over the internet, capturing relationships among key entities of interest to enterprises, and a way to integrate information extracted from multiple data sources. Knowledge graphs have also started to play a central role in machine learning and natural language processing as a method to incorporate world knowledge, as a target knowledge representation for extracted knowledge, and for explaining what is being learned. This class is a graduate level research seminar and will include lectures on knowledge graph topics (e.g., data models, creation, inference, access) and invited lectures from prominent researchers and industry practitioners. The seminar emphasizes synthesis of AI, database systems and HCI in creating integrated intelligent systems centered around knowledge graphs. . Mục đích: Là tìm hiểu cũng như trau dồi kiến thức chuyên môn trong lĩnh vực Knowledge Graph cũng như từ vựng tiếng Anh. Không vì mục đích kinh doanh hay bất cứ mục đích về lợi nhuận, tất cả là vì mục đích chia sẻ kiến thức và học tập. . Mọi thông tin về những chủ đề được note lại có thể tìm thấy ở đây: . https://web.stanford.edu/class/cs520/2020/notes/Table_Of_Contents.html . Video của các buổi seminar trên địa chỉ Youtube: . https://www.youtube.com/playlist?list=PLDhh0lALedc5paY4N3NRZ3j_ui9foL7Qc . Mọi vấn đề về dịch thuật, thuật ngữ xin để lại comment hoặc gửi về địa chỉ email: lenam.fithcmus@gmail.com với tiêu đề . [ISSUES OF KG TRANSLATION] . WHAT ARE SOME KNOWLEDGE GRAPH INFERENCE ALGORITHMS . MỘT SỐ THUẬT TOÁN SUY DIỄN ĐỒ THỊ TRI THỨC . 1. Giới thiệu . Khi chúng ta đã khởi tạo đồ thị tri thức, chúng quan tâm đến truy xuất thông tin, và sử dụng những thông tin đó để đưa ra những kết luận mới. Chúng ta đã giới thiệu qua những ngôn ngữ truy vấn (query languages) mà chúng ta có thể sử dụng để thực hiện truy xuất trên đồ thị. Trong chương này, chúng ta sẽ tập trung vào những thuật toán suy diễn, vượt ra ngoài truy xuất, tức là kết luận những dữ kiện mới từ đồ thị tri thức mà không được biểu diễn một cách rõ ràng trong đó. Các thuật toán suy diễn có thể được gọi thông qua giao diện khai báo truy vấn. . Chúng ta sẽ đề cập hai lớp lớn của các thuật toán suy luận: Graph Algorithms - Các thuật toán đồ thị, và Ontology-Based Algorithm - Các thuật toán dựa trên Ontology. Các thuật toán đồ thị (Graph Algorithms) có thể được áp dụng cho bất kỳ dữ liệu cấu trúc đồ thị (graph-structured data) nào, và hỗ trợ nhiều toán tử như tìm đường đi ngắn nhất giữa các nút trong đồ thị (finding minimum paths between nodes in a graph), xác định các nút quan trong trong một đồ thị (identifying salient nodes in a graph). Các thuật toán dựa trên Ontology thực hiện trên cấu trúc đồ thị nhưng tính đến ngữ nghĩa của nó, ví dụ như, duyệt đường đi cụ thể, hay kết luận những liên kết mới dựa trên miền tri thức nền tảng (background domain knowledge). Trong chương này, chúng ta sẽ đề cập cả hai lớp thuật toán trên. . Về nguyên tắc, chúng ta có thể gọi những thuật toán đồ thị, và những thuật toán suy luận dựa trên Ontology thông qua một giao diện khai báo truy vấn (declarative query interface) của những loại mà chúng ta đã đề cập trước đó. Suy luận dựa trên Ontology có thể tận dụng được những thuật toán dựa trên đồ thị. Ví dụ như, kiểm tra nếu một đối tượng A là một thể hiện của một lớp B, có thể hoàn thành kiểm tra bằng cách kiểm tra liệu có tồn tại hay không một đường đi trong một lớp nằm giữa C và B trong đó C là trung gian của A. . 2. Các thuật toán suy luận dựa vào đồ thị - Graph-based Inference Algorithms . Chúng ta sẽ đề cập ba lớp thuật toán lớn trong những thuật toán đồ thị: . - (1) Path finding - Tìm kiếm đường đi . - (2) Centrality detection - Xác định trung tâm . - (3) Community detection - Xác định quần thể (cộng đồng) . Tìm kiếm đường đi - Path finding liên quan đến việc tìm kiếm một đường đi nằm giữa hai hay nhiều nút trong một đồ thị mà đáp ứng những thuộc tính nhất định. . Xác định (Nhận diện) trung tâm - Centrality detection là về những hiểu biết mà những nút là quan trọng trong một đồ thị. Những phương thức khác nhau được sử dụng để xác định ý nghĩa quan trọng dẫn đến rất nhiều biến thể trong những thuật toán xác định (nhận diện) trung tâm - Centrality detection algorithms. . Và cuối cùng, community detection - xác định (nhận diện) cộng đồng là việc định danh một nhóm các nút (a group of nodes) trong một đồ thị mà đáp ứng được một vài tiêu chí để nằm trong cùng một cộng đồng (quần thể, lớp). Community detection - xác định (nhận diện) cộng đồng rất hữu ích trong việc nghiên cứu những hành vi mới nổi (emergent behaviors) trong một đồ thị mà có thể không được chú ý đến. . Chúng ta sẽ đề cập mỗi một loại trong những thuật toán đồ thị chi tiết hơn. Với mỗi loại, chúng ta sẽ trình bày tổng quan, thảo luận những cách khác nhau rất hữu ích, và xem xét một vài ví dụ cho các thuật toán. . 2.1 Các thuật toán tìm đường đi - Path Finding Algorithms . Có rất nhiều biến thể của vấn đề tìm kiếm đường đi trong một đồ thị: tìm đường đi ngắn nhất giữa hai nút cho trước (finding the shortest path between any given two nodes), tìm đường đi ngắn nhất giữa tất cả các cặp nút (finding the shortest paths between all pairs of nodes), tìm một cây khung nhỏ nhất (finding a minimum spanning tree). Đường đi ngắn nhất trong một đồ thị (The shortest path in a graph) là một đường đi giữa hai nút trong một đồ thị mà tổng trọng số của các cạnh liên kết là nhỏ nhất. Nếu không có trọng số gắn với một cạnh liên kết, thì nó được giả định là 1. Đường đi ngắn nhất giữa hai nút bất kỳ có thể được sử dụng trong lập kế kế hoạch tối ưu định tuyến trong một hệ thống điều hướng giao thông. Một cây khung nhỏ nhất (A minimum spanning tree) tính toán chi phí ít nhất cho việc đi đến tất cả các nút trong một tập các nút, có thể hữu ích trong vấn đề lập kế hoạch tham quan, du dịch. . Như một ví dụ về một thuật toán tìm đường đi ngắn nhất đặc biệt, chúng ta sẽ đề cập đến thuật toán $A^{*}$ (the $A^{*}$ Algorithm) mà là một trường hợp tổng quát của thuật toán Dijkastra’s Algorithm. Thuật toán $A^{*}$ cũng được sử dụng rộng rãi như một thuật toán tìm kiếm để giải quyết những vấn đề lập lịch AI (solving AI Planning problems). . Thuật toán $A^{*}$ thực hiện duy trình một cây những đường đi có gốc tại nút bắt đầu và mởi rộng những đường đi này từng cạnh một cho đến khi điều kiện dừng của nó được thoã mãn. Ở mỗi bước, nó quyết định đường đidựa trên chi phí đường đi cho đến hiện tại và ước lượng chi phí cần để mở rộng tất cả con đường đi đến đích. Nếu $n$ là nút kế tiếp để ghé thăm, $g(n)$ chi phí cho đến hiện tại, và $h(n)$ ước lượng chi phí cần thiết để mở rộng đường đi đến đích, sau đó nó chọn nút mà tối tiểu được $f(n)$, trong đó $f(n) = g(n) + h(n)$. . Chúng ta phải chọn một admissible heuristic (heuristic có thể chấp nhận được) sao cho nó không bao giờ ước tính quá mức chi phí để đạt được mục tiêu. Trong một biến thể, được gọi là Best First Search, heuristic chọn đường đi mới chi phí tổng cộng thấp nhất cho đến hiện tại, tức là, nó đặt $h(n) = 0$. Cũng tồn tại tài liệu chuyên sâu về những heuristic khác nhau mà có thể được dùng trong tìm kiếm $A^{*}$. . 2.2 Các thuật toán xác định trung tâm - Centrality Detection Algorithms . Các thuật toán xác định trung tâm - The centrality detection algorithms được sử dụng để hiểu tốt hơn những vai trò được đảm nhận bởi các nút khác nhau trên toàn bộ đồ thị. Phân tích này có thể giúp chúng ta hiểu biết những nút quan trọng nhất trong một đồ thị, tính linh động của một nhóm và khả năng bắc cầu (nối) giữa những nhóm (groups) với nhau. . Có rất nhiều biến thể của thuật toán xác định trung tâm (Centrality Detection Algorithms): degree centrality, closeness centrality, between-ness centrality, và page rank. . Degree centrality đơn giản là đếm số những cạnh ra/ vào (incoming and/or outgoing edges). Một nút với một ra cao (a high outgoing degree) trong mạng lưới chuỗi cung ứng(supply chain network) gợi ý đó là một nhà cung ứng độc quyền (a supplier monopoly). . Closeness centrality xác định những nút mà có đường đi ngắn nhất đến tất cả các nút khác. Với những thông tin như vậy có thể hữu ích trong việc xác định vị trí cho một dịch vụ mới để mà nó có thể tiếp cận phạm vi khách hàng rộng nhất. . Between-ness centrality xác định một nút dựa trên số con đường đi ngắn nhất giữa các nút đi qua nó. Between-ness centrality là một độ đo phạm vi ảnh hưởng bởi những nút trong một mạng. . Cuối cùng, thuật toán PageRank (the PageRank Algorithm) đo mức độ quan trọng của một nút dựa trên những nút khác mà liên kết đệ quy. . Trong phần thảo luận này, chúng ta sẽ đề cập thuật toán PageRank một cách chi tiết hơn. Ban đầu PageRank được phát triển cho việc xếp hạng (ranking) những trang web cho WWW Search (Tìm kiếm WWW). Nó cho phép đo ảnh hưởng bắc cầu (transitive influence) trên một nút. Ví dụ như, một nút liên kết với một vài nút rất quan trọng có thể quan trọng hơn nút mà liên kết với một lượng lớn các nút không quan trọng. Chúng ta có thể định nghĩa PageRank của một nút như sau: . $PR(u) = (1- d) + d times left( frac{PR(T_1)}{C(T_1)} + … + frac{PR(T_n)}{C(T_n)} right)$ . Trong biểu thức ở trên, chúng ta giả định rằng nút $u$ có những cạnh vào từ những nút $T_1, T_2, …, T_n$. Chúng ta sử dụng $d$ như một damping factor - hệ số đệm mà thường được đặt là $0.85$. $C(T_1), C(T_2), …, C(T_n)$ là số cạnh vào từ những nút $T_1, T_2, …, T_n$. Thuật toán thực hiện một cách tuần tự bằng cách đầu tiền cài đặt PageRank cho tất cả các nút về cùng một giá trị, và sau đó tuần tự cải thiện nó với một số lần duyệt cố định, cho đến khi những giá trị này hội tụ. . Ngoài phiên bản gốc của nó được sử dụng trong việc xếp hạn các kết quả tìm kiếm cho những truy vấn WWW, PageRank cho thấy nhiều ứng dụng thú vị khác. Ví dụ như, nó được sử dụng trên các trang phương tiện xạ hội (social media sites) để gợi ý cho một người dùng cụ thể nên theo dõi ai. Nó cũng được sử dụng trong phân tích gian lân (fraud analysis) để xác định những hoạt động bất thường với những nút trong một đồ thị. . 2.3 Các thuật toán xác định cộng đồng - Community Detection Algorithms . Nguyên lý chung cơ bản cho những thuật toán xác định cộng đồng (The general principle underlying the community detection algorithms) là những nút mà nằm trong một công đồng có nhiều quan hệ trong cộng đồng hơn những nút nằm ngoài cộng đồng đó. Đôi khi, phân tích cộng đồng (Community Analysis) có thể là bước phân tính đầu tiên trong một đồ thị để mà một phân tích sâu hơn có thể được thực hiện với những nút trong cộng đồng. . Có nhiều thuật toán xác định cộng đồng khác nhau - Community Detection Algorithm như: connected components, strongly connected components, label propagation và fast unfolding (cũng được gọi là Louvain algorithm) . Hai thuật toán đầu tiên trong số các thuật tán, connected components - thành phần liên thông, strongly connected components - thành phần liên thông mạnh thường được sử dụng trong những phân tích khởi đầu cho một đồ thị. Thuật toán thành phần liên thông (Connected Components Algorithm) và thuật toán thành phần liên thông mạnh (Strongly Connected Components Algorithm) là những kỹ thuật chuẩn trong Lý thuyết Đồ thị (Graph Theory). Một thành phần liên thông (A connected component) là một tập các nút mà có một đường đi giữa hai nút bất kỳ trong một đồ thị vô hướng. Một thành phần liên thông mạnh (A strongly connected component) là một tập các nút mà với bất kỳ nút A và B nào trong tập hợp, tồn tại một đường đi nối từ nút A đến nút B và đường đi từ nút B đến nút A. . Cả label propagation - Nhãn lan truyền và fast unfolding là những thuật toán bottom-up cho việc xác định cộng đồng trong một đồ thị lớn. Chúng ta sẽ xem xét cả hai thuật toán này chi tiết hơn. . Label propagation bắt đầu bằng việc gán cho mỗi nút trong một đồ thị một cộng đồng khác nhau. Sau đó, chúng ta sắp xếp các nút một cách ngẫu nhiên để cập nhật cộng đồng của chúng như sau. Chúng ta kiểm tra những nút theo thứ tự được chỉ định, với mỗi nút, chúng ta kiểm ra láng giềng của nó và đặt cộng đồng nó cho cộng đồng được chia sẻ bởi phần lớn láng giềng của nó. Các mối quan hệ bị phá vỡ một cách ngẫu nhiên đồng nhất. Thuật toán dừng khi mỗi nút được gán cho một cộng đồng được chia sẻ bởi phần lớn láng giềng của nó. :v? . Trong thuật toán Fast Unfolding, có hai giai đoạn. Chúng ta khởi tạo mỗi một nút là một cộng đồng riêng biệt. Trong giai đoạn đầu tiên, chúng ta kiểm tra mỗi nút và mỗi láng giềng của nó và đánh giá liệu có bất kỳ lợi ích tổng thể nào khi tính mô-đun khi đặt nút này vào cùng một cộng đồng với một láng giềng hay không. Một độ đo để tính toán mô-đun được định nghĩa. Nếu không có lợi ích nào, nút sẽ rời khởi cộng đồng ban đầu của nó. Trong giai đoạn thứ hai của thuật toán, chúng ta khởi tạo một mạng mới trong đó một nút tương ứng với mỗi cộng đồng từ giai đoạn 1, và một cạnh liên kết giữa hai nút nếu có một canh liên kết giữa vài nút trong những cộng đồng giai đoạn 1 tương ứng của chúng. Liên kết giữa những nút trong cùng một cộng đồng trong giai đoạn 1 dẫn đến các khuyên (self-loops) cho nút tương ứng với cộng đồng của chúng trong giai đoạn 2. Khi giai đoạn hai hoàn tất, thuật toán lặp lại bằng cách áp dụng giai đoạn 1 lên đồ thị kết quả. . Một ví dụ về một hàm tính toán mô-đun (a modularity function) được sử dụng trong thuật toán ở bên trên . $Q = sum_{i=1}^k left[ frac{e_i}{m} - left( frac{d_i}{2m} right)^{2} right]$ . Trong biểu thức trên, chúng ta tính toán được điểm tổng mô-đun (overall modularity score) Q của một mạng được phân tách thành $k$ cộng đồng, trong đó $e_i$ và $d_i$ là tương ứng với số nút, và tổng bậc các nút trong cộng đồng $i$m và $m$ là tổng số cạnh trong mạng. . Cả label propagation algorithm và fast unfolding algorithm cho ra những chi tiết về cộng đồng mới nổi (emergent communities) và những tìm ẩn ngoài dự kiến (potentially unanticipated). Việc thực hiện khác nhau cũng có thể dẫn đến việc xác định các cộng đồng khác nhau. . 3. Các thuật toán suy luận dựa trên Ontology - Ontology-based Inference Algorithms . Suy luận dựa trên Ontology phân biệt một hệ thống đồ thị tri thức (knowledge graph system) với một hệ thống suy luận dựa trên đồ thị tổng quát (general graph-based system). Chúng ta sẽ phân loại suy diễn dựa trên Ontology thành hai loại: . - (1) Taxonomic Inference - Suy luận phân loại . - (2) Rule-based inference - Suy luận dựa trên luật . Suy luận phân loại (Taxonomic Inference) chủ yếu dựa trên phân cấp các lớp (hierarchy of classes) và thể hiện (instances) và kế thừa (inheritance) của những giá trị qua những cấp bậc. Suy luận dựa trên luật (Rule-based inference) có thể liên hệ với những luật logic tổng quát. Chúng ta có thể truy cập suy luận Ontology thông qua một giao diện khai báo truy vấn, và do đó, nó có thể được sử dụng như một dịch vụ suy luận chuyên biệt (specialized reasoning service) cho một lớp truy vấn xác định. . 3.1 Taxonomic Reasoning - Suy diễn phân loại . Taxonomic reasoning - Suy diễn phân loại được áp dụng trong những tình huống mà nó có ích trong việc tổ chức tri thức thành những lớp (classes). Chúng ta sẽ đề cập những khái niệm về class membership, class specialization, disjoint classes, value restriction, inheritance và various inferences có thể được rút ra suy luận bằng cách sử dụng chúng. . Cả đồ thị thuộc tính (Property Graph) và mô hình dữ liệu RDF (RDF Data Model) đều hỗ trợ lớp. Với đồ thị thuộc tính, kiểu các nút tương đương với lớp. Với RDF, có một mở rộng gọi là RDF Schema - Lược đồ RDF mà hộ trợ định nghĩa các lớp. Trong một mở rộng cao cấp hơn của RDF như Web Ontology Language và Semantic Web Rule Language, một sự hỗ trợ đầy đủ sẵn có cho việc định nghĩa các lớp và các luật. . Để thảo luận Taxonomic Reasoning, chúng ta chọn cách giới thiệu ra khỏi đồ thị thuộc tính (Property Graph) và mô hình dữ liệu RDF (RDF Data Model). Chúng ta sẽ giới thiệu những khái niệm cơ bản của taxonomies như class membership, disjointness, constraints và inheritance bằng cách sử dụng Datalog như một ngôn ngữ đặc tả ( a specification language). . 3.1.1 Class Membership - Lớp Membership . Giả sử chúng ta mong muốn mô hình hoá dữ liệu về quan hệ họ hàng (kinship). Chúng ta có thể định nghĩa những quan hệ một ngôi (unary relations) của male và female như những lớp, có những thành viên như art, bob, bea, coe, … Những thành viên của một lớp được coi như một thể hiện của lớp đó. . Đối với mỗi vị từ một ngôi mà chúng tôi cũng muốn tham chiếu đến như một lớp, chúng ta thêm một đối tượng không đổi (object constant) với cùng tên với tên của quan hệ không đổi (relation constant) như sau .     . class(male) | class(female) | . Do vậy, male vừa là một đối tượng không đổi (object constant) vừa là quan hệ không đổi (relation constant) . Đây là một ví dụ về cách dùng của metaknowledge và đôi khi nó cũng được gọi là punning. . Để biểu diễn art là một thể hiện của lớp male, chúng ta thêm vào một quan hệ gọi là instance_of và sử dụng nó như sau: .     . instance_of(art,male) | instance_of(bea,female) | . instance_of(bob,male) | instance_of(coe,female) | . instance_of(cal,male) | instance_of(cory,female) | . instance_of(cam,male) |   | . 3.1.2 Class Specialization - Lớp Specialization . Những lớp có thể được tổ chức thành dạng hệ thống phân cấp. Ví dụ, chúng ta có thể thêm vào một lớp person. Cả male và female bây giờ là lớp con - subclass của person .     . subclass_of(male,person) | subclass_of(female,person) | . Quan hệ subclass_of là quan hệ bắc cầu, tức là nếu A là một lớp con (subclass) của B, và B là một lớp con (subclass) của C, thì A là một lớp con (subclass) của C. Lấy ví dụ, nếu mother là một lớp con của female, thì mother cũng là một lớp con của person. .   . subclass_of(A,C) :- subclass_of(A,B) &amp; subclass_of(B,C) | . Những quan hệ subclass_of và instance_of được liên hệ trong đó, nếu A là một lớp con của Bm thì tất cả những thể hiện của A cũng là thể hiện của B. Trong ví dụ của chúng ta, tất cả những thể hiện của male cũng là tất cả những thể hiện của person. .   . subclass_of(I,B) :- subclass_of(A,B) &amp; instance_of(I,A) | . Một hệ thống phân cấp lớp (Class hierarchy) không được chứa các chu trình (cycles) bởi vì điều đó có nghĩa rằng một lớp là một lớp con của chính nó, điều này không chính xác về mặt ngữ nghĩa. (Cũng dễ hiểu) . 3.1.3 Class Disjointness - Lớp Disjointness . Chúng ta nói rằng một lớp A là disjoint - tách rời với một lớp khác là B nếu không có thể hiện nào của một trong số chúng là thể hiện của một lớp kia. Chúng ta có thể khai báo hai lớp là tách rời với nhau hoặc một tập hợp các lớp là một phân vùng sao cho mỗi lớp trong tập đó là tách rời từng cặp với mọi lớp khác. Trong ví dụ quan hệ họ hàng, lớp make và female tách rời với nhau: .   . ~instance_of(I,B) :- disjoint(A,B) &amp; instance_of(I,A) | . ~instance_of(I,A) :- disjoint(A,B) &amp; instance_of(I,B) | . disjoint(A1,A2) :- partition(A1,…,An) | . disjoint(A2,A3) :- partition(A1,…,An) | . disjoint(An-1,An) :- partition(A1,…,An) | . 3.1.4 Class Definition - Lớp Definition . Những lớp được định nghĩa bằng cách sử dụng những giá trị quan hệ necessary (cần) và sufficient (đủ). Ví dụ: age (tuổi) là giá trị quan hệ cần thiết cho một người. Nếu chúng ta định nghĩa một lớp người tóc nâu (a brown-haired person), điều đó là cần (necessary) và đủ (sufficient) cho một người có tóc màu nâu trở thành một thể hiện của lớp này: . instance_of(X,brown_haired_person) :- . instance_of(X,person) &amp; has_hair_color(X,brown) . | . Lớp chỉ có những giá trị quan hệ cần thiết được gọi là primitive classes - lớp nguyên thuỷ và lớp mà chúng ta biết được cả những giá trị cần và đủ được gọi là defined classes. Định nghĩa đủ của một lớp có instance_of trong phần đầu của nó . 3.1.5 Value Restriction - Giới hạn giá trị . Chúng ta có thể giới hạn các đối số của một quan hệ mà là thể hiện của những lớp xác định. Trong ví dụ quan hệ họ hàng, chúng ta có thể giới hạn giá trị của quan hệ parent để mà những đối số của nó luôn luôn là thể hiện của lớp person. Do vậy, nếu một lập luận yêu cầu chứng minh parent(table, chair), nó có thể kết luận đơn giản là không đúng bằng cách nhận thấy cả table và chair không là thể hiện của person. Giới hạn trên đối số đầu tiên của một quan hệ thường được gọi là một miền giới hạn (a domain restriction) và giới hạn trên đối số thức hai của một quan hệ được gọi là khoảng giới hạn (range restriction). Tương tự, giới hạn có thể được định nghĩa cho những mối quan hệ đa ngôi. .   . illegal :- domain(parent,person) &amp; parent(X,Y) &amp; ~instance_of(X,person) | . illegal :- range(parent,person) &amp; parent(X,Y) &amp; ~instance_of(Y,person) | . 3.1.6 Cardinality and Number Consraints - Các ràng buộc về số lượng và số học . Chúng ta có thể giới hạn nhiều hơn những giá trị của những quan hệ bằng cách xác định những ràng buộc số lượng và số học. Một ràng buộc số lượng giới hạn số lượng của một mối quan hệ và một ràng buộc số học xác định khoảng giá trị số học mà một quan hệ có thể có. Ví dụ như, chúng ta có thể nói rằng một người có chính xác hai phụ huynh, và tuổi của một người nằm giữa 0 và 100 năm. .   . illegal :- instance_of(X,person) &amp; ~countofall(P,parent(P,X),2) | . illegal :- instance_of(X,person) &amp; age(X,Y) &amp; min(0,Y,Y) | . illegal :- instance_of(X,person) &amp; age(X,Y)&amp; min(100,Y,100) | . 3.1.7 Inheritance - Kế thừa . Những giá trị quan hệ của một lớp được cho là kế thừa từ những thể hiện của nó. Ví dụ như, nếu chúng ta khẳng định rằng art là một thể hiện của lớp brown_haired_person, chúng ta có thể kết luận has_hair_color(art,brown). Nói chung, một đối tượng có thể là thể hiện của nhiều lớp. Trong trường hợp đa kế thừa, những giá trị kế thừa được từ những lớp khác nhau có thể xung đột và gây ra vi phạm ràng buộc, Ví dụ, nếu art là một thể hiện của lớp brown_haired_person, và một lớp bald_person với ràng buộc là người đó không có tóc, chúng ta sẽ mắc phải vi phạm ràng buộc. Trong trường hợp vi phạm ràng buộc, hoặc là giá trị vị phạm ràng buộc phải được loại bỏ hoặc những kỹ thuật lý luận không nhất quán (para-consistent reasoning) phải dược sử dụng để xử lý những trường hợp không nhất quán như vậy. . 3.1.8 Reasoning with Classes - Suy luận với các lớp . Có bốn loại suy luận được quan tâm với các lớp: . - (1) Cho hai lớp A và B, liệu A có phải là lớp con của B? . - (2) Cho một lớp A và một thể hiện I, liệu I có là một thể hiện của A? . - (3) Cho một quan hệ xác định nó là đúng hay sai? . - (4) Cho một quan hệ, xác định những những giá trị của các biến làm cho nó đúng. . Hai suy luận đầu tiên tương đương với việc tính toán trên quan điểm quan hệ subclass và instance_of. Chúng cũng có thể được cài đặt bằng các thuật toán tìm kiếm đường đi trên đồ thị xác định bởi các lớp và các thể hiện của chúng. Hai suy luận cuối tương đương với quan đỉểm quan hệ nhỏ được quan tâm. . 3.2 Rule-based Reasoning - Suy luận dựa trên luật . Không có ranh giới rõ ràng giữa rule-based reasoning và taxonomic reasoning. Cho dù chúng ta sử dụng thông qua Datalog như một ngôn ngữ đặc tả cho taxonomic reasoning. Nó có thể cài đặt rất nhiều những suy luận mong muốn trong một rule engine. Trong phần này, chúng ta sẽ xem xét một ví dụ về rule-based reasoning mà liên quan tới dạng nâng cao của những luật được gọi là quy luật tồn tại. Chúng ta sẽ bắt đầu với một ví dụ đồ thị tri thức mà cận những suy luận như vậy và sau đó chúng ta sẽ đề cập những thuật toán suy luận dựa trên luật (rule-based reasoning algorithm) thực hiện những suy luận được yêu cầu. . 3.2.1 Example Scenario Requiring Rule-based Reasoning - Ví dụ về trường hợp cần suy luận dựa trên luật . Xem xét một đồ thị thuộc tính với lược đồ được cho ở bên dưới đây. Những công ti sản suất sản phẩm chứa hoá chất. Những người có liên quan tới nghiên cứu hoá học và họ có thể được tài trợ bởi những công ty. . Cho đồ thị thuộc tính như trên, chúng ta quan tâm đến việc quyết định xem nếu một người có thể có xung đột lợi ích khi tham gia vào một nghiên cứu. Chúng ta có thể định nghĩa quan hệ xung đồ bằng cách sử dụng luật Datalog sau đây: .   . coi(X,Y,Z) :- involved_in(X,Y) &amp; about(Y,P) &amp; funded_by(X,Z) &amp; has_interest(Y,P) | . has_interest(X,Z) :- produces(X,Y) &amp; contains(Y,Z) | . Quan hệ has_interest không phải nằm trong lược đồ đồ thị thuộc tính được thêm vào. Nhưng với sự giúp đỡ của việc định nghĩa nó bằng cách dùng một luật, một rule engine có thể tính toán xung đột của quan hệ quan tâm đến coi. Trong một vài trường hợp, chúng ta có thể quan đến việc thêm vào những giá trị đã được tính toán của quan hệ coi vào đồ thị tri thức của chúng ta. Vì coi là quan hệ ba ngôi, chúng ta sẽ cần phải tái tổ chức nó. Vì tái tổ chức yêu cầu thêm vào những đối tượng mới trong đồ thị, chúng ta có thể xác định chúng bằng cách sử dụng một quy luật tồn tại được cho bên dưới: .   . ∃c conflict_of(c,X) &amp; conflict_reason(c,Y) &amp; conflict_with(c,Z) :- involved_in(X,Y) &amp; about(Y,P) &amp; funded_by(X,Z) &amp; has_interest(Y,P) | . Nói chung, những luật tồn tại cần thiết bất cứ khi nào chúng ta cần phải tạo ra những đối tượng mới trong đồ thị tri thức. Tái tổ chức quan hệ là một tình huống cụ thể. Đôi khi, chúng ta có thể cần tạo ra những đối tượng mới thoã mãn những ràng buộc xác dịnh (certain constraints). Ví dụ như, xem xét một ràng buộc: mọi con người phải có hai cha me. Với một người, cha mẹ có thể không cần biết, và nếu chúng ta muốn đồ thị tri thức của chúng ta tiếp tục phù hợp với ràng buộc này, chúng ta phải thêm vào hai đối tượng biểu diễn cha me như một người. Vì điều này có thể dẫn đến vô số các đối tượng mới, nên điển hình là đặt giới hạn về cách các đối tượng mới được tạo ra. . 3.2.2 Approach for Rule-based Reasoning - Phương pháp tiếp cận cho suy diễn dựa trên luật . Để hỗ trợ suy luận dựa trên luật trên đồ thị tri thức, chúng ta thường dùng một rule engine với dữ liệu trên đồ thị tri thức. Chúng ta đề cập ở đây một vài chiến lược suy luận khác nhau được sử dụng bởi những rule engine. . Trong chiến lược bottom-up, được gọi là Chase, chúng ta áp dụng tất cả những luật dựa trên đồ thị tri thức, và thêm vào một số dữ kiện mới cho nó cho đến khi chúng ta không cần phải khai báo những dữ kiện mới nữa. Như đã nói đến ở phần trước, chúng ta cần đưa ra những chiến lược dừng để đối phó với những tình huống mà những suy luật thêm vào không cung cấp những thông tin hữu ích. Khi chúng ta tính toán xong Chase, suy luận có thể được thực hiện bằng những phương thức truy vấn truyền thống. . Trong xử lý truy vấn top-down, chúng ta bắt đầu từ câu truy vấn sẽ được trả lời, và áp dụng những luật cơ bản nhất. Một chiến lược top-down cần một tương tác chặt chẽ giữa engine truy vấn của đồ thị tri thức với luật đánh giá. Với tiếp cận này, cách tiếp cận này có thể sử dụng ít không gian hơn rất nhiều so với chiến lược lập luận bottom-up . Những luật engine có độ hiệu quả cao và có thể mở rộng sử dụng những truy vấn tối ưu (query optimization) và những kỹ thuật ghi lại (rewriting techniques). Chúng cũng dựa trên việc nắm bắt các chiến lược để đạt được hiệu quả thực thi. . 4. Tổng kết . Trong chương này, chúng ta đã đề cập những thuật toán suy diễn khác nhau cho đồ thị tri thức. Những thuật toán đồ thị như tìm kiếm đường đi, xác định công đồng, … được hỗ trợ bởi hầu hết các graph engine trong thực tế. Graph engine thường giới hạn hỗ trợ cho ontology và rule-based reasoning. Các engine đồ thị tri thức (Knowledge Graph Engines) hiện đang bắt đầu trở nên sẵn sàng hỗ trợ cả các thuật toán đồ thị tổng quát cũng như ontology và rule-based reasoning . Bài tập: . …Sẽ cập nhật sau… . Bài giảng gốc: https://web.stanford.edu/class/cs520/2020/notes/What_Are_Some_Inference_Algorithms.html .",
            "url": "https://nhutnamhcmus.github.io/lenux-notebooks/2021/06/28/what-are-some-inference-algorithms.html",
            "relUrl": "/2021/06/28/what-are-some-inference-algorithms.html",
            "date": " • Jun 28, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "How To Create A Knowledge Graph From Text",
            "content": "ĐỒ THỊ TRI THỨC - KNOWLEDGE GRAPH . Đây là bản dịch từ Course CS520: Knowledge Graphs | Data Models, Knowledge Acquisition, Inference and Applications | . Department of Computer Science, Stanford University, Spring 2021 . Knowledge graphs have emerged as a compelling abstraction for organizing world’s structured knowledge over the internet, capturing relationships among key entities of interest to enterprises, and a way to integrate information extracted from multiple data sources. Knowledge graphs have also started to play a central role in machine learning and natural language processing as a method to incorporate world knowledge, as a target knowledge representation for extracted knowledge, and for explaining what is being learned. This class is a graduate level research seminar and will include lectures on knowledge graph topics (e.g., data models, creation, inference, access) and invited lectures from prominent researchers and industry practitioners. The seminar emphasizes synthesis of AI, database systems and HCI in creating integrated intelligent systems centered around knowledge graphs. . Mục đích: Là tìm hiểu cũng như trau dồi kiến thức chuyên môn trong lĩnh vực Knowledge Graph cũng như từ vựng tiếng Anh. Không vì mục đích kinh doanh hay bất cứ mục đích về lợi nhuận, tất cả là vì mục đích chia sẻ kiến thức và học tập. . Mọi thông tin về những chủ đề được note lại có thể tìm thấy ở đây: . https://web.stanford.edu/class/cs520/2020/notes/Table_Of_Contents.html . Video của các buổi seminar trên địa chỉ Youtube: . https://www.youtube.com/playlist?list=PLDhh0lALedc5paY4N3NRZ3j_ui9foL7Qc . Mọi vấn đề về dịch thuật, thuật ngữ xin để lại comment hoặc gửi về địa chỉ email: lenam.fithcmus@gmail.com với tiêu đề . [ISSUES OF KG TRANSLATION] . HOW TO CREATE A KNOWLEDGE GRAPH FROM TEXT . LÀM THẾ NÀO KHỞI TẠO MỘT ĐỒ THI TRI THỨC TỪ VĂN BẢN . 1. Giới thiệu . Những nguồn dữ liệu văn bản giống như tin tức kinh doanh và tài chính, những hồ sơ SEC, và những trang web như Wall Street Journal, chứa thông tin có giá trị cao cho những tác vụ kinh doanh như nghiên cứu thị trường - market research, kinh doanh thông minh - business intelligence, … Chúng ta có thể sử dụng Xử lý ngôn ngữ tự nhiên (Natural Language Processing -NLP) để xử lý những nguồn dữ liệu, và khởi tạo đồ thị tri thức để có thể hỗ trợ nhiều loại phân tích. Tuy nhiên, NLP là một công nghệ chuyên biệt (specialized) và rất phức tạp (sophisticated) và mục đích của chúng ta không phải cung cấp một phạm vi toàn diện và chi tiết về nó. Mục đích của chúng ta ở đây là dựa vào những khái niệm cơ sở của NLP mà có thể hữu ích trong nhiều mối quan tâm chính và mục tiêu chính vẫn là khởi tạo một đồ thị tri thức. Một số nhà cung cấp đã tạo ra các dịch vụ kinh doanh xoay quanh việc xử lý văn bản ngôn ngữ tự nhiên và cung cấp dữ liệu có cấu trúc cho những người khác để tiêu thụ. . Có ba tác vụ Xử lý ngôn ngữ tự nhiên - NLP task liên hệ trực tiếp đến xây dựng đồ thị tri thức (knowledge graph construction): . - (1) Entity Extraction - Rút trích thực thể . - (2) Relation Extraction - Rút trích quan hệ . - (3) Entity Resolution - Phân giải thực thể . Entity Extraction - Rút trích thực thể là tác vụ định danh những thực thể chính (key entities) được quan tâm (ví dụ: Organizations - Tổ chức, People - Con người, Place - Nơi chốn, …) từ văn bản. Những thực thể này thông thường tạo nên nút (node) trong một đồ thị tri thức. . Relation Extraction - Rút trích quan hệ là tác vụ mà khi được cho hai thực thể quan tâm, và một số văn bản, chúng rút trích ra những quan hệ giữa chúng (ví dụ: net sales, management team information, … ) từ văn bản. Thỉnh thoảng, rút trích quan hệ cũng được dùng để rút trích những thuộc tính của một thực thể được cho trước. Mối quan hệ và những thuộc tính được rút trích thông thường sẽ trở thành những mối quan hệ hoặc những thuộc tính nút trong đồ thị tri thức của chúng ta. . Entity Resolution - Phân giải thực thể là tác vụ định danh xem nhiều đề cập trong một văn bản có tham chiếu đến cùng một thực thể hay không. Ví dụ như, trong một đoạn văn bản, “John Smith”, “He” và “Her father” có thể tất cả cùng tham chiếu đến cùng một thực thể. . Trong chương này, chúng ta sẽ tìm hiểu một cái nhìn tổng quan về những kỹ thuật được sử dụng trong rút trích thực thể (Entity Extraction ) và quan hệ (Relation Extraction). Chúng ta sẽ không thảo luận về phân giải thực thể - entity resolution trong phần thảo luận này bởi vì nó là một đề tài nâng cao so với phạm vi trình bày hiện tại :)) Hầu hết những kỹ thuật cho rút trích thực thể và quan hệ, mà phổ biến hiện nay, dựa trên điều chỉnh với một mô hình ngôn ngữ được huấn luyện từ trước (pre-trained language model) trong tác vụ đang được thực hiện. Với mục đích của chúng ta, chúng ta coi những mô hình ngôn ngữ được huấn luyện từ trước (pre-trained language model) và những kỹ thuật máy học (machine learning techniques) như những chiếc hộp đen có sẵn để sử dụng như những món hàng bán sẵn ngoài chợ (off-the-shelf commodities). Quá trình này trong Xử lý ngôn ngữ tự nhiên - NLP và Máy học - Machine Learning cho phép những người tạo ra đồ thị tri thức tập trung vào sản phẩm cuối cùng, và cung cấp những dữ liệu huấn luyện và đánh giá thích hợp mà cần thiết cho sự điều chỉnh của mô hình ngôn ngữ (language models). Chúng ta sẽ bắt đầu với một tổng quan về mô hình ngôn ngữ và sao đó mô tả chi tiết các tác vụ rút trích thực thể và rút trích quan hệ. . 2. Tổng quan về mô hình ngôn ngữ - Overview of Language Models . Mô hình ngôn ngữ là tác vụ dự đoán xem từ nào xuất hiện kế tiếp trong một văn bản. Ví dụ, cho một câu: “students opened their”, một mô hình ngôn ngữ sẽ dự đoán từ kế tiếp mà có thể hoàn thành câu này. Trong trường hợp này, từ kế tiếp có thể là book, exam, laptop, … . Tổng quát hơn, cho một tập hợp những từ $x_1, x_2, …, x_{n-1}$, một mô hình ngôn ngữ dự đoán xác suất $P(x_n | x_1, x_2, …, x_{n-1})$, trong đó $x_n$ là một từ bất kỳ trong bộ từ vựng. Mô hình ngôn ngữ có thể được sử dụng rỗng rãi trong tự động hoàn thành yêu cầu tìm kiếm trên web, trong tự động chỉnh sửa từ trong xử lý từ, … . Mô hình ngôn ngữ hiện đại được tạo ra bằng cách huấn luyện một mô hình Học sâu (Deep Learning Model), như là Recurring Neural Network, trên một kho ngữ liệu văn bản cực lớn. Nhiều biến thể của các mô hình ngôn ngữ được huấn luyện trướccó sẵn như những sản phẩm mã nguồn mở có thể được tinh chỉnh cho mục đính của những tác vụ xác định đang thực hiện. Vì chúng ta đang thảo luận những kỹ thuật cho rút trích thực thể và rút trích quan hệ, chúng ta cũng sẽ mô tả làm thế nào mà mô hình ngôn ngữ có thể được tinh chỉnh cho những tác vụ này. . 3. Rút trích thực thể - Entity Extraction . Chúng ta sẽ bắt đầu bằng cách xem xét một ví dụ cụ thể về rút trích thực thể và sau đó tìm hiểu tổng quan những cách tiếp cận khác nhau cho rút trích thực thể và kết lại phần này bằng thảo luận về một số thách thức trong việc thực hiện tốt ở tác vụ này. . 3.1 Ví dụ về rút trích thực thể - An Example of Entity Extraction . Chúng ta hãy xem xét một mẫu văn bản nhỏ từ một câu chuyện tin tức sau đây: . Cecilia Love, 52, a retired police investigator who lives in Massachusetts, said she paid around $370 a ticket with tax for nonstop United Airlines flights to Sacramento from Boston for her niece’s high school graduation in June, 2020. . Chúng ta sẽ xem xét những thực thể named trong đoạn văn bản phía trên. Một thực thể named là bất cứ thứ gì có thể được tham chiều với một tên thích hợp: a person - một người, a location - một địa điểm, an organization - một tổ chức, … Việc xác định một thực thể được đặt tên thường được mở rộng để bao gồm những thứ không phải là thực thể, bao gồm ngày, giờ và các loại biểu thức khác liên quan đến thời gian và thậm chí cả biểu thức số học, ví dụ: giá . [PERCecilia Love], 52, a retired police investigator who lives in [LOCNew Jersey], said she paid around [MONEY $370] a ticket with tax for nonstop [ORGUnited Airlines] flight to [LOCSacramento] from [LOCBoston] for her niece’s high school graduation in [TIME June, 2020]. . Đoạn văn bản chứa 7 thực thể được đặt tên, một trong số đó là một người - a person (được chỉ định bởi PER), ba trong số đó là địa điểm - location (được chỉ định bởi LOC), một trong số đó là tiền - money (được chỉ định bởi MONEY), một trong đó là tổ chức - organization (được chỉ định bởi ORG) và một trong đó là thời gian - time (được chỉ định bởi TIME). Phục thuộc vào phạm vi của ứng dụng, chúng ta có thể thêm nhiều hơn hoặc ít hơn những kiểu thuộc tính được đặt tên. Ví dụ, trong tác vụ định danh những thuật ngữ khoá trong một văn bản, chỉ có một loại thực thể biểu diễn một cụm từ khóa. . Tác vụ rút trích thực thể hữu ích trong nhiều ứng dụng. Ví dụ như, trong trả lời câu hỏi - question answering, nó có thể giúp lấy ra câu trả lời từ một đoạn văn bản được truy xuất. Trong một ứng dụng xử lý từ, nó có thể giúp trong liên kết một cách tự động những thực thể xuất hiện trong văn bản với những thông tin được thêm vào (như định nghĩa, dữ kiện, …) về những thực thể đó. . 3.2 Những phương pháp tiếp cận cho rút trích thực thể - Approaches to Entity Extraction . Đầu tiên và quan trọng nhất, chúng ta có thể xem rút trích thực thể như một vấn đề gán nhãn. Chúng ta liên hệ một nhãn (label) với mỗi từ, và tác vụ này trở thành việc dự đoán nhãn. Chúng ta có thể thực hiện rút trích thực thể bằng ba phương pháp tiếp cận: . - (1) Sequence labeling . - (2) Deep Learning Models . - (3) Rule-based Approaches . Chúng ta sẽ điểm qua từng phương pháp tiếp cận một . Để tạo điều kiện cho việc gán nhãn, chúng ta thêm vào một lược đồ gán nhãn được biết đến với tên là BIOES trong đó . - B đại diện cho the beginning of an entity - Bắt đầu một thực thể . - I đại diện cho the interior of an entity - Nội dung của một thực thể . - O đại diện cho a word that is not part of an entity - Một từ không nằm trong một thực thể . - E đại diện cho the end of an entity - Kết thúc một thực thể . - S đại diện cho a single word entity - Một từ đơn mô tả thực thể . Lấy một ví dụ, những trong đoạn văn bản phía trên sẽ được gán nhãn như bảng được cho ở bên dưới .                     . Cecilia | B | Love | E | , | O | 52 | O | , | O | . a | O | retired | O | police | O | investigator | O | who | O | . lives | O | in | O | Massachusetts | S | , | O | said | O | . she | O | paid | O | around | O | $370 | S | a | O | . ticket | O | with | O | tax | O | for | O | nonstop | O | . Untied | B | Airlines | E | flights | O | to | O | Sacramento | S | . from | O | Boston | S | for | O | her | O | niece’s | O | . high | O | school | O | graduation | O | in | O | June | B | . , | I | 2020 | E |   |   |   |   |   |   | . Với phương pháp tiếp cận Sequence Labeling - Chuỗi gán nhãn, chúng ta huấn luyện một thuật toán máy học (Machine Learning Algorithm), ví dụ như Conditional Random Fields - Trường điều kiện ngẫu nhiên), sử dụng những đặc trưng (features) như: part of speech - đoạn giọng nói, presence of the word in a list of standard words - hiện diện của một từ trong một danh sách từ chuẩn hoá, word embeddings, word base form, từ liệu có chứa một tiền tố (prefix) hay hậu tố (suffix), liệu từ có được in hoa toàn bộ, … Cần có sự nổ lực đáng để trong Feature Engineering - Kỹ thuật đặc trưng, bởi vì hiệu suất của việc lựa chọn những đặc trưng cụ thể và thuật toán máy học có thể thay đổi bởi phạm vi xem xét. . Với phương pháp tiếp cận Deep Learning - Học Sâu, ở đây không cần những kỹ thuật đặc trưng - feature engineering, và chúng ta đơn giản đưa word embeddings vào một mô hình ngôn ngữ (language model). Thay vì dự đoán xem từ kế tiếp là gì, mô hình ngôn ngữ bây giờ dự đoán một trong năm nhãn (tag) (B, I, O, E, S) cần cho việc nhận dạng thực thể (entity recognition). Để điều chính mô hình ngôn ngữ cho một tác vụ mới, đầu tiên chúng là huấn luyện trước nó sử dụng kho ngữ liệu cho miền đang xem xét, và sau đó huấn luyện nó cho tác vụ đang thực hiện. Trong những tác vụ xác định của mô hình ngôn ngữ, chúng ta cung cấp quá trình huấn luyện bằng cách thêm một token phân biệt (distinguished token) [CLS] mà đại diện cho điểm bắt đầu một thực thể (the beginning of an entity), và một token phân biệt thứ hai [SEP] đại diện cho điểm kết thúc một thực thể (the end of an entity). Quá trình huấn luyện cho phép mô hình dự đoán những nhãn phân biệt (distinguished tags) này để phản hồi một văn bản đầu vào. Những dự đoán như vậy là đủ cho chúng ta để tạo ra một trong năm nhãn cho mỗi từ. . Cuối cùng, với phương pháp tiếp cận Rule-Based - Dựa trên luật, một luật gán nhãn xác định (ne specifies labeling rules) trong một ngôn ngữ truy vấn hình thức (formal query language). Những luật này có thể bao gồm regular expression - biểu thức chính quy, references to dictionaries - tham chiếu tư điển, semantic constraints - ràng buộc ngữ nghĩa, và cũng có thể liên qua để bộ tự động rút trích và những cấu trúc bảng tham chiếu. Những luật này cũng có thể liên quan đến những module máy học cho những tác vụ cụ thể. Áp dụng luật có thể là một chuỗi trình tự theo cách mà đầu tiên chúng ta sử dụng những luật có precision cao (high precision rules), sau đó là tra cứu trong một danh sách tên chuẩn hoá, sau đó là dựa trên kinh nghiệm ngôn ngữ - language-based heuristics, và nếu sau tất cả đều thất bại, thì dùng để những kỹ thuật máy học xác suất (probabilistic machine learning techniques) . 3.3 Những thách thức trong rút trích thực thể - Challenges in Entity Extraction . Mặc dù với những tác vụ xác định, các bộ rút trích thực thể (entity extractors) có thể cho thấy precision và recall trên 90% nhưng đạt được một hiệu suất tốt qua tất cả những miền (across all the domains) có thể là một thách thức. Trong phần này, chúng ta đề cập một thách thức mà chúng ta phải đối mặt trong quá trình rút trích thực thể . . Trong khi gán nhãn quan hệ với lớp của chúng, có rất nhiều trường hợp nhập nhằng (numerous cases of ambiguity). Ví dụ như, cho một thực thể Louis Vuitton, nó có thể tham chiếu đến một người - a person, hoặc một tổ chức - an organization, hoặc sản phẩm thương mai - am commercial product. Không thể giải quyết những vấn đề như sự nhập nhằng nếu như không tính đến ngữ cảnh một cách đáng kể. . Với cách sử dụng một mô hình học máy (machine learning model), chúng ta lượng dữ liệu cực kỳ to lớn. Trong thực tế, dữ liệu thường không có sẵn hoặc phần lớn chúng chưa hoàn thiện. Khi chúng ta huấn luyện mô hình sử dụng dữ liệu không hoàn thiện, nó sẽ ảnh hưởng nghiêm trọng đến hiệu suất. . Một trong những biến thể của rút trích thực thể là định danh những cụm từ khoá trong văn bản. Vì những cụm từ khoá là không giới hạn ở một số lớp, tác vụ định danh những lớp xác định tương ứng với một cụm từ khoá có thể trở nên thách thức hơn. Thỉnh thoảng, những cụm từ khoá quá phức tạp (overly complex) (ví dụ: duplication of a cell by fission), và đôi khi quá chung chung (too general) (ví dụ như: Attach) làm cho tác vụ này quá khó để mà áp dụng một kỹ thuật thống nhất trên diện rộng. . Những thực thể có thể xuất hiện ở nhiều hình dạng khác nhau (different surface forms), ví dụ như: synonyms - từ đồng nghĩa, acronyms - từ viết tắt, plurals - dạng số nhiều và morphological variations - các biến thể hình thái :)))))))))????. Nói chung, rút trích thực thể cần chú trọng về tri thức từ vựng (lexical knowledge) mà thường không tồn tại khi vào một lĩnh vực/ miền mới. Do đó, việc cải thiện hiệu năng của rút trích thực thể, rút trích từ vựng (lexicon extraction) trở thành một tác vụ liên quan thiết yếu. . 4. Rút trích quan hệ - Relation Extraction . Chúng ta sẽ bắt đầu bằng cách đề cặp một vài ví dụ cụ thể về rút trích quan hệ, sau đó tìm hiểu một cách tổng quan về những phương pháp tiếp cận khác nhau cho rút trích quan hệ, và kết lại phần này bằng cách thảo thuận một số thách thức làm sao đạt hiệu suất tốt với tác vụ này. . 4.1 Ví dụ về rút trích quan hệ - Examples of Relation Extraction . Xem xét đoạn văn bản từ phần trước, chúng ta có thể rút trích những quan hệ như Cecilia Love lives in Massachusetts, United Airlines flies from Boston và United Airlines flies to Sacramento, … Trong một tác vụ rút trích quan hệ thông thường, những thực thể đã được định danh trước đó, và trong trường hợp này, nó mở rộng tác vụ rút trích thực thể. Những quan hệ sẽ được rút trích cũng được xác định trước đó. . Một thể hiện thể phổ biến của tác vụ rút trích quan hệ là rút trích những thông tin từ Wikipedia Infoboxes. Ứng dụng rõ ràng của tác vụ này là cải thiện kết quả tìm kiếm trên Internet. Wikipedia infoboxes định nghĩa những mối quan hệ như preceded by, succeeded by, children, spouse, … Đạt được một độ chính xác cao (a high accuracy) đối với tác vụ này có thể là một thách thức bởi một lượng lớn những trường khó (corner cases). Ví dụ, Larry King đã kết hôn nhiều lần, do đó bộ rút trích phải có khả năng lấy ra những thông tin khoảng thời gian mà cuộc hôn nhân tồn tại. . Ở đây cũng tồn tại những miền xác định những mối quan hệ. Ví dụ, Unified Medical Language Systems hỗ trợ những mối quan hệ như causes, treats, disrupts, … Ngoại trừ những quan hệ chuẩn hoá như subclass-of, has_part, những mối quan hệ sẽ được rút trích là những miền xác định và thường yêu cầu một số thiết kế từ trước. Có một số phương pháp tiếp cận để rút trích quan hệ mà không yêu cầu lựa chọn những quan hệ từ trước, nhưng tính hữu ích của những phương pháp như vậy trong thực tế được phát hiện là bị giới hạn. . 4.2 Những phương pháp tiếp cận cho rút trích quan hệ - Approaches to Relation Extraction . Có ba phương pháp diện rộng để rút trích quan hệ: . - (1) syntactic patterns . - (2) various forms of supervised machine learning . - (3) unsupervised machine learning . Như được đề cập từ phần trước, unsupervised machine learning bị giới hạn sử dụng trong thực tế. Do đó chúng ta sẽ xem xét chủ yếu việc sử dụng syntactic patterns và supervised machine learning cho việc rút trích quan hệ. . Một phương pháp tiếp cận kinh điển cho rút trích quan hệ dựa trên syntactic patterns được biết đến như Hearst Patterns. Ví dụ, xem xét câu dưới đây: . The bow lute, such as the Bambara ndang, is plucked and has an individual curved neck for each string. . Cho dù chúng ta chưa từng được nghe đến Bambara ndang, chúng ta vẫn có thể suy luận nó là một loại đàn nguyệt hình cung (a kind of bow lute, lute là một danh từ có nghĩa là đàn nguyệt, đờn tỳ bà, bow: cây cung). Tổng quát hơn, chúng ta có thể định danh syntactic patterns - mẫu cú pháp mà có những chỉ số cao về subclass của mối quan hệ. Năm mẫu cú pháp sau đây đã xuất hiện khá lâu và cực kỳ hiệu quan trong thực tế. .     . Pattern Name | Example | . such as | … works by authors such as Herric, Goldsmith, and Shakespear … | . or other | Bruises, wounds, broken bones, or other injuries … | . and other | .. temples, treasuries, and other Civic Buildings, … | . including | All common law countries including Canada and England … | . especially | Most European countries especially France, England, and Spain, … | . Chúng ta có thể khám pháp những mẫu cú pháp mới cho bất kỳ mối quan hệ nào như sau. Đầu tiên, chúng thu gom những mẫu cho mối quan hệ được cho là đúng. Sau đó, chúng ta tìm những câu mà mối quan hệ là đúng. Bằng cách xác định những điểm chung thông qua những câu đó, chúng ta có thể định nghĩa ra được một mẫu mới. Chúng ta có thể kiểm tra những mẫu (patterns) dựa trên kho ngữ liệu. Một thuật toán như thế được gọi là Dual Iterative Pattern Relation Expansion (DIPRE). . Chúng ta cụ thể hoá nguyên lý hoạt động của nó bằng một vấn đề của việc rút trích cặp (author, title) từ một kho ngữ liệu. Chúng ta bắt đầu với một tập các cặp (author, title) đã được biết, và chúng ta tìm tất cả số lần xuất hiện của chúng trong bộ ngữ liệu, và từ những thứ đó chúng ta tạo ra nhiều mẫu hơn. Thuật toán tiếp tục một cách đệ quy bằng cách sử dụng những mẫu mới để khám phá nhiều sách hơn, và từ việc khám phá những mẫu mới của chúng. Một ví dụ cụ thể, cho một cặp (William Shakespear, The Comedy of Errors), và những câu sau: . - The Comedy of Errors, by William Shakespeare, was … . - The Comedy of Errors, by William Shakespeare, is … . - The Comedy of Errors, one of William Shakespeare’s earliest attempts … . - The Comedy of Errors, one of William Shakespeare’s most … . Chúng ta có thể thu được những mẫu (patterns) sau: . - $?x , by ?y$ . - $?x , text{one of } ?y’s$ . Bằng cách sử dụng những mẫu mới thu được, quá trình rút trích tiếp tục một cách đệ quy. . Phương pháp tiếp cận supervised - có giám sát cho rút trích quan hệ cần dữ liệu huấn luyện phong phú. Bất cứ khi nào dữ liệu huấn luyện là sẵn có, nhiều thuật toán học có sẵn (the off-tbe-shelf) có thể được huấn luyện. Nhưng, trong trường hợp không đủ dữ liệu, tiếp cận giám sát yếu (weak supervision approaches) trở nên phổ biến để giải quyết yêu cầu về dữ liệu. Ý tưởng cơ bản trong weak supervision là sử dụng nhiều hàm gán nhãn gần đúng (several approximate labeling functions) mà có thể tạo ra dữ liệu huấn luyện một cách tự động. Những nhãn yếu (weak labels) này có thể được kết hợp bằng cách sử dụng một hàm xác suất (probabilistic function) . Một ví dụ về một hàm gán nhãn yếu (a weak labeling function), xem xét quan hệ has_part. Với quan hệ này, nó không có khả năng để phát triển những mẫu cú pháp (syntactic patterns) của loại được đề xuất như trên. Một hàm gán nhãn yếu (weak labeling function) có thể có cho mối quan hệ này là đầu tiên tạo ra một phân tích cú pháp phụ thuộc cho câu, và sau đó tìm kiếm hai node trong phân tích mà có một đường đi chiều dài một chứa động từ has hoặc have. Với mối quan hệ taxonomic (mối quan hệ phân loại), một hàm gán nhãn yếu (weak labeling function) bổ sung nếu hai thực thể kết thúc với cùng một từ cơ sở nhưng một trong chúng có một cụm bổ nghĩa ( additional modifier) đứng trước nó, điều này gợi ý một taxonomic relation (ví dụ như: eukaryotic cell SUBCLASS cell). . Để điều chỉnh một mô hình ngôn ngữ cho tác vụ rút trích quan hệ, chúng ta thay đổi biểu diễn đầu vào của một câu để mà mỗi một thuật ngữ cá thể được đánh dấu một cách rõ ràng. Ví dụ: chúng ta đưa vào một câu như [“All”, “[TERM1-START]”, “cells”, “[TERM1-END]”, “have”, “a”, “[TERM2-START]”, “cell” “membrane”, “[TERM2-END]”, “.”], và kỳ vọng mô hình cho ra phân phố xác suất trên những mối quan hệ khác nhau, điều này có thể tồn tại hai thuật ngữ. Mối quan hệ dự đoán được phụ thuộc vào dữ liệu huấn luyện đầu vào. . 4.3 Những thách thức trong rút trích quan hệ . Thách thức chính trong rút trích quan hệ là có được lượng dữ liệu huấn luyện cần thiết. Phương pháp tiếp cận giám sát yếu (weak supervision approach) khá là hứa hẹn bởi dữ liệu huấn luyện không cần phải hoàn thiện. Chúng ta có thể dùng đến những nguồn như Wikidata và Wordnet như một nguồn dữ liệu cho việc định nghĩa những hàm gán nhãn yếu (weak labeling functions). Phát triển một phương pháp tiếp cận mới cho weak labeling functions là một chủ đề đã và đang tiến hành nghiên cứu. . Chúng ta cũng cần có một quy trình làm việc (workflow) tốt để mà xác nhận những kết quả từ các bộ rút trích. Những bộ rút trích thường xuyên được tạo ra bởi cộng đồng (crowdsourcing). Chúng ta cũng có thể ưu tiên xác nhận những quan hệ rút trích được mà có độ tin cậy thấp. Phát triển các vòng lặp active learning là một thách thức khác hiện đang được nghiên cứu. . 5. Tổng kết . Với chương này, chúng ta đề cập đến vấn đề khởi tạo một đồ thị tri thức bằng cách xử lý văn bản. Chúng ta điểm qua hai vấn đề cơ bản là rút trích thực thể (entity extraction) và (relation extracion). Với cả hai tác vụ này, những công trình trước đây tập trung vào xác định những quy tác thủ công và cú pháp cho việc rút trích. Những phương pháp tiếp cận gần đây dựa trên điều đỉnh mô hình ngôn ngữ được huấn luyện sẵn (pre-trained language models) và tinh chỉnh chúng cho những bộ ngữ liệu cụ thể ở công việc đang xử lý. . Với cả rút trích thực thể và rút trích quan hệ, cách tiếp cận phổ biến nhất hiện nay là điều chỉnh một mô hình ngôn ngữ được tạo ra trước bằng cách sử dụng Học Sâu (Deep Learning). Cũng có những phương pháp tiếp cận, dựa trên cú pháp (syntactic) hay dựa trên luật (rule-based) cũng đóng vai trò quan trong trong boostrapping dữ liệu huấn luyện cần cho mô hình Học Sâu (Deep Learning). Việc xác nhận đầu ra của rút trích tiếp tục là một thách thức. . Vấn đề liên kết thực thể (entity linking) hay phân giải thực thể (entity resolution) là một vấn đề quan trong không kém trong việc khởi tạo đồ thị tri thức, nhưng chúng ta không đề cập đến nó trong phần thảo luận này bởi hai lý do: . - Lý do thứ nhất, chúng ta tin rằng thách thức cho việc có được hiệu năng tốt là nằm ở rút trích thực thể (entity extraction) và rút trích quan hệ (relation extraction), chính nó là một rào cản đáng kể . - Lý do thứ hai, một điều kiện tiên quyết để có một hiệu suất tốt trên liên kết thực thể (entity linking) là có sẵn một vốn từ vựng tốt . Với những lý do này, phân giải thực thể (entity resolution) là một kỹ thuật nâng cao (an advanced technique) và nó có thể hoặc không là nút thắc trong giải quyết vấn đề khởi tạo đồ thị. . Bài tập: . …Sẽ cập nhật sau… . Bài giảng gốc: https://web.stanford.edu/class/cs520/2020/notes/How_To_Create_A_Knowledge_Graph_From_Text.html .",
            "url": "https://nhutnamhcmus.github.io/lenux-notebooks/2021/06/27/how-to-create-a-knowledge-graph-from-text.html",
            "relUrl": "/2021/06/27/how-to-create-a-knowledge-graph-from-text.html",
            "date": " • Jun 27, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "What Are Some Knowledge Graph Data Models",
            "content": "ĐỒ THỊ TRI THỨC - KNOWLEDGE GRAPH | Đây là bản dịch từ Course CS520: Knowledge Graphs | Data Models, Knowledge Acquisition, Inference and Applications | . Department of Computer Science, Stanford University, Spring 2021 . Knowledge graphs have emerged as a compelling abstraction for organizing world’s structured knowledge over the internet, capturing relationships among key entities of interest to enterprises, and a way to integrate information extracted from multiple data sources. Knowledge graphs have also started to play a central role in machine learning and natural language processing as a method to incorporate world knowledge, as a target knowledge representation for extracted knowledge, and for explaining what is being learned. This class is a graduate level research seminar and will include lectures on knowledge graph topics (e.g., data models, creation, inference, access) and invited lectures from prominent researchers and industry practitioners. The seminar emphasizes synthesis of AI, database systems and HCI in creating integrated intelligent systems centered around knowledge graphs. . Mục đích: Là tìm hiểu cũng như trau dồi kiến thức chuyên môn trong lĩnh vực Knowledge Graph cũng như từ vựng tiếng Anh. Không vì mục đích kinh doanh hay bất cứ mục đích về lợi nhuận, tất cả là vì mục đích chia sẻ kiến thức và học tập. . Mọi thông tin về những chủ đề được note lại có thể tìm thấy ở đây: . https://web.stanford.edu/class/cs520/2020/notes/Table_Of_Contents.html . Video của các buổi seminar trên địa chỉ Youtube: . https://www.youtube.com/playlist?list=PLDhh0lALedc5paY4N3NRZ3j_ui9foL7Qc . Mọi vấn đề về dịch thuật, thuật ngữ xin để lại comment hoặc gửi về địa chỉ email: lenam.fithcmus@gmail.com với tiêu đề . [ISSUES OF KG TRANSLATION] . WHAT ARE SOME GRAPH DATA MODELS? . MỘT SỐ MÔ HÌNH DỮ LIỆU ĐỒ THỊ . 1. Giới thiệu . Hai mô hình dữ liệu đồ thị phổ biến là mô hình Resource Description Framework (RDF) và mô hình Property Graph (PG). Ngôn ngữ truy vấn cho RDF là SPARQL, và ngôn ngữ truy vấn cho mô hình Property Graph là Cypher. . Trong chương này, chúng ta sẽ trình bày một cách tổng quan bình thường cả hai mô hình dữ liệu và cho những ví dụ truy vấn với chúng. Chúng ta xem xét chuyển đổi biểu diễn dữ liệu bằng một trong các mô hình sang biểu diễn dữ liệu bằng mô hình khác, và cũng so sánh những dữ liệu đồ thị này bằng cách dùng mối quan hệ mô hình dữ liệu thông thường. . 2. Resource Description Frame - Khung mô tả tài nguyên . RDF (Resource Description Frame - Khung mô tả tài nguyên) là một khung (framework) cho việc biểu diễn thông tin (representation information) trên web. Mô hình dữ liệu RDF (RDF Data Model) và ngôn ngữ truy vấn của nó SPARQL được chuẩn hoá bởi World Wide Web Consortium . 2.1 RDF Data Model - Mô hình dữ liệu RDF . Một bộ ba RDF, thành phân cơ sở của biểu diễn trong mô hình này, bao gồm một chủ thể (subject), một thuộc tính (predicate) và một đối tượng (object). Một tập bộ ba như vậy được gọi là đồ thị RDF (RDF Graph). Chúng ta có thể trực quan hoá một bộ ba RDF như một node và một cạnh liên kết có hướng, mà mỗi bộ ba như vậy biểu diễn một đồ thị node-edge-node (nút-cạnh-nút) . . Có thể chia thành ba loại node: . - IRIs - Internationalized Resource Identifier: được sử dụng để xác định duy nhất những tài nguyên trên web . - literals: là một giá trị của một kiểu dữ liệu xác định, ví dụ như: string – chuỗi, integer - số nguyên, … . - Blanks nodes: Là một node mà không có bộ định danh, và tương tự như một ẩn danh (anonmyous) hoặc một biến giá trị tồn tại (existential variable) . Một ví dụ minh hoạ của biểu diễn thông tin sử dụng RDF, chúng ta lấy ví dụ biểu diễn tri thức quan hệ giữa con người. Trong ví dụ này, một người với tên art, được đại diên bởi IRI http://example.org/art. Trong định nghĩa sử dụng IRIs dưới đây có thể được viết tắt bởi một tiền tố.Ví dụ như, chúng ta định nghĩa foaf như một tiền tố cho &lt;&lt;http://xmlns.com/foaf/0.1/&gt;&gt;. Quan hệ tri thức (knows) được định nghĩa bởi IRI http://xmlns.com/foaf/0.1/knows . @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; . @prefix ex: &lt;http://example.org/&gt; . ex:art foaf:knows ex:bob . ex:art foaf:knows ex:bea . ex:bob foaf:knows ex:cal . ex:bob foaf:knows ex:cam . ex:bea foaf:knows ex:coe . ex:bea foaf:knows ex:cory . ex:bea foaf:age 23 . ex:bea foaf:based_near _:o1 . Hai bộ ba minh hoạ cuối cùng, một nút tầm thường (literal node) và một nút trống (blank node).Giá trị của foaf:age là một số nguyên 23, một ví dụ về một literal. Một chuỗi là một kiểu dữ liệu tầm thường phổ biến khác. Giá trị của foaf:based_near là một không gian ẩn danh mà được biểu thị bởi dấu gạch dưới (underscore) như một nút định danh. o1 ở đây là một dữ liệu định danh nổi bộ không có ý nghĩa, nằm bên ngoài ngữ cảnh của đồ thị hiện tại. . Bộ từ vựng RDF là một bộ sưu tập (collection) của những IRI dự định sử dụng trong đồ thị RDF (RDF Graph). IRIs trong bộ từ vựng RDF thường bắt đầu với một chuỗi con chung gọi là một namespace (không gian tên) IRI. Trong ví dụ ở trên, &lt;&lt;http://xmlns.com/foaf/0.1/&gt;&gt; là một không gian tên tiền tố (namespace prefix). Trong một vài không gian tên (namespace), IRIs được liên kết theo quy ước với một tên ngắn được gọi là tiền tố không gian tên (namespace prefix). Trong ví dụ bên trên, chúng ta định nghĩa foaf và ex như tiền tố không gian tên (namespace prefix) . Đồ thị RDF (RDF Graphs) mang tính chất hữu cơ theo nghĩa là chúng cung cấp một bức tranh tổng quan dữ liệu tĩnh. Với phần mở rộng từ vựng phù hợp, chúng có thể diễn đạt thông tin về các sự kiện hoặc các thuộc tính động khác của các thực thể. . Một kho dữ liệu RDF (RDF Dataset) là một tập của nhiều đồ thị RDF (RDF Graphs) và bao gồm chính xác một đồ thị mặc định có thể để trống và không cần đặt tên và một hoặc nhiều đồ thị được đặt tên. Mỗi đồ thị được đặt tên bao gồm một IRI hoặc một nút trống thể hiện tên của nó và đồ thị RDF. . 2.2 SPARQL Query Language - Ngôn ngữ truy vấn SPARQL . SPARQL (đọc là “sparkle” :v xờ pắc kơ le), viết tắt của SIMPle Protocol and RDF Query Language) là một ngôn ngữ truy vấn để truy xuất và thao tác dữ liệu được lưu trữ trong Resource Description Framework (RDF). SPARQL thể được sử dụng để thể hiện các truy vấn trên nhiều nguồn dữ liệu khác nhau, cho dù dữ liệu được lưu trữ nguyên bản dưới dạng RDF hay được xem dưới dạng RDF thông qua phần mềm trung gian. SPARQL chứa các khả năng truy vấn bắt buộc và tuỳ chọn mẫu đồ thị (graph patterns) với liên kết (conjunctions) và phi liên kết (disconjuntions) của chúng. SPARQL cũng hỗ trợ mở rộng truy vấn giá trị kiểm tra và ràng buộc bởi nguồn đồ thị RDF. Kết quả của truy vấn SPARQL có thể là các tập hợp hoặc những đồ thị RDF (RDF Graphs) . Hầu hết dạng của một truy vấn SPARQL bao gồm một tập bộ ba mẫu (a set of triple patterns) được gọi là một mẫu đồ thị cơ sở (a basic graph pattern). Bộ ba mẫu giống như bộ ba RDF ngoại trừ rằng mỗi chủ thể (subject), thuộc tính (predicate) và đối tượng (object) có thể là một biến (variable). Một mẫu đồ thị cơ sở (Basic Graph Pattern) khớp với một đồ thị con (Subgraph) của dữ liệu RDF khi những thuật ngữ RDF từ đồ thị con đó có thể được thay thế cho các biến trong mẫu đồ thị (graph patterns) và kết quả là đồ thị RDF tương dương với đồ thị con. . Ví dụ dưới đây cho thấy một truy vấn SPARQL dựa trên dữ liệu đồ thị được hiển thị ở trên và các truy vấn tri thức con người bởi một người. Truy vấn bao gồm hai phần: mệnh đề SELECT xác định các biến sẽ xuất hiện trong kết quả truy vấn và mệnh đề WHERE cung cấp mẫu biểu đồ để khớp với biểu đồ dữ liệu. Mẫu đồ thị trong ví dụ này bao gồm một bộ ba duy nhất với một biến duy nhất (? Người) ở vị trí đối tượng. . SELECT ?person . WHERE . &lt;http://example.org/art&gt; &lt;http://xmlns.com/foaf/0.1/knows&gt; ?person . Câu truy vấn trả về tập kết quả trên dữ liệu đồ thị của chúng ta .   . ?person1 | . &lt;http://example.org/bob&gt; | . &lt;http://example.org/bea&gt; | . Mẫu đồ thị (Graph Pattern) có thể chứa nhiều bộ ba. Lấy ví dụ như câu truy vấn sau, chúng ta hỏi những bạn của bạn của art (art’s friends of friends) . SELECT ?person ?person1 . WHERE . &lt;http://example.org/art&gt; &lt;http://xmlns.com/foaf/0.1/knows&gt; ?person . ?person &lt;http://xmlns.com/foaf/0.1/knows&gt; ?person1 . Câu truy vấn trả về tập kết quả trên dữ liệu đồ thị của chúng ta .     . ?person1 | ?person2 | . &lt;http://example.org/bob&gt; | &lt;http://example.org/cal&gt; | . &lt;http://example.org/bob&gt; | &lt;http://example.org/cam&gt; | . &lt;http://example.org/bea&gt; | &lt;http://example.org/coe&gt; | . &lt;http://example.org/bea&gt; | &lt;http://example.org/cory&gt; | . Mỗi lời giải đưa ra một cách trong đó các biến đã chọn có thể được liên kết với các thuật ngữ RDF để mẫu truy vấn khớp với dữ liệu. Tập hợp kết quả đưa ra tất cả các lời giải khả thi. Trong ví dụ trên, hai tập hợp con dữ liệu khác nhau cung cấp các kết quả phù hợp dẫn đến các câu trả lời. Các ví dụ trên minh họa khớp mẫu đồ thị cơ bản; tất cả các biến được sử dụng trong mẫu truy vấn phải được ràng buộc trong mọi lời giải. . Truy vấn SPARQL có thể trả về những node trống (Blank Nodes) trong kết quả. Định danh cho những node trống (Blank Nodes) được dùng trong kết quả có thể không giống như định danh sử dụng trong đồ thị RDF gốc. Lớp WHERE trong một truy vấn SPARQL cung cấp một cách khớp dựa trên những kiểu tầm thường và để lọc những kết quả dựa trên những ràng buộc số học. . Các câu truy vấn SPARQL có rất nhiều dạng. Dạng mệnh đề SELECT mà chúng ta xem xét đến bây giờ trả về những biến ràng buộc. Dạng mệnh đề CONSTRUCT có thể được dùng trong khởi tạo những kết quả mà định nghĩa một đồ thị RDF (RDF Graph). Những câu truy vấn cũng có thể chỉ định nhiều hơn một mẫu đồ thị (graph pattern) mà tất cả chúng hoặc một vài trong chúng phải khớp với dữ liệu RDF. Những kết quả truy vấn cũng có thể được xử lý thêm bằng cách cung cấp một cách trực tiếp các lệnh để sắp xếp chúng, loại bỏ trùng lặp kết quả, hoặc giới hạn số lượng các kết quả được trả về. . 3. Property Graphs - Đồ thị thuộc tính . Mô hình dữ liệu thuộc tính được sử dụng bởi nhiều hệ thống cơ sở dữ liệu đồ thị. Không giống như RDF được thúc đẩy bởi nhu cầu mô hình hoá thông tin dữ liệu trên web, hệ thống sơ cở dữ liệu xử lý dữ liệu đồ thị tổng quát. Những hệ thống cơ sở dữ liệu đồ thị (Graph Database Systems) tách biệt bản thân chúng với cơ sở dữ liệu quan hệ truyền thống (Traditional Relational Databases) với sự phụ rất ít vào một lược đồ được định nghĩa từ trước, và tối ưu sự vận hành nhờ vào duyệt đồ thị (Graph Traversals). Trong mục này, chúng ta sẽ xem xét mô hình dữ liệu đồ thị thuộc tính và ngôn ngữ Cypher được dùng để truy vấn nó. . 3.1 Mô hình dữ liệu đồ thị thuộc tính (Property Graph Data Model) . Một mô hình dữ liệu đồ thị thuộc tính (Property Graph Data Model) bao gồm các nút (node), những mối quan hệ (relationships) và những thuộc tính (properties). Mỗi một nút có một nhãn và một tập các thuộc tính dưới dạng bất kỳ những cặp key-value. Các key là những chuỗi (string) và các value là kiểu dữ liệu bất kỳ. Một quan hệ là một cạnh liên kết có hướng giữa hai node (nút), có một nhãn và có thể có một tập các thuộc tính. . Trong đồ thị thuộc tính sau đây art và bea là hai node. Node cho bea có hai thuộc tính: age và based_near. Hai nút (node) được nối bằng một cạnh liên kết với nhãn là knows. Cạnh liên kết này có thuộc tính since chỉ năm mà art và bea quen biết nhau . . Trong lúc định nghĩa một thuộc mô hình dữ liệu đồ thị thuộc tính, chúng ta phải quyết định những nút (nodes), những cạnh liên kết (edges) và những thuộc tính (properties). Ví dụ như chúng ta có thể hỏi tại sao không biểu diễn một thành phố như một nút, và khởi tạo một nhãn based_near giữa một người (a person) và một thành phố (a city) thay vì tạo ra một thuộc tính của một nút biểu diễn một người. Một cách tổng quát, bất kỳ giá trị nào có liên hệ với nhiều nút (nodes) khác trong một đồ thị sao cho có yêu cầu ứng dụng để duyệt trên các mối quan quan hệ đó một cách hiệu quả, hoặc chúng cần liên kết các thuộc tính bổ sung với cách nó liên hệ với những nút khác, bản thân nó nên được biểu diẽn như một nút. . . 3.2 Cypher Query Language . Cypher là một ngôn ngữ dùng trong truy vấn dữ liệu được biểu diễn trong một mô hình dữ liệu đồ thị thuộc tính. Những khái niệm thiết kế từ Cypher đang được xem xét để trở thành một chuẩn ISO cho một ngôn ngữ truy vấn đồ thị. Ngoài việc truy vấn, Cypher cũng có thể được sử dụng để khởi tạo (create), cập nhật (update) và loại bỏ (delete) dữ liệu từ một cơ sở dữ liệu đồ thị. Trong phần này, chúng ta sẽ điểm qua một vài khả năng truy vấn của Cypher . Ví dụ sau đây về truy vấn Cypher dựa trên dữ liệu đồ thị được đề cập từ đầu và những truy vấn cho những người được quen biết bởi art. Câu truy vấn gồm hai phần: mệnh đề MATCH chỉ định một mẫu đồ thị (graph patterns) mà nên khớp dựa trên dữ liệu đồ thị và mệnh đề RETURN chỉ định câu truy vấn nên trả về cái gì. Mẫu đồ thị (graph pattern) được chỉ định trong định nghĩa ASCII cho đồ thị: Mỗi một nút được viết trong dấu ngoặc đơn (parentheses) và mỗi một cạnh liên kết được viết bởi một dấu mũi tên (arrow). Cả thông số nút (node) và quan hệ (relation) đều bao gồm các kiểu tương ứng của chúng và bất kỳ thuộc tính bổ sung nào cần được đối sánh. . MATCH (p1:Person {name: art}) -[:knows]-&gt; (p2: Person) . RETURN p2 . Ví dụ dưới đây, chúng ta thấy cách mà Cypher truy vấn với câu hỏi cho tất cả những người bạn của một người biết nhau từ năm 2010 . MATCH (p1:Person {name:art}) -[:knows {since: 2010}]-&gt; (p2: Person) . RETURN p2 . Từ câu truy vấn ở trên, chúng ta có thể thấy việc liên kết các thuộc tính với những quan hệ cũng dễ dàng như liên kết chúng với các nút. Một người có thể có nhiều người bạn từ những năm trước 2010, và nếu chúng ta muốn truy vấn bao gồm những người bạn đó, chúng ta có thể thêm một mệnh đề WHERE . MATCH (p1:Person {name:art}) -[:knows {since: Y}]-&gt; (p2: Person) . WHERE Y &lt;= 2010 . RETURN p2 . Thông qua mệnh đề WHERE, có thể chỉ định nhiều ràng buộc bộ lọc giống như các mẫu có thể sử dụng để giới hạn các kết quả truy vấn. Hơn nữa,Cypher cung cấp cấu trúc ngôn ngữ cho việc đếm các kết quả (counting results), gom nhóm dữ liệu bởi những giá trị (grouping data by values), tìm giá trị cực đại/ cực tiểu (minimum/ maximum values) và một số toán tử toán học khác. . 4. Comparison of Data Models - So sánh các mô hình dữ liệu . Trong mục này, chúng ta sẽ bắt đầu so sánh RDF và mô hình dữ liệu đồ thị thuộc tính. Chúng ta cũng sẽ so sánh cả hai thứ này với mô hình dữ liệu quan hệ. . 4.1 Comparison of RDF and Property Graph Data Models . Ngoài các đặc trưng của RDF được đề cập trong những mục trước, nó có nhiều tầng (layers) bổ sung, ví dụ như lược đồ RDF, Web Ontology Language (OWL),… Trong phần này, chúng ta không cần phải đề cập đến những đặc trưng cao cấp này. . Những điểm chính khác biệt giữa mô hình RDF cơ bản và mô hình dữ liệu đồ thị thuộc tính (Property Graph Model) . - Mô hình dữ liệu đồ thị thuộc tính (Property Graph Model) cho phép những cạnh liên kết có những thuộc tính . - Mô hình dữ liệu đồ thị thuộc tính (Property Graph Model) không yêu cầu IRIs và không hỗ trợ những node trống (blank node). . Để hỗ trợ thuộc tính cạnh, mô hình RDF hỗ trợ một mở rộng (extension) gọi là reification. Chúng ta sẽ đề cập phần mở rộng (extension) này và sau đó mô tả các cách khác nhau mà dữ liệu được biểu diễn trong mô hình dữ liệu này có thể được chuyển đổi (convert) sang một dạng khác. . Để hiểu sự tái tổ chức - reification trong RDF, xem xét một tình huống mà chúng ta cần biểu diễn nguồn gốc của một bộ ba sau đây. Bộ ba này xác nhận trọng lượng của một mặt hàng. Chữ “2,4” ^^ xsd: decimal biểu thị số 2,4 thuộc kiểu xsd: decimal. Chúng ta quan tâm đến người chỉ định thức hiện phép đo này . exproducts:item10245 exterms:weight “2.4”^^xsd:decimal . Chúng ta có thể liên kết những thông tin xuất xứ với bộ ba phía trên bằng cách dùng từ vựng RDF reification. Từ vựng RDF reification bao gồm kiểu rdf:Statement, thuộc tính rdf:subject, rdf:predicate và rdf:object. Bẳng cách bộ từ vựng reification, một tái tổ chức của một mệnh đề về trọng lượng của một mặt hàng nên được cho bởi phép gán mệnh đề IRI giống như exproducts:triple12345 (vì vậy các câu lệnh có thể được viết mô tả nó), và sau đó mô tả mệnh đề như bên dưới đây. Bộ ba cuối cùng trong danh sách chỉ định thông tin xuất xứ mong muốn bằng cách xác nhận số nhận dạng cho người đã tạo bộ ba ban đầu. .   . exproducts:triple12345 rdf:type rdf:Statement . | . exproducts:triple12345 rdf:subject exproducts:item10245 . | . exproducts:triple12345 rdf:predicate exterms:weight . | . exproducts:triple12345 rdf:object “2.4”^^xsd:decimal . | . exproducts:triple12345 dc:creator exstaff:85740 . | . Những mệnh đề này nói rằng tài nguyên được định danh bởi IRI exproducts:triple12345 là một mệnh đề RDF, mà chủ thể của mệnh đề tham chiếu đến tài nguyên được định danh bởi exterms:weight và đối tượng của mệnh đề tham chiều tới giá trị thập phân được định danh bởi kiểu của chữ “2.4” ^^xsd:decimal. Cuối cùng mệnh đề xác nhận rằng exproducts:triple12345 được cung cấp bởi người với IRI là exstaff:8574 . Với từ vựng tái tổ chức, nó có thể dịch một cách máy móc dữ liệu trong mô hình đồ thị thuộc tính sang RDF. Mỗi node và giá trị thuộc tính của nó trong dữ liệu đồ thị thuộc tính trở thành một bộ ba. Mỗi cạnh liên kết trong dữ liệu đồ thị thuộc tính cũng trở thành một bộ ba RDF. Mọi cạnh liên kết trong dữ liệu đồ thị thuộc tính có thuộc tính được tái tổ chức, và những thuộc tính của cạnh liên kết trở thành bộ ba của cạnh được tái tổ chức bằng cách sử dụng từ vựng tái tổ chức như giải thích bên trên :v . Để dịch dữ liệu được biểu diễn trong mô hình RDF sang mô hình đồ thị thuộc tính, cách tiếp cận dễ dàng nhất là ánh xạ mỗi node và mỗi cạnh tương ứng với node và một cạnh trong đồ thị thuộc tính. Một tái tổ chức khả thi là chúng ta chỉ tạo các nút thuộc tính mới cho những nút là IRI hoặc nút trống. Với bất kỳ một bộ ba nào trong RDF mà mục tiêu là chữ (literal), chúng ta tạo cho chúng một thuộc tính của node trong dữ liệu đồ thị thuộc tính. . Ngoài ra để chuyển đổi dữ liệu giữa các mô hình RDF và đồ thị thuộc tính, chúng ta cũng quan tâm đến chuyển đổi hình thức cú pháp của dữ liệu và các câu truy vấn. Với mô hình dữ đồ thị thuộc tính, không có một chuẩn cú pháp cho những biểu thức, do vậy một trình dịch tùy chỉnh cần được viết cho định dạng mà người đó đang làm việc với. Một lần dịch lược đồ là cố định giữa hai mô hình, nên dịch giữa SPARQL và Cypher cũng đơn giản. . 4.2 Comparison of Graph Models and Relational Data Model - So sánh mô hình đồ thị và mô hình dữ liệu quan hệ . Chúng ta có thể định nghĩa một phép dịch và và từ dữ liệu được thể hiện bằng cách sử dụng mô hình dữ liệu quan hệ sang dữ liệu được thể hiện bằng cách sử dụng mô hình RDF và mô hình đồ thị thuộc tính. Một số ý kiến rằng các mô hình đồ thị thì dễ dàng hiểu hơn đối với con người và các ngôn ngữ truy vấn đồ thị thì gọn hơn với những những truy vấn xác định. Về nguyên tắc, chúng ta có thể cài đặt một một giao diện người dùng để trực quan hoá lược đồ quan hệ, và cài đặt trình biên dịch truy vấn mà có thể ánh xạ câu truy vấn được viết bằng ngôn ngữ truy vấn đồ thị thành một dạng tương đương mà có thể thực hiện trên những bảng quan hệ. Nếu một ứng dụng yêu cầu điều hướng mối quan hệ, một cơ sở dữ liệu đồ thị có những cạnh liên kết có lợi thế vì nó tối ưu được trong việc duyệt đồ thị. Cho phần còn lại của mục này, chúng ta xem xét một ví dụ cụ thể xem cách mà những câu truy vấn đồ thị nhỏ gọn hơn so với những câu truy vấn quan hệ tương ứng, và kết luận bằng cách đề cặp một số hệ thông quan hệ cố gắng hỗ trợ xử lý đồ thị . Để hiểu sự tương phản giữa truy vấn đồ thị và truy vấn quan hệ, chúng ta xem xét một ví dụ đơn giản trong đó chúng ta có 3 bảng: một bảng Employee, một bảng Department và một bảng kết Employee_Department. Một nhân viên (employee) có thể được liên kết với nhiều phòng ban (Department) vì chúng được lưu trữ trong các bảng riêng biệt. Hai bảng liên hệ bằng một bảng kết gồm các khoá ngoại employee id và department id. . . Giả định rằng chúng ta muốn xuất ra danh sách những nhân viên thuộc phòng ban IT (có thể có thể nói là vua của các phòng ban :)) Câu truy vấn SQL thực hiện nhiệm vụ này đầu tiên cần kết bảng employee và bảng department và sau đó lọc ra những kết quả trên tên của phòng ban (department) .   . SELECT name FROM Employee | . LEFT JOIN Employee_Department | . ON Employee.Id = Employee_Department.EmployeeId | . LEFT JOIN Department | . ON Department.Id = Employee_Department.DepartmentId | . WHERE Department.name = “IT” | . Nếu chúng ta muốn biểu diễn thông tin tương tự bằng cách sử dụng một mô hình dữ liệu đồ thị, chúng ta sẽ cần một node cho department và employee. Employee ssn và department name sẽ là những thuộc tính của node. Bảng Employee_Department sẽ được nắm bắt bằng một mối quan hệ trong biểu diễn đồ thị thuộc tính. Nếu bảng bảng Employee_Department có những thuộc tính bổ sung, chúng sẽ được biểu diễn như thuộc tính cạnh liên kết trong mô hình dữ liệu đồ thị. Một mẫu node với một thuộc tính đồ thị như sau: . . Chúng ta có thể truy vấn dữ liệu bằng cách sử dụng câu truy vấn Cypher sau đây .   . MATCH (p:Employee) -[:works_in]-&gt; (d:Department) | . WHERE d = “IT” | . RETURN p | . Truy vấn Cypher ở trên nhỏ gọn hơn nhiều so với truy vấn SQL của nó. Sự nhỏ gọn này bắt nguồn từ thực tế là các phép nối được nắm bắt một cách tự nhiên bằng cách sử dụng các mẫu đồ thị (graph patterns). . Gần đây, có nhiều hệ thống biểu diễn dữ liệu quan hệ theo cách không có lược đồ bằng cách biểu diễn mỗi thuộc tính nút dưới dạng bộ ba trong một bảng và mỗi thuộc tính cạnh dưới dạng bốn bộ trong bảng thứ hai. Những hệ thống như vậy, cung cấp một bộ lập kế hoạch truy vấn cho phép truy vấn bằng một ngôn ngữ giống Cypher mà có thể tính toán hiệu quản qua hai bảng quan hệ. Những hệ thống như thế có khả năng tận dụng công nghệ quan hệ hiện có và cũng có thể thực hiện tối ưu hóa khi một số dữ liệu kế thừa nằm trong bảng quan hệ truyền thống. . 5. Limitations of a Graph Data Model - Giới hạn của một mô hình dữ liệu đồ thị . Một mô hình dữ liệu đồ thị không hẳn là một lựa chọn thích hợp nhất khi ứng dụng bao gồm chủ yếu là dữ liệu số, và chỉ dựa vào mối quan hệ nhị phân. Ví dụ như, mô hình quan hệ thì hiệu quả hơn trong việc nắm bắt những dữ liệu chuỗi thời gian (time series data) giống như sự phát triển dân số của một quốc gia. Mặc dù chúng ta có thể biểu diễn những dữ liệu như thế bằng cách sử dụng một đồ thị, nhưng kết quả trong một số lượng lớp bộ ba mà không nhất thiết mang lại cho chúng ta lợi thế về sự hiểu biết khái niệm tốt hơn và / hoặc hiệu suất truy vấn nhanh hơn thông qua duyệt đồ thị . Có rất nhiều mối quan hệ không thể được biểu diễn một cách tự nhiên bằng mối quan hệ nhị phân. Ví du như, mối quan hệ của đối tượng A là giữa đối tượng B và C tức là một mối quan hệ ba ngôi. Một quan hệ ba ngôi có thể được biến đổi thành một tập hợp các quan hệ nhị phân bằng cách sử dụng kỹ thuật tái tổ chức (reification technique), nhưng mà làm như thế, chúng ta sẽ đánh mất đi lợi thế của việc hiểu khái niệm (better conceptual understanding) mà chúng ta nhận được từ mô hình dữ liệu đồ thị. Đồ thị cũng không phải là một biểu diễn tự nhiên nhất cho các phương toán học và phản ứng hoá học, khi tồn tại các biểu diễn cụ thể theo miền dễ hiểu . Bài tập: . …Sẽ cập nhật sau… . Bài giảng gốc: https://web.stanford.edu/class/cs520/2020/notes/What_Are_Graph_Data_Models.html .",
            "url": "https://nhutnamhcmus.github.io/lenux-notebooks/2021/06/26/what-are-some-knowledge-graph-data-models.html",
            "relUrl": "/2021/06/26/what-are-some-knowledge-graph-data-models.html",
            "date": " • Jun 26, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "How To Create A Knowledge Graph From Data",
            "content": "ĐỒ THỊ TRI THỨC - KNOWLEDGE GRAPH | Đây là bản dịch từ Course CS520: Knowledge Graphs | Data Models, Knowledge Acquisition, Inference and Applications | . Department of Computer Science, Stanford University, Spring 2021 . Knowledge graphs have emerged as a compelling abstraction for organizing world’s structured knowledge over the internet, capturing relationships among key entities of interest to enterprises, and a way to integrate information extracted from multiple data sources. Knowledge graphs have also started to play a central role in machine learning and natural language processing as a method to incorporate world knowledge, as a target knowledge representation for extracted knowledge, and for explaining what is being learned. This class is a graduate level research seminar and will include lectures on knowledge graph topics (e.g., data models, creation, inference, access) and invited lectures from prominent researchers and industry practitioners. The seminar emphasizes synthesis of AI, database systems and HCI in creating integrated intelligent systems centered around knowledge graphs. . Mục đích: Là tìm hiểu cũng như trau dồi kiến thức chuyên môn trong lĩnh vực Knowledge Graph cũng như từ vựng tiếng Anh. Không vì mục đích kinh doanh hay bất cứ mục đích về lợi nhuận, tất cả là vì mục đích chia sẻ kiến thức và học tập. . Mọi thông tin về những chủ đề được note lại có thể tìm thấy ở đây: . https://web.stanford.edu/class/cs520/2020/notes/Table_Of_Contents.html . Video của các buổi seminar trên địa chỉ Youtube: . https://www.youtube.com/playlist?list=PLDhh0lALedc5paY4N3NRZ3j_ui9foL7Qc . Mọi vấn đề về dịch thuật, thuật ngữ xin để lại comment hoặc gửi về địa chỉ email: lenam.fithcmus@gmail.com với tiêu đề . [ISSUES OF KG TRANSLATION] . HOW TO CREATE A KNOWLEDGE GRAPH FROM DATA . LÀM THẾ NÀO ĐỂ KHỞI TẠO MỘT ĐỒ THỊ TRI THỨC TỪ DỮ LIỆU . 1. Giới thiệu . Những tổ chức lớn tạo ra lượng lớn dữ liệu nội bộ và cũng tiêu thụ dữ liệu được tạo ra bởi các nhà cung cấp bên thứ ba (third party providers). Nhiều nhà cung cấp dữ liệu có được dữ liệu bằng cách xử lý nhưng nguồn phi cấu trúc, và đầu tư một nổ lực đáng kể trong việc cung cấp nó trong một dạng có cấu trúc cho việc sử dụng của người dùng. Để sử dụng hiệu quả những dữ liệu bên ngoài, nó phải liên quan tới dữ liệu bên trong công ty, Như tích hợp dữ liệu cho phép nhiều trường hợp sử dụng phổ biến như 360 view of a customer - góc nhìn 360 độ của khách hàng, fraud detection - phát hiện gian lận, risk assessment - đánh giá rủi ro, loan approval - phê duyệt khoản vay, .. Với chương này, chúng ta sẽ thảo luận vấn đề khởi tạo một đồ thị tri thức bằng cách tích hợp dữ liệu có sẵn từ những nguồn có cấu trúc. Chúng ta sẽ xem xét vấn đề của việc rút trích dữ liệu từ những nguồn dữ liệu phi cấu trúc trong chương tiếp theo :v . Khi kết hợp dữ liệu từ nhiều nguồn vào một đồ thị tri thức, chúng ta có thể thực hiện một số thiết kế sơ đồ như chúng ta đã thảo luận trong chương trước :v Chúng ta cũng bắt đầu mà không cần lược đồ vì việc tải dữ liệu bên ngoài thẳng vào như bộ ba vào một đồ thị tri thức rất dễ dàng. Thông thường, thiết kế ban đầu của lược đồ dựa trên trường hợp cụ thể mà người ta muốn giải quyết. Ở mức độ tồn tại ban đầu của lược đồ như thế, chúng ta phải quyết định các thành phần dữ liệu từ một nguồn dữ liệu mới nên được thêm vào đồ thị tri thức như thế nào. Điều này thường được biết đến là vấn đề schema mapping - vấn đề ánh xạ lược đồ. Hơn nữa, để liên hệ lược đồ của hai nguồn, chúng ta cũng phải giải quyết khả năng mà một thực thể trong dữ liệu đến (ví dụ như một Company) có thể đã tồn tại trong đồ thị tri thức của chúng ta. Vấn đề suy luận nếu hai thực thể trong dữ liệu có thể cùng là một thực thể trong thế giới thực được gọi là vấn đề record linkage - mẫu ghi liên kết. Vấn đề mẫu ghi liên kết cũng xuất hiện khi các nhà cung cấp dữ liệu bên thứ ba gửi những nguồn cấp dữ liệu mới (a new data feeds), và đồ thị tri thức của chúng ta phải được cập nhật (up-to-daye) với những nguồn dữ liệu mới này. . Trong chương này, chúng ta sẽ cùng thảo luận những tiếp cận hiện tại cho giải quyết vấn đề ánh xạ lược đồ và vấn đề mẫu ghi liên kết. Chúng ta sẽ nêu những thuật toán state-of-the-art và thảo luận về mức độ hiệu qủa của chúng trong những vấn đề của ngành :v . 2. Ánh xạ lược đồ - Schema Mapping . Ánh xạ lược đồ giả định rằng tồn tại một lược đồ mà sẽ được sử dụng cho viêc lưu trữ dữ liệu mới đến từ một nguồn khác. Ánh xạ lược đồ sau đó xác định những quan hệ và thuộc tính nào trong cơ sở dữ liệu đầu vào tương ứng với những thuộc tính và quan hệ trong đồ thị tri thức. Tồn tại những kỹ thuật cho bootstrapping schema mappings. Bootstrapped schema mappings có thể được điều chỉnh thông qua sự can thiệp của con người. . Chúng ta sẽ bắt đầu thảo luận về ánh xạ lược đồ bằng cách nêu ra một số thách thức và nhận định liệu chúng ta có nên chuẩn bị cho việc phần lớn quá trình này có thể thực hiện thủ công và tốn nhiều công sức. Sau đó, chúng ta mô tả một tiếp cận cho việc chỉ định ánh xạ giữa lược đồ nguồn đầu vào và lược đồ của đồ thị tri thức. Chúng ta sẽ kết thúc mục này bằng đề cập một vài kỹ thuật có thể được sử dụng cho bootstrap schema mapping. . 2.1 Những thách thức với Ánh xạ lược đồ - Schema Mapping . Những thách thức chính trong tự động ánh xạ lược đồ . - (1) Khó để hiểu lược đồ . - (2) Độ phức tạp của việc ánh xạ . - (3) Ít dữ liệu huấn luyện có sẵn . Chúng ta sẽ thảo luận chi tiết hơn những thách thức này . Lược đồ cơ sở dữ liệu quan hệ thương mại (Commercial relational database schemas) có thể rất lớn bao gồm hàng ngàn quan hệ và hàng vạn thuộc tính. Thỉnh thoảng, tên của những quan hệ và thuộc tính không có ngữ nghĩa (ví dụ, segment1, segment2 @@ ) mà không liên quan gì bản thân chúng với bất kỳ dự đoán tự động thực tế nào của ánh xạ. . Ánh xạ giữa lược đồ đầu vào và lược đồ trong đồ thị tri thức không phải lúc nào cũng đơn giản là ánh xạ 1-1 (one-to-one mapping). Ánh xạ có thể liên quan tới những tính toán, áp dụng logic kinh doanh và có những luật đặc biệt cho việc xử lý tình huống như là missing values. Nó trở thành một sự kỳ vọng quá cao đối với bất kỳ quá trình xử lý tự động nào suy diễn những phép ánh xạ phức tạp như vậy. . Cuối cùng, nhiều giải pháp ánh xạ tự động dựa trên các kỹ thuật Máy học (Machine Learning techniques) yêu cầu một lượng lớn dữ liệu huấn luyện để hoạt động một cách hiệu quả. Như lược đồ thông tin, bằng định nghĩa, nhỏ hơn nhiều dữ liệu bản thân nó, rất là viễn vong để kỳ vọng rằng chúng sẽ có một lượng lớn ánh xạ lược đồ sẵn có để một thuật toán ánh xạ có thể được huấn luyện. . 2.2 Xác định Ánh xạ lược đồ - Specifying Schema Mapping . Trong phần này, chúng ta sẽ đề cập một phương pháp tiếp cận khả thi để xác định ánh xạ giữa nguồn dữ liệu đầu vào và một mục tiêu trong lược đồ đồ thị tri thức. Chúng ta sẽ lấy một ví dụ trong lĩnh vực dụng cụ nấu ăn. Chúng ta có thể tưởng tượng những nhà cung cấp khác nhau cung cấp các mặt hàng trên một trang thương mại điện tử (E-commerce site) có mong muốn tổng hợp và quảng bá đến khách hàng của họ. Chúng ta sẽ xem xét hai nguồn ví dụ và sau đó thêm vào lược đồ đồ thị tri thức để mà chúng ta sẽ định nghĩa các ánh xạ. . Chúng ta hiển thị một vài mãu dữ liệu từ nguồn dữ liệu đầu tiên trong một bảng quan hệ gọi là cookware. Nó có bốn thuộc tính: name, type, material, và price . . Cơ sở dữ liệu thứ hai được hiển thị bên dưới cho thấy danh sách những sản phẩn của một nhà sản suất. Trong trường hợp này, có nhiều bảng, một bảng ứng với một thuộc tính sản phẩm. Bảng kind xác định loại của mỗi sản phẩm. Bảng base xác định mỗi sản phẩm được làm từ kim loại ăn mòn -corrosible metal (nhôm - aluminum hoặc không gỉ - stainless), kim loại không ăn mòn - noncorrosible metal (sắt - iron hoặc thép - steel) hay thứ gì đó không phải kim loại (thủy tinh hoặc gốm - ceramic). Bảng coated xác định những sản phẩm này có phủ chống dính hay không (nonstick coatings). Bảng price cho thông tin về giá bán. Không có thông về vật liệu. Công ty được chọn không cung cấp thông tìn về kim loại được sử dụng trong mỗi sản phải. Lưu ý rằng, bản coated chỉ có những giá trị dương; những sản phẩm mà không có lớp phủ chống dính không được đề cặp đến. . . Giả sử rằng lược đồ mong muốn cho đồ thị tri thức được biểu diễn như một đồ thị thuộc tính được cho ở bên dưới đây. Chúng ta có hai loại nút khác nhau: một cho sản phẩm - Product, và cái kia cho các nhà cung cấp – Supplier. Hai nút này liên kết với nhau bởi một mối quan hệ gọi là has_supplier. Mỗi nút sản phẩm có những thuộc tính là “type” và “price” . . Để xác định lược đồ ánh xạ và để xử lý cụ thể, chúng ta sẽ sử dụng định nghĩa một bộ ba để mà một xử lý tương tự có thể áp dụng bất kể chúng ta sử dụng mô hình dữ liệu đồ thị thuộc tính hay mô hình RDF cho đồ thị tri thức. Với một đồ thị tri thức RDF, chúng sẽ cần phải khởi tạo IRI, tức một quá trình trực giao để liên hệ hai lược đồ, và ở đây chúng ta bỏ qua điều này. Những bộ ba mong muốn trong mục tiêu đồ thị tri thức được liệt kê bằng bảng dưới đây. . Bất kỳ ngôn ngữ lập trình nào có thể dược sử dụng để biểu diễn ánh xạ. Ở đây, chúng ta chọn sử dụng Datalog để biểu diễn ánh xạ. Các luật dưới đây rất đơn giản. Các biến được biểu thị bằng cách sử dụng các chữ cái in hoa. Luật thứ ba thêm ràng buộc vender_1 để chỉ ra nguồn dữ liệu. . knowledge_graph(ID,type,Type) :- cookware(ID,TYPE,MATERIAL,PRICE) knowledge_graph(ID,price,PRICE) :- cookware(ID,TYPE,MATERIAL,PRICE) knowledge_graph(ID,has_supplier,vendor_1) :- cookware(ID,TYPE,MATERIAL,PRICE) . Kế đến, chúng ta xem xét những luật cho việc ánh xạ nguồn dữ liệu thứ hai. Những luật cũng khá là tương tự như những luật ánh xạ cho nguồn dữ liệu thứ nhất ngoài trừ là thông tin bây giờ thì đến từ hai bảng khác nhau trong nguồn dữ liệu . knowledge_graph(ID,type,Type) :- kind(ID,TYPE) . knowledge_graph(ID,price,PRICE) :- price(ID,PRICE) . knowledge_graph(ID,has_supplier,vendor_2) :- kind(ID,TYPE) . Tổng quát mà nói, nó không hợp lý khi sử dụng lại các bộ định danh từ cơ sở dữ liệu nguồn, và chúng ta mong muốn là tạo ra những bộ định danh mới cho việc sử dụng trong đồ thị tri thức. Trong một số trường hợp, đồ thị tri thức có thể đã chứa những đối tượng tương đương với chúng trong dữ liệu được nhập. Chúng ta sẽ xem xét vấn đề này trong phần mẫu ghi liên kết - record linkage . 2.3 Bootstrapping Schema Mapping . Như được đề cập ở phần 2.1, một tiếp cận hoàn toàn tự động để ánh xạ lược đồ đối mặt với rất nhiều khó khăn trong thực tế. Ở đây đề cập một công trình về bootrapping the schema mappings dựa trên nhiều kỹ thuật và xác nhận chúng bằng đầu vào con người. Những kỹ thuật Boostrapping cho ánh xạ lược đồ có thể được phân loại thành những loại sau đây: . - (1) Linguistic matching - Kết hợp ngôn ngữ học . - (2) Matching based on instances - Kết hợp dựa trên thể hiện . - (3) Matching based on constraints - Kết hợp dựa trên ràng buộc . Những kỹ thuật ngôn ngữ học có thể được sử dụng trên tên của một thuộc tính hoặc trên những văn bản mô tả của một thuộc tính. Các tiếp cận đầu tiên và cũng rõ ràng nhất là kiểm tra tên của hai thuộc tính là bằng nhau hay không. Chúng ta có thể có một độ tin cậy cao trong so sánh bằng nếu những tên là IRIs. Thứ hai, chúng ta có thể chuẩn hoá tên bằng cách xử lý chúng thông qua một số kỹ thuật như stemming và kiểu tra tính bằng nhau. Lấy ví dụ, thông qua xử lý, chúng ta có thể kết luận ánh xạ của CName đến Customer Name. Thứ ba, chúng ta có thể kiểm tra ánh xạ dựa trên từ đồng nghĩa - synonyms (ví dụ như là: car và automobile) hoặc từ siêu nghĩa - hypernyms (ví dụ như là book và publication). Thứ tư, chúng ta có thể kiểm tra ánh xạ dựa trên những chuỗi con chung, phát âm chung, và cách mà những từ đó được phát âm. Và cuối cùng, chúng ta có thể kết hợp những mô tả của những thuộc tính thông qua những kỹ thuật ngữ nghĩa tương đồng (semantic similarity techniques). Ví dụ, một cách tiếp cận để rút trích những từ khoá từ phần mô tả và sau đó kiểm tra độ tương đồng giữa chúng bằng cách sử dụng những kỹ thuật mà chúng ta đã nếu ra. . Trong kết hợp dựa trên những thể hiện, người ta kiểm tra loại dữ liệu có tồn tại. Ví dụ, nếu một giá trị thuộc tính cụ thể mang kiểu dữ liệu ngày tháng, nó chỉ có thể kết hợp dựa trên những thuộc tính mang những giá trị ngày tháng. Nhiều kiểu dữ liệu chuẩn hoá có thể được suy diễn bằng cách kiểu tra dữ liệu . Trong một số trường hợp, lược đồ cung cấp thông tin về những ràng buộc. Ví dụ, nếu một lược đồ xác định một thuộc tính cụ thể là đơn nhất đối với một cá thể, và phải là số, nó là một đối sánh tiềm năng hoặc các thuộc tính xác minh như số nhân viên hoặc số an sinh xã hội. . Những kỹ thuật được đề cặp ở đây là không chính xác và do đó có thể chỉ sử dụng để boostrap quá trình trình ánh xạ lược đồ. Bất kỳ ánh xạ nào cũng phải được xác minh và xác nhận bởi những người chuyên gia. . 3. Ghi liên kết - Record Linkage . Chúng ta sẽ bắt đầu thảo luận về vấn đề mẫu ghi liên kết bằng một ví dụ cụ thể. Sau đó, chúng ta sẽ đưa ra một cái nhìn tổng quan về một phương pháp tiếp cận điển hình để giải quyết vấn đề này. . 3.1 Vấn đề mẫu ghi liên kết - A Sample Record Linkage Problem . Giả sử rằng chúng ta có dữ liệu với hai bảng. Vấn đề mẫu ghi liên kết liên quan tới việc dự đoán mẫu ghi $a_1$ giống với mẫu ghi $b_1$ và mẫu ghi $a_3$ giống với mẫu ghi $b_2$. Giống như việc ánh xạ lược đồ, đây là những dự đoán không chính xác và cần phải được xác nhận bởi con người. . . Một đồ thị tri thức lớn có thể chứa lượng thông tin trên 10 triệu công ty. Nó có thể nhận một nguồn cung cấp dữ liệu, mà được rút trích từ văn bản ngôn ngữ tự nhiên. Những nguồn cung cấp dữ liệu như thế có thể chứa hơn 100,000 công tin. Cho dù nếu một đồ thị tri thức có một phương thức chuẩn hoá để tham chiếu đến những công tin, nhưng nguồn dữ liệu mới được rút trích từ văn bản sẽ không có những bộ định danh chuẩn hoá. Tác vụ mẫu ghi liên kết là liên hệ những công ty mà chứa những nguồn cung cấp mới với những công ty đã tồn tại trong đồ thị tri thức. Vì các khối dữ liệu rất lớn, thực hiện tác vụ này một cách hiểu quả là điều tối quan trọng. . 3.2 Phương pháp tiếp cận giải quyết vấn đề mẫu ghi liên kết . Độ hiệu quả của mẫu ghi liên kết (record linkage) liên quan tới hai bước: blocking và matching. Bước blocking liên quan tới một tính toán nhanh để chọn ra một tập con những mẫu ghi từ nguồn và mục tiêu mà sẽ được xem trong suốt một bước đối sánh chính xác và tốn kém hơn. Trong bước matching, chúng tôi đối sánh theo từng cặp với tập hợp con các bản ghi đã được chọn trong quá trình blocking. Trong ví dụ được đề cập ở trên, chúng ta có thể sử dụng một chiến lược blocking xem xét đối sánh chỉ những mẫu ghi mà phù hợp với trạng thái. Với chiến lược đó, chúng ta chỉ cần phải xem xét sự phù hợp $a_1$ với $b_1$, $a_3$ với $b_2$ do đó giảm đáng kể số lần so sánh phải thực hiện. . Cả hai bước blocking và matching thực hiện bằng cách học một random forest thông qua một quá trình học chủ động (active learning process). Một random forest là một tập của các luật quyết định mà được cho bởi những dữ đoán cuối cùng thông qua đa số phiếu được bầu được trả về bởi những luật riêng lẻ. Active learning (Học chủ động) là một quá trình học mà được xây dựng random forest bằng cách chủ động theo dõi hiệu suất của nó trên tập dữ liệu kiểm tra và lựa chọn có chọn lọc những mẫu huấn luyện mới để cải thiện hiệu suất của nó. Chúng ta sẽ giải thích chi tiết hơn hai bước này ở phần kế tiếp. . 3.3 Random Forests . Những luật blocking dựa trên hàm kiểm tra chuẩn hoá độ tương đồng, giống như, độ phụ hợp chính xác - exact match, tương đồng Jaccard - Jaccarc Similarity, tương đồng chồng chéo - overlap similarity, tương đồng cosin - cosine similarity, … Lấy ví dụ, nếu chúng ta đã kiểm tra tương đồng chồng chéo giữa “Prolific Consulting” và “Prolific Consulting Inc.”, đầu tiên chúng ta sẽ thu thập những token trong mỗi chúng, và sau đó kiểm tra những token nào là chung, cho chung ta một điểm tương đồng là 2/3 . Chúng ta biểu diễn một phần của một random forest cho blocking. Một random forest có thể được quan sát như một tập các luật. Random forest được hiển thị bên dưới là một tập của hai tập hợp luật. Các đối số của mỗi vị từ là hai giá trị được so sánh. . . Có nhiều nguyên lý tổng quát cho việc tự động hoá việc chọn hàm tương đồng (similarity functions) cho luật blocking. Ví dụ, với những thuộc tính mang giá trị số học như tuổi – age, trọng lượng – weight, giá cả – price, … những hàm tương đồng ứng viên có thể là: khớp chính xác - exact match, hiệu tuyệt đối - absolute difference, hiệu tương đối - relative difference, và khoảng cách Levenstein - Levenstein distance. Với những thuộc tính mang giá trị chuỗi (string), người ta thường dùng edit distance, cosine similarity, Jaccard similarity, và TF/IDF functions. . 3.4 Active Learning of Random Forests . Chúng ta có thể áp dụng Random Forest cho những luật blocking thông qua theo đổi quá trình học chủ động (active learning process). Chúng ta chọn một cách ngẫu nhiên một tập những cặp từ hai bộ dữ liệu. Bằng cách áp dụng hàm tương đồng lên mỗi thành phần của cặp, chúng ta có được một tập những đặc trưng cho mỗi cặp đó. Sử dụng những đặc trưng này, chúng ta sử dụng một Random Forest. Chúng ta áp dụng những luật có được lên một cặp mới được chọn từ tập dữ liệu, và đánh giá hiệu suất của chúng. Nếu hiệu suất dưới một ngưỡng (threshold) nhất định, chúng ta lặp lại chu trình, bằng cách cung cấp bổ sung những mẫu có nhãn cho đến khi hiệu suất chấp nhận được được tìm thấy. Chúng ta sẽ minh hoạ quá trình này bằng ví dụ ngay sau đây. . . Chúng ta giả định rằng bộ dữ liệu đầu tiên chứa ba thành phần: $a$, $b$, và $c$ và bộ dữ liệu thứ hai chứa hai thành phần $d$ và $e$. Từ bộ dữ liệu này, chúng ta lấy hai cặp $(a, d)$ và $(c, d)$ được gán nhãn tương đồng và không tương đồng bởi người dùng. Trên cặp này, chúng ta áp dụng những hàm tương đồng mà mỗi hàm sẽ cho ra kết quả là một đặc trưng của cặp. Sau đó chúng ta sử dụng những đặc trưng này để học một random forest. Chúng ta áp dụng những luật đã được học cho những bộ ba không nằm trong tập huấn luyện và hỏi người dùng để xác minh kết quả. Người dùng thông báo cho chúng ta biết là cặp $(b, d)$ là không đúng. Chúng ta thêm $(b, d)$ vào tập dữ liệu huấn luyện của chúng ta, và chúng ta lặp lại quá trình với vòng lặp tiếp theo. Sau một số vòng lặp, chúng ta dự đoán xem quá trình hội tụ chưa và cho chúng ta một Random forest để chúng ta có thể sử dụng một cách hiệu quản trong bước blocking. . Khi một Random forest đã được học, chúng ta có thể biểu diễn mỗi một luật cho người dùng. Dựa trên xác minh của người dùng, chúng ta chọn ra những luật sẽ được sử dụng trong những bước tiếp theo. . 3.5 Applying the Rules . Sau khi chúng ta học được những luật, bước kế tiếp là áp dụng chúng lên dữ liệu thật sự. Khi kích thước dữ liệu là cực lớn, nó vẫn không thể áp dụng những luật blocking cho tất cả các cặp đối tượng. Do đó, chúng ta phải dùng đến lập chỉ mục (resort to indexing). Giả sử sằng, một trong các luật yêu cầu chỉ mục Jaccard nên phải lớn hơn $0.7$, và chúng ta đang tìm kiếm phù hợp với bộ phim Sound of Music. Vì độ dài của tên bộ phim là $3$, chúng ta chỉ cần phải xem xét những bộ phim trong dữ liệu của chúng ta mà độ dài của chúng nằm giữa $3 times 0.7$ và $3/0.7$, tức là nằm giữa 2 và 4. Nếu chúng ta đã lập chỉ mục tập dữ liệu về kích thước của phim, nó rất hiệu quả để chọn được những bộ phim mà kích thước tên nằm giữa $2$ và $4$, và lọc tập hơn thông qua việc áp dụng những luật blocking. . 3.6 Performing the Matching . Bước blocking tạo ra một tạp những tập được tinh giảm đi rất nhiều mà đã được kiểm tra xem chúng có khớp với nhau hay không. Cấu trúc chung cho quá trình matching khá là tương tự với lần đầu chúng ta xác định một tập những đặc trưng, học một random forest, và thông qua quá trình active learning mà tinh chỉnh nó. Điểm khác biệt mấu chốt giữa bước blocking và matching là quá trình matching cần phải chính xác và cần nhiều tính toán. Bởi vì đây là bước cuối cùng trong mẫu ghi liên kết (record linkage) và chúng ta cần có độ tin cậy cao rằng hai thực thể phải chắc chắn khớp với nhau. . 4. Tổng kết . Trong chương này, chúng ta đề cập đến vấn đề khởi tạo một đồ thị tri thức bằng cách tích hợp dữ liệu đến từ những nguồn có cấu trúc. Lược đồ tích hợp của đồ thị tri thức có thể được tinh chỉnh và đánh giá theo mỗi yêu cầu của doanh nghiệp. Việc ánh xạ giữa những lược đồ của những nguồn khác nhau có thể được boostrapped thông qua những kỹ thuật thuật tự động, những chúng cần có xác mình đầu vào của con người. Record linkage - mẫu ghi liên kết là sự tích hợp dự liệu ở mức thể hiện, nơi mà chúng ta cần phải dự đoán đối sánh giữa hai thể hiện trong trường hợp không có bộ định danh duy nhất. Phương pháp tiếp cận chung nhất cho record linkage là học một Random Forest thông qua quá trình active learning. Với những ứng dụng yêu cầu độ chính xác cao, tính toán record linkage một cách tự động vẫn cần đến sự xác minh của con người. . Bài tập: . …Sẽ cập nhật sau… . Bài giảng gốc: https://web.stanford.edu/class/cs520/2020/notes/How_To_Create_A_Knowledge_Graph_From_Data.html .",
            "url": "https://nhutnamhcmus.github.io/lenux-notebooks/2021/06/26/how-to-create-a-knowledge-graph-from-data.html",
            "relUrl": "/2021/06/26/how-to-create-a-knowledge-graph-from-data.html",
            "date": " • Jun 26, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "How Create A Knowledge Graph",
            "content": "ĐỒ THỊ TRI THỨC - KNOWLEDGE GRAPH | Đây là bản dịch từ Course CS520: Knowledge Graphs | Data Models, Knowledge Acquisition, Inference and Applications | . Department of Computer Science, Stanford University, Spring 2021 . Knowledge graphs have emerged as a compelling abstraction for organizing world’s structured knowledge over the internet, capturing relationships among key entities of interest to enterprises, and a way to integrate information extracted from multiple data sources. Knowledge graphs have also started to play a central role in machine learning and natural language processing as a method to incorporate world knowledge, as a target knowledge representation for extracted knowledge, and for explaining what is being learned. This class is a graduate level research seminar and will include lectures on knowledge graph topics (e.g., data models, creation, inference, access) and invited lectures from prominent researchers and industry practitioners. The seminar emphasizes synthesis of AI, database systems and HCI in creating integrated intelligent systems centered around knowledge graphs. . Mục đích: Là tìm hiểu cũng như trau dồi kiến thức chuyên môn trong lĩnh vực Knowledge Graph cũng như từ vựng tiếng Anh. Không vì mục đích kinh doanh hay bất cứ mục đích về lợi nhuận, tất cả là vì mục đích chia sẻ kiến thức và học tập. . Mọi thông tin về những chủ đề được note lại có thể tìm thấy ở đây: . https://web.stanford.edu/class/cs520/2020/notes/Table_Of_Contents.html . Video của các buổi seminar trên địa chỉ Youtube: . https://www.youtube.com/playlist?list=PLDhh0lALedc5paY4N3NRZ3j_ui9foL7Qc . Mọi vấn đề về dịch thuật, thuật ngữ xin để lại comment hoặc gửi về địa chỉ email: lenam.fithcmus@gmail.com với tiêu đề . [ISSUES OF KG TRANSLATION] . HOW TO CREATE A KNOWLEDGE GRAPH? . LÀM THẾ NÀO ĐỂ KHỞI TẠO MỘT ĐỒ THỊ TRI THỨC? . 1. Giới thiệu . Ta có thể bắt đầu với đồ thị tri thức mà không cần thiết kế trước lược đồ (schema) của nó và phát triển cả lược đồ (schema) lẫn các thể hiện (instances) của nó trong suốt quá trình xử lý. Ở mức độ một bản thiết kế trước lược đồ đồ thị tri thức trong thực tế, nó có thể cải thiện đáng kể tính hữu dụng của nó. Giống như một thiết kế liên quan đến việc đưa ra một lựa chọn hợp lý những node, nhãn nút, những thuộc tính node, những quan hệ và những thuộc tính quan hệ. . Đầu vào cho quần thể đồ thị tri thức có thể đến từ một hoặc nhiều nguồn bao gồm dữ liệu có cấu trúc (structured data), dữ liệu bán cấu trúc (semi structured data), văn bản (free text) hoặc hình ảnh (images) hoặc được nhập trực tiếp bởi con người (direct authoring by human input). Khi chúng ta đang làm việc với nguồn dữ liệu có cấu trúc (structured data) và dữ liệu bán cấu trúc (semi structured data), chúng phải thực hiện tác vụ ánh xạ lược đồ (schema mapping task) (tức là, liên hệ lược đồ trong nguồn dữ liệu đầu vào với lược đồ của đồ thị tri thức) và tác vụ ghi liên kết (record linkage task) (tức là liên hệ những thể hiện mới với những thể hiện đã tồn tại từ trước trong đồ thị tri thức). Những những tác vụ cũng đối mặt trong suốt quá trình tích hợp dữ liệu (data integration) với chỉ một khác biệt là dữ liệu tích hợp được thể hiện trong mô hình dữ liệu đồ thị. Khi chúng ta đang làm việc với nguồn dữ liệu phi cấu trúc (unstructured sources), chúng ta phải giải quyết vấn đề rút trích thông tin trong tác vụ rút trích thực thể (entity extraction) và rút trích quan hệ (relation extraction) . Sự lựa chọn phương pháp sử dụng trong quần thể đồ thị tri thức phụ thuộc vào quy mô của vấn đề và độ chính xác mong muốn. Nếu một đồ thị tri thức được sử dụng trên quy mô web cho truy xuất thông tin (information retrieval), độ chính xác không cần phải hoàn hảo, và không sử dụng định danh con người cho mọi bộ ba của đồ thị. Nếu một đồ thị tri thức được sử dụng trong doanh nghiệp, nơi mà độ chính cần phải càng chính xác càng tốt (tiệm cần hoàn hảo), định danh con người là cần thiết ngay cả khi nó được thực hiện ngay trước khi thông tin được sử dụng. Độ chính xác luôn được mong muốn bất kể là doanh nghiệp hay cài đặt WW, để đảm bảo hiệu quả chi phí (cost effectiveness) và khả năng mở rộng (scalability), phải chú trọng đến nguồn cung cấp từ cộng đồng và các phương pháp giảm thiểu chi phí trong việc lấy thông đầu vào từ con người . 2. Thiết kế đồ thị tri thức . Cả đồ thị thuộc tính (Property Graph) và mô hình dữ liệu RDF (RDF Data Model) có một tập các vấn đề thiết kế, một vài trong số đó thường gặp ở cả hai, trong khi số khác thì chỉ cần ở một loại duy nhất. . Lấy ví dụ, cả hai mô hình đều cần phải sử dụng tái tổ chức cho những tình huống không thể mô hình hoá trực tiếp bằng cách sử dụng bộ ba. Một mô hình RDF (RDF Model) cần phải áp dụng một lược đồ cho IRIs điều mà không cần thiết với đồ thị thuộc tính (Property Graphs). Trong mô hình đồ thị thuộc tính (Property Graph Model), chúng ta cần phải quyết liệu rằng một giá trị có nên được biểu diễn như một thuộc tính (property) hay như một nút (node), trong khi sự phân biệt này không cần thiết trong một mô hình RDF. Trong phần này, chúng ta sẽ tìm hiểu tổng quan một số vấn đề thiết kế gặp phải với hai mô hình này. . 2.1 Thiết kế một RDF Graph - Design of an an RDF Graph . Các nguyên tắc tạo biểu đồ tri thức cho dữ liệu RDF trên WWW được gọi là các nguyên tắc dữ liệu được liên kết - linked data principles như sau: . - Sử dụng URIs như tên gọi cho mọi thứ . - Sử dụng HTTP URIs nên mọi người có thể tra cứu những tên gọi này . - Khi một người nào đó tra cứu một URI, cung cấp những thông tin hữu ích, sử dụng các chuẩn (RDF, SPARQL) . - Bao gồm liên kết đến những URIs khác, nên họ có thể khám phá nhiều thứ hơn . 2.1.1 Sử dụng URI như định danh cho các sự vật . Để xuất bản một đồ thị tri thức lên WWW, đầu tiên chúng ta phải định danh những thành phần quan tâm trong miền của chúng ta. Chúng là những thứ mà những thuộc tính và quan hệ của chúng, chúng ta muốn mô tả trên đồ thị. Trong thuật ngữ WWW (WWW terminology), tất cả nhưng thành phần quan tâm ấy được gọi là tài nguyên – resources. Những tài nguyên có hai loại: tài nguyên thông tin (information resources) và tài nguyên phi thông tin (non-information resources). Tất cả những tài nguyên mà chúng ta tìm kiếm trên WWW truyền thống như tài liệu (documents), hình ảnh (images) và những tập tin phương tiện (media files) là những tài nguyên thông tin (information resources) . Nhưng nhiều thứ chúng ta muốn trong đồ thi tri thức không phải con người (People), sản phẩm vật lý (physical product), nơi chốn (places), proteins, những khái niệm khoa học (scienctific concepts), …. Như một quy luật chung, tất cả “những thực thể thế giới thực” mà tồn tại bên ngoài WWW đều là tài nguyên phi thông tin (non-information resources) . Những người xuất bản đồ thị tri thức nên xây dựng URI để chia sẻ theo một cách đơn giản, ổn định và dễ quản lý. Nói gọn hơn, URI dễ nhớ sẽ không dễ bị hư hại khi được gửi trong email và nói chung dễ nhớ hơn :v Sau khi chúng ta cài đặt một URL để định danh một tài nguyên xác định, nó sẽ duy trì càng lâu càng tốt. Để đảm bảo tính bền bỉ lâu dài, tốt nhất là giữ các bit và phần cụ thể về triển khai, chẳng hạn như “.php”, và “.asp” ra ngoài URIs. Cuối cùng, URI nên được định nghĩa theo cách mà chúng có thể được quản lý bởi những người xuất bản (Developer chẳng hạn) . 2.1.2 Sử dụng HTTP URIs để mà con người có thể tra cứu chúng . Chúng ta định danh những tài nguyên bằng cách sử dụng Uniform Resources Identifiers (URIs) - Bộ định danh tài nguyên nguyên đồng nhất. Chúng ta tự hạn chế chỉ sử dụng các URI HTTP và tránh các lược đồ URI khác như Uniform Resource Names (URN) và Digital Object Identifiers (DOI). . Quá trình xử lý của việc tra cứu tên gọi là tham chiếu URI - URI dereferencing. Khi chúng ta tham chiếu một URI cho một đối tượng thông tin, chúng ta mong đợi có được biểu diễn trạng thái hiện tại của nó (ví dụ như là một tài liệu văn bản, một hình ảnh, một video, …) Nhưng khi chúng ta tham chiếu một tài nguyên phi thông tin, chúng ta có thể nhận được mô tả trong biểu diễn RDF trong một định nghĩa XML . 2.1.3 Khi một ai đó tra cứu một URI, cung cấp những thông tin hữu ích sử dụng RDF và SPARQL . Khi một ai đó tra cứu một URI, nhà cung cấp nên trả về một đồ thị tri thức trong RDF. Dữ liệu nên tái sử dụng những từ vựng được chuẩn hoá để đặt tên những IRIs được sử dụng trong mô tả dữ liệu RDF. Những từ vựng hữu ích có sẵn cho việc mô tả dữ liệu danh mục, những tổ chức và dữ liệu đa chiều (multidimensional data), như là thống kê trên Web. Một nổ sự mã nguồn mở gọi là Schema.Org công bố bởi cộng đồng từ vựng mã nguồn mở cho việc sử dụng trên khắp Web. Chúng ta xem xét một vài ví dụ về những từ vựng đấy . Dữ liệu RDF sau đây mô tả một đoạn về cơ cấu tổ chức của Văn phòng Nội các Vương quốc Anh. . @prefix uk_cabinet: &lt;http://reference.data.gov.uk/id/department/&gt; . uk_cabinet:co rdf:type org:Organization . uk_cabinet:co skos:prefLabel “Cabinet Office” . uk_cabinet:co org:hasUnit uk_cabinet:cabinet-office-communications . uk_cabinet:cabinet-office-communications rdf:type org:OrganizationUnit . uk_cabinet:cabinet-office-communications skos:prefLabel “Cabinet Office Communications” . uk_cabinet:cabinet-office-communications org:hasPost uk_cabinet:post_246 . uk_cabinet:post_246 skos:prefLabel “Deputy Director, Deputy Prime Minister’s Spokesperson” . Dữ liệu phía trên, bộ ba đầu tiên sử dụng lớp org:Organization từ Organization Ontology. . Bộ ba thứ hai sử dụng quan hệ skos:prefLabel được vẽ từ SKOS ontology. SKOS chuẩn hoá cho một Simple Knowledge Organization System, và cung cấp một vài quan hệ chung hữu ích như skos:prefLabel cho việc mô tả dữ liệu. Trong trường hợp này, skos:prefLabel đơn giản cho phép chúng ta liên hệ một nhãn văn bản uk_cabinet:co. . Bộ ba thứ ba sử dụng quan hệ org:hasUnit từ Organization ontology một tả một đơn vị trong UK Cabinet office . Hai bộ ba tiếp theo bổ sung khẳng định về đơn vị này . Bộ ba thứ sáu sử dụng quan eh65 org:hasPost mô tả vị trị với một phòng ban (department) . Và hai bộ ba cuối cùng cho thông tin bổ sung về vị trị đó . Không phải lúc nào cũng có thể tìm thấy những từ vựng tồn tại trước đó có thể được sử dụng trong khởi tạo RDF dataset. Nếu việc khởi tạo mới một từ vựng trở nên cần thiết, chúng ta nên đảm bảo rằng nó được ghi lại, tự mô tả, có chính sách phiên bản, được định nghĩa trong nhiều ngôn ngữ, và được xuất bản bởi một nguồn đáng tin cậy để mà các tồn tại URIs sử dụng nó trong một khoảng thời gian dài. Chúng ta nói rằng một từ vựng tự mô tả nếu mỗi thuộc tính hoặc thuật ngữ có một nhãn, khái niệm và chú thích được định nghĩa. . 2.1.4 Bao gồm các tới các URIs khác, nên họ có thể khám phá nhiều thứ hơn . Trong khi xuất bản dữ liệu bằng cách sử dụng RDF, chúng ta nên cung cấp liên kết đến những đối tượng để mà tăng tính hữu ích của nó. Có 3 loại liên kết: . - Relationship links - liên kết quan hệ . - Identity links - liên kết thực thể . - Vocabulary links - liên kết từ vựng . Liên kết quan hệ (Relationship links) trỏ đến những thứ liên hệ trong những nguồn dữ liệu khác như những người khác, những nơi chỗ hoặc genes. Ví dụ, liên kết quan hệ cho phép con người có thể có trỏ đến những thông tin lai lịch về nơi mà họ sinh sống, hoặc dữ liệu thư mục về những công bố mà họ đã viết. Trong bộ ba sau đây, chúng ta thấy một liên kết mà một cá nhân trong một tập dữ liệu đươc xác nhận là sống gần một vị trí địa lý được chỉ định bằng cách sử dụng URI trong một tập dữ liệu khác. . @prefix big: &lt;http://biglynx.co.uk/people/&gt; . @prefix dbpedia: &lt;http://dbpedia.org/resource/&gt; . big:dave-smith foaf:based_near dbpedia:Birmingham . Liên kết thực thể (Identity links) trỏ đến những URI bí danh sử dụng bởi những nguồn dữ liệu khác để định danh cùng một đối tượng trong thế giới thực hoặc khái niệm trừu tượng, Liên kết thưc thể cho phép khách hàng (clients) có thể truy xuất nhiều mô tả về một thực thể và phục vụ một chức năng xã hội quan trọng vì chúng cho phép nhiều góc nhìn khác nhau về thế giới được thể hiện trên WWW. Nó là một chuẩn thực thể để sử dụng loại liên kết http://www.w3.org/2002/07/owl#sameAs để thông báo hai bí danh URI cùng tham chiếu đến cùng một nguồn. . Lấy ví dụ, nếu Dave Smith cùng muốn bảo trì một dữ liệu trang chủ ẩn danh bên cạnh dữ liệu mà Big Lynx công khai về anh ta, anh có thể thêm một liên kết http://www.w3.org/2002/07/owl#sameAs đến dữ liệu trang chủ ẩn danh, việc thông báo URI sử dụng tham chiếu đến tài liệu và URI sử dung bởi Lynx cùng tham chiếu đến cùng một thưc thể thế giới thực. Một bộ ba biểu diễn thông tin như thế được mô tả sau đây: . @prefix ds: &lt;http://www.dave-smith.eg.uk&gt; . @prefix owl: &lt;http://www.w3.org/2002/07/owl&gt; . @prefix big: &lt;http://biglynx.co.uk/people/&gt; . ds:me owl:sameAs big:dave-smith . Liên kết từ vựng trỏ trừ dữ liệu đến những định nghĩa của những thuật ngữ từ vựng được sử dụng để biểu diễn dữ liệu, giống như từ những định nghĩa này đến những định nghĩa của những thuật ngữ được liên hệt trong những từ vựng khác. Liên kết từ vựng làm cho dữ liệu tự mô tả và cho phép ứng dụng liên kết dữ liệu (Link Data) hiểu và tích hợp dữ liệu thông quan những từ vựng. Trong liên kết từ vựng được cho sau đây, lớp SmallMediumEnterprise định nghĩa bởi BigLynx được định nghĩa thành một lớp con của lớp Company trong DBpedia Ontolgy. Bằng cách tạo ra một liên kết như thế, có thể truy xuất các xác nhận khác nhau về lớp Company từ DBPedia, và sử dụng chung với lớp SmallMediumEnterprise. . @prefix dbpedia: &lt;http://dbpedia.org/ontology/&gt; . big:sme#SmallMediumEnterprise rdfs:subClassOf dbpedia:Company . 2.2 Thiết kế một đồ thị thuộc tính (Property Graph) . Thiết kế một đồ thị thuộc tính liên quan đến chọn nút (nodes), nhãn nút (node labels), thuộc tính nút (node properties), cạnh liên kết (edges) và thuộc tính cạnh liên kết (edge properties). Những câu hỏi thiết kế cơ bản là liệu có nên mô hình hoá một phần thông tin như một thuộc tính, nhãn hay như một đối tượng riêng biệt; khi nào nên đưa vào những thuộc tính quan hệ; và làm thế nào có thể xử lý những mối quan hệ đặc biệt (higher arity relationships). Chúng ta sẽ minh họa quá trình thực hiện những lựa chọn này bằng cách sử dụng các ví dụ. . 2.2.1 Lựa chọn nút (Nodes), nhãn (Labels) và thuộc tính (Properties) . Trong một mô hình đồ thị thuộc tính, những nút thường biểu diễn những thực thể trong miền, Nếu chúng dược biểu diễn với thông tin biểu diễn về con người, chúng ta sẽ khởi tạo một nút cho mỗi cá nhân (ví dụ John), và liên hệ nhãn Person với nút đó. . Có nhiều cân nhắc trong tạo ra nhiều lựa chọn hơn những nhãn nút, những thuộc tính nút và cạnh liên kết. Những cân nhắc này bao gồm: tính tự nhiên của nhãn, liệu các nhãn có thể thay đổi trong một khoảng thời gian, hiệu suất truy vấn thời gian chạy và số lượng các giá trị . Để minh hoạ sự lựa chọn liệu có nên mô hình hoá một phần thông tin thành một nhãn, thuộc tính hay thành một đối tượng riêng biệt, xem xét tác vụ biểu diễn giới tính của một người. Chúng ta có ba cách tìm năng để biểu diễn thông tin này: . - (1) Chúng ta có thể khởi tạo :Male và :Female như những nhãn và liên hệ chung với những nút Person . - (2) Chúng ta có thể khởi tạo một thuộc tính gọi là “Gender” và liên hệ nó với nút Person và cho phép nó có thể có giá trị “male” và “female” . - (3) Chúng ta có thể khởi tạo đối tượng Gender, liên hệ nó với Person bằng cách sử dụng mối quan hệ has_gender, và cho nó một thuộc tính gọi là “name” mà có thể lấy “male” và “female” như những giá trị của nó . Những nhãn trong một mô hình đồ thị thuộc tính được sử dụng để nhóm những nút thành những tập hợp. Tất cả những nút được gán nhãn với cùng nhãn sẽ thuộc về cùng một tập. Những truy vấn có thể hoạt động với những tập hợp thay vì toàn bộ đồ thị, tạo ra những câu truy vấn dễ dàng hơn, và hiệu quả hơn. Một nút có thể được gán nhãn với bất kỳ nhãn nào, kể cả rỗng, việc tạo nhãn là một tuỳ chọn bổ sung cho đồ thị. Như nhóm những nhãn nút thành một tập, nó có thể được nhìn như một lớp. Câu hỏi đặt ra là liệu có thể đưa một nhãn mới có thể được đặt lại như đưa vào một lớp mới hay không? . Khởi tạo những lớp mới Male và Female so với đưa vào một thuộc tính nút “gender” mà có thể nhận giá trị “male” và “female” biểu diễn cùng một thông tin. Một cách tổng quát, bất cứ khi nào một cụm từ xuất hiện một cách tự nhiên trong ngôn ngữ một cách thường xuyên được sử dụng trong một miền, nó là một ứng viên có thể được thêm vào như một lớp miễn là số lượng thành viên trong lớp không thay đổi theo thời gian. Như một số cài đặt tối ưu truy xuất dựa trên sử dụng nhãn, việc sử dụng nhãn có thể cho kết quả truy vấn với hiệu suất cao mà cần thiết để lọc những kết quả dựa trên thành viên trong lớp. Nếu lớp các thành viên thay đổi theo thời gian, cả nhãn hay giá trị thuộc tính nút đều không phải là lựa chọn thích hợp, chúng ta cần phải sử dụng một mối quan hệ. Chúng ta sẽ xem xét vấn đề này trong phần dưới đây :v . 2.2.2 Khi đưa vào mối quan hệ (Relationships) giữa những đối tượng (Objects) . Với những tình huống có thể mô hình hoá thay vì sử một thuộc tính nút hoặc đưa vào một đối tượng riêng biệt và mối quan hệ, ở đây, ít nhất, có hai cân nhắc khác nhau. Cân nhắc đầu tiên được giới thiệu trong phân phía trên: những thành viên trong lớp thay đổi theo thời gian. Cân nhắc thứ hai phát sinh khi chúng ta mong muốn đạt đươc hiệu năng tốt hơn. Chúng ta sẽ xem xét những tình huống này chi tiết hơn . Tiếp tục với ví dụ từ phần trước, khi giới tính của một người có thể thay đổi trong một khoảng thời gian, do đó lựa chọn của chúng ta chỉ có thể là biểu diễn thông tin như một đối tượng Gender riêng biệt mà có thể liên hệ với Person bằng cách sử dụng quan hệ has_gender. Chúng ta có thể liên hệ một mối quan hệ thuộc tính với mối quan hệ has_gender mà cho biết khoảng thời gian mà giá trị cụ thể của giới tính đó nắm giữ. Khởi tạo một nút riêng biệt Gender, tuy nhiên sẽ dẫn tới một số lượng lớn các cạnh liên kết gây lãng phí vì hầu hết mọi người thì giới tính không đổi. Trong trường hợp như thế, có thể mong muốn một kết hợp hai giải pháp trong đó, đối với hầu hết mọi người, giới tính được biểu diễn như một giá trị thuộc tính nút, nhưng với một số ít người, nó được biểu diễn như một giá trị quan hệ thuộc tính đến một nút Gender riêng biệt. . Chúng ta xem xét một tình huống mà việc truy vấn hiệu suất tốt hơn là một yếu tố quan trọng cần cân nhắc. Giả định rằng, chúng ta mong muốn mô hình hoá những bộ phim và những thể loại của chúng. Trong một thiết kế, với một nút thuộc kiểu Movie, chúng ta có thể thêm một thuộc tính “genre” mà có thể nhận những giá trị như “Action”, “SciFci”, … Trong một thiết kế khác, chúng ta có thể thêm một nút kiểu Genre mà có một thuộc tính nút là “name” mà có thể nhận những giá trị như là “Action”, “SciFci”. Sau đó chúng ta sẽ liên hệ một nút kiểu Movie với một nút kiểu Genre bằng cách sử dụng mối quan hệ has_genre. Tổng quát, chúng ta có thể liên kết nhiều hơn một thể loại với một bộ phim. Giả định rằng chúng ta mong muốn truy vấn những bộ phim mà có ít nhất một thể loại chung. Giải pháp đầu tiên là chúng ta sử dụng một thuộc tính nút “genre”, trong truy vấn này sẽ được viết bằng Cypher: . MATCH (m1:Movie), (m2:Movie) . WHERE any(x IN m1.genre WHERE x IN m2.genre) . AND m1 &lt;&gt; m2 . RETURN m1, m2 . Khi chúng ta mô hình hoá thể loại như một đối tượng riêng biệt, truy vấn tương tự cũng tự viết như sau: . MATCH (m1:Movie)-[:has_genre]-&gt;(g:Genre), . (m2:Movie)-[:has_genre]-&gt;(g) . WHERE m1 &lt;&gt; m2 . RETURN m1, m2 . Trong truy vấn thứ hai ở trên, chúng ta có khả năng sử dụng một cách trực tiếp mẫu đồ thị (graph patterns) và trong một số graph engine, truy vấn này có một hiệu suất thời gian chạy nhanh hơn (faster runtime performance) bởi vì lập chỉ mục trên các mối quan hệ. . Do đó, trong trường hợp này, người ta phải chọn giữa hai thiết kế tùy thuộc vào loại truy vấn sẽ được mong đợi. . 2.2.3 Khi đưa vào mối quan hệ (Relationships) giữa những thuộc tính (Properties) . Chúng ta đã thấy một ví dụ về một thuộc tính liên hệ với một mối quan hệ để giải quyết tình huống khi mối quan hệ thay đổi theo thời gian. Những tình huống khác mà chúng có ý nghĩa để thêm những thuộc tính với mối quan hệ bao gồm liên hệ trọng số hoặc độ tin cậy với một mối quan hệ hoặc liên hệ nguồn gốc hoặc meta data khác với mối quan hệ . Một số grah engine không chỉ mục dựa trên những mối quan hệ thuộc tính. Nếu sử dụng trường hợp như vậy mà một lượng lớn đánh giá truy vấn có thể hoàn thành mà không cần sử dụng những mối quan hệ thuộc tính, và chúng chỉ cần cho lọc kết quả cưới cùng, chúng ta không cần phải trả giá về mặt hiệu năng vì thiếu chỉ mục. Nếu truy cập đến những quan hệ thuộc tính là trọng tâm của hiệu suất truy vấn, tốt hơn nó nên được sửa đổi quan hệ, và chúng ta sẽ thảo luận ngay phần bên dưới :v . 2.2.4 Xử lý các mối quan hệ phi nhị phân (Handling non-binary Relationships) . Chúng ta thường xuyên cần phải mô hình hoá những mối quan hệ mà không phải nhị phân. Một ví dụ chung về một mối quan hệ như là mối quan hệ between được cho bởi những đối tượng A, B và C mà C là between A và B. Một tiếp cận chuẩn để biểu diễn những mối quan hệ đặc biệt cao này trong một đồ thị là tái tổ chức (reification). Chúng ta đã thảo luận trước đó về tái tổ chức (reification) trong một ngữ cảnh của RDF, nhưng kỹ thuật này cũng hữu ích và đáng kỳ vọng như nhau đối với đồ thị. Để nắm bắt mối quan hệ between, chúng ta thể vào một nút kiểu Between_Relationship mà có hai thuộc tính: bas_object (với những giá trị là A và B) và has_between_object (với giá trị C). Chúng ta có thể sử dụng tái tổ chức cho những quan hệ với bất kỳ đặc biệt nào bằng cách khởi tạo một nút kiểu mới cho quan hệ, và bằng cách thêm những thuộc tính nút cho những tham số khác nhau của quan hệ đó. . 3. Tổng kết . Bài tập: . …Sẽ cập nhật sau… . Bài giảng gốc: . https://web.stanford.edu/class/cs520/2020/notes/How_To_Create_A_Knowledge_Graph.html .",
            "url": "https://nhutnamhcmus.github.io/lenux-notebooks/2021/06/26/how-create-a-knowledge-graph.html",
            "relUrl": "/2021/06/26/how-create-a-knowledge-graph.html",
            "date": " • Jun 26, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "What Is Knowledge Graph",
            "content": "ĐỒ THỊ TRI THỨC - KNOWLEDGE GRAPH | Đây là bản dịch từ Course CS520: Knowledge Graphs | Data Models, Knowledge Acquisition, Inference and Applications | . Department of Computer Science, Stanford University, Spring 2021 . Knowledge graphs have emerged as a compelling abstraction for organizing world’s structured knowledge over the internet, capturing relationships among key entities of interest to enterprises, and a way to integrate information extracted from multiple data sources. Knowledge graphs have also started to play a central role in machine learning and natural language processing as a method to incorporate world knowledge, as a target knowledge representation for extracted knowledge, and for explaining what is being learned. This class is a graduate level research seminar and will include lectures on knowledge graph topics (e.g., data models, creation, inference, access) and invited lectures from prominent researchers and industry practitioners. The seminar emphasizes synthesis of AI, database systems and HCI in creating integrated intelligent systems centered around knowledge graphs. . Mục đích: Là tìm hiểu cũng như trau dồi kiến thức chuyên môn trong lĩnh vực Knowledge Graph cũng như từ vựng tiếng Anh. Không vì mục đích kinh doanh hay bất cứ mục đích về lợi nhuận, tất cả là vì mục đích chia sẻ kiến thức và học tập. . Mọi thông tin về những chủ đề được note lại có thể tìm thấy ở đây: . https://web.stanford.edu/class/cs520/2020/notes/Table_Of_Contents.html . Video của các buổi seminar trên địa chỉ Youtube: . https://www.youtube.com/playlist?list=PLDhh0lALedc5paY4N3NRZ3j_ui9foL7Qc . Mọi vấn đề về dịch thuật, thuật ngữ xin để lại comment hoặc gửi về địa chỉ email: lenam.fithcmus@gmail.com với tiêu đề . [ISSUES OF KG TRANSLATION] . WHAT IS A KNOWLEDGE GRAPH? . ĐỒ THỊ TRI THỨC LÀ GÌ? . 1. Giới thiệu . Đồ thị tri thức là một cấu trúc trừu tượng rất hợp lý, hấp dẫn cho việc tổ chức tri thức có cấu trúc của thế giới trên Internet, và như một cách tích hợp rút trích thông tin từ nhiều nguồn dữ liệu. Đồ thị tri thức cũng đóng vai trò trung tâm trong Machine Learning (Học Máy) như một phương pháp kết hợp tri thức nhân loại, như một mục tiêu biểu diễn tri thức (Knowledge Representation) với những tri thức đã được rút trích, và giải thích những gì học được. . Mục đích của chúng ta ở đây là để giải thích những thuật ngữ (terminology), khái niệm (concepts) và cách sử dụng của Đồ thị tri thức trong một cách hiểu đơn giản. Chúng ta không tổ chức một khảo sát toàn diện về những công trình quá khứ và hiện tại về đề tài Đồ thị tri thức. . Chúng ta sẽ bắt đầu bằng cách định nghĩa về đồ thị tri thức, một vài ứng dụng mà đóng góp vào sự phát triển phổ biến của Đồ thị tri thức, sau đó sử dụng Đồ thị tri thức vào trong Machine Learning (Học Máy). Chúng ta sẽ kết lại chương bằng một tổng kết chung về những điểm mới và khác biệt về phương pháp Đồ thị tri thức trong thời gian gần đây. . 2. Định nghĩa Đồ thị tri thức . Một Đồ thị tri thức (Knowledge Graph) là một đồ thị hữu hướng được gán nhãn (Directed labeled graph – DLG) mà những nhãn này xác định có ý nghĩa rõ ràng. . Một đồ thị hữu hướng được gán nhãn (DLG) bao gồm các nút (nodes), cạnh liên kết (edges) và nhãn (labels). Bất kỳ thứ gì đều có thể xem là một nút (node), ví dụ như con người, công ty, máy tính, … . Một cạnh liên kết (edges) kết nối một cặp nút (nodes) và thể hiện mối quan hệ được quan giữa chúng, ví dụ như mối quan hệ tình bạn giữa hai người, mối quan hệ khách hàng giữa một công ty và một người, hoặc một kết nối mạng kết nối hai máy tính. Nhãn thể hiện ý nghĩa của mối quan hệ đó, ví dụ: mối quan hệ tình bạn giữa hai người. . Tổng quát hơn, cho một tập các nút $N$, và một tập các nhãn $L$, một đồ thị tri thức là một tập hợp con của tích hữu hướng $N times L times N$. Mỗi thành phần trong tập này được gọi là một bộ ba và có thể trực quan như sau: . . Biểu diễn đồ thị hữu hướng thường được sử dụng trong nhiều cách khác nhau phụ thuộc vào nhu cầu của ứng dụng. Một đồ thị hữu hướng như tập các node biểu diễn con người, và các cạnh liên kết thể hiện mối quan hệ tình bạn giữa họ còn được gọi là một dữ liệu đồ thị. Một đồ thị hữu hướng mà những node là những lớp đối tượng (sách, báo, …) và những cạnh liên kết thể hiện mối quan hệ lớp con có thể hiểu là một phân loại học (taxonomy). Trong một số mô hình dữ liệu, A được gọi là chủ thể (subject), B được gọi là thuộc tính (predicate), và C được gọi là đối tượng (object). . Nhiều tính toán dựa trên đồ thị có thể điều chỉnh thành dạng điều hướng. Ví dụ như, trong một đồ thị tri thưc tình bạn, để tính toán bạn bè của một người bạn của một người A, chúng ta có thể điều hướng đồ thị tri thức từ A đến tất cả các node B mà liên kết với nó bằng nhãn quan hệ bạn, và sau đó, đệ quy đến tất cả node C liên kết đến B bởi mối quan hệ bạn. . Một đường đi (Path) trong một đồ thị G là một chuỗi các node $(v_1, v_2, …, v_n)$ trong đó bất kỳ một node i nào thuộc N với $1 leq i &lt; n$, tồn tại một cạnh liên kết từ $v_i$ đến $v_{i+1}$. . Một đường đi đơn (SIMPle Path) là một đường đi mà không có node nào lặp lai . Một chu trình (Cycle) là một đường đi trong đó node bắt đầu và node kết thúc là giống nhau. . Thông thường thì, chúng ta quan tâm đến chỉ một vài đường đi mà nhãn cạnh liên kết giống với tất cả các cặp node. Có thể định nghĩa nhiều thuộc tính khác trên đồ thị (thành phần liên thông, thành phần liên thông mạnh) và những cách khác nhau để duyệt đồ thị như (đường đi ngắn nhất - shortest path, đường đi Hamiltonian, ….) . 3. Những ứng dụng gần đây của Đồ thị tri thức . Có rất nhiều những ứng dụng của đồ thị tri thức cả trong nghiên cứu lẫn doanh nghiệp. Trong Khoa học máy tính, có rất nhều cách sử dụng biểu diễn đồ thị hữu hướng, ví dụ như, luồng dữ liệu đồ thị, sơ đồ quyết định nhị phân, biểu đồ trạng thái, … Ở đây chúng ta sẽ tập trung vào hai ứng ứng cụ thể dẫn đến sự phát triển phổ biến của đồ thị tri thức: tổ chức thông tin trên Internet, và tích hợp dữ liệu. . 3.1 Đồ thị tri thức trong việc tổ chức thông tin trên Internet . Chúng ta sẽ giải thích việc sử dụng một đồ thị tri thức trên trang web bằng cách lấy ví dụ cụ thể về Wikidata. Wikidata đóng vai trò là nơi lưu trữ trung tâm cho dữ liệu có cấu trúc cho Wikipedia. Để cho thấy sự tác động lẫn nhau giữa hai đối tượng, và động lực của việc sử dụng đồ thị tri thức Wikidata, ta xem xét thành phố Winterthur ở Switzerland có một trang trên Wikipedia. Trang Wikipedia cho Winterthur liệt kê những thị trấn song sinh với nó: hai ở Switzerland, một ở Czech Republic, và một ở Austria. Thành phố của Ontario ở California có một trang Wikipedia với tựa đề dựa đặt là Ontario, California, liệt kê Winterhur như thành phố kết nghĩa của nó. Những quan hệ thành phố kết nghĩa và thành phố song sinh đồng nhất cũng như tương hỗ. Như vậy, nếu một thành phố A là một thành phố kết nghĩa của một thành phố khác B thì B phải là một thành phố kết nghĩa của A.Việc suy luận này nên tự động, nhưng vì thông tin này được nêu bằng tiếng Anh trong Wikipedia, nên không dễ phát hiện ra sự khác biệt này. Ngược lại, trong Wikidata, biểu diễn của Winterthur, có một mối quan hệ được gọi là cơ quan hành chính kết nghĩa liệt kê thành phố Ontario. Vì mối quan hệ này là đối xứng, trang Wikidata cho thành phố Ontario tự động bao gồm Winterthur. Do đó, khi đồ thị kiến thức Wikidata sẽ được tích hợp hoàn toàn vào Wikipedia, những sai lệch như vậy sẽ tự nhiên biến mất. . Wikidata bao gồm dữ liệu từ nhiều nhà cung cấp độc lập, ví dụ như Library of Congress, công bố dữ liệu chứa những thông tin về Winterthur. Bằng cách sử dụng bộ định danh (identifier) Wikidata cho Winterthur, thông tin được phát hành bởi Library of Congress có thể được liên kết một cách dễ dàng với những thông tin sẵn có từ những nguồn khác. Wikidata giúp dễ dàng thiết lập các liên kết như vậy bằng cách xuất bản các định nghĩa của các mối quan hệ được sử dụng trong nó trong Schema.Org. . Từ vựng quan hệ trong Schema.Org cho chúng ta, ít nhất, ba ưu điểm. . - Thứ nhất, có thể viết các truy vấn trải dài trên nhiều tập dữ liệu . - Thứ hai, với khả năng truy vấn như vậy, có thể dễ dàng tạo các khối thông tin có cấu trúc trong Wikipedia . - Thứ ba, thông tin có cấu trúc được trả về bởi các truy vấn cũng có thể xuất hiện trong kết quả tìm kiếm, hiện là một tính năng tiêu chuẩn cho các công cụ tìm kiếm hàng đầu . Một phiên bản gần đây của Wikidata có hơn 80 triệu đối tượng, với hơn một tỷ quan hệ giữa những đối tượng này. Wikidata tạo ra những liên kết qua hơn 4872 danh mục khác nhau bằng 414 ngôn ngữ khác nhau do các nhà cung cấp dữ liệu độc lập xuất bản. Theo ước tính gần đây, 31% trang web và hơn 12 triệu nhà cung cấp dữ liệu xuất bản chú thích Schema.Org hiện đang sử dụng từ vựng của Schema.Org. . Một số đặc trưng chính của đồ thị tri thức Wikidata . - Một đồ thị với quy mô chưa từng có, và là một đồ thị tri thức lớn nhất cho đến thời điểm hiện tại . - Nó được tham gia xây dựng bởi một cộng đồng người đóng góp . - Một số dữ liệu trong Wikidata có thể đến từ những thông tin được rút trích tự động, những nó phải dễ hiểu và được xác minh theo chính sách biên tập của Wikidata . - Đó là một nỗ lực vô cùng để cung cấp các định nghĩa ngữ nghĩa của các tên quan hệ khác nhau thông qua từ vựng trong Schema.Org. . - Mục tiêu chính của việc sử dụng Wikidata là cải thiện tìm kiếm trên web . Cho dù Wikidata có nhiều ứng dụng sử dụng nó trong việc phân tích và trực quan hoá dữ liệu, nhưng sử dụng nó trên web tiếp tục vẫn là một ứng dụng hấp dẫn và dễ hiểu nhất. . 3.2 Đồ thị tri thức trong việc tích hợp dữ liệu trong doanh nghiệp . Tích hợp dữ liệu (Data Integration) là quá trình kết hợp dữ liệu từ nhiều nguồn khác nhau và cung cấp cho người dùng một cái nhìn tổng quát về dữ liệu. . Phần lớp dữ liệu doanh nghiệp nằm trong các cơ sở dữ liệu. Một cách tiếp cận trong việc tích hợp dữ liệu là dựa trên lược đồ toàn cục (global schema) để nắm bắt mối quan hệ qua lại giữa những thành phần dữ liệu được biểu diễn trên các cơ sở dữ liệu này. Hình thành một lược đồ toàn cục (global schema) là một quá trình thật sự khó khăn bởi vì có quá nhiều bảng và thuộc tính; những chuyên gia, những người mà tạo ra những cơ sở dữ liệu này không phải lúc nào cũng có mặt, và do sự thiếu thốn các tài liệu, nên khó để hiểu ý nghĩa của dữ liệu. Bởi vì thách thức trong việc hình thành một lược đồ toàn cục (global schema), nó sẽ thuận tiện hơn khi bỏ qua các vấn đề và chuyển đổi dữ liệu quan hệ (relational data) trong một cơ sở dữ liệu với một lược đồ bộ ba tổng quát, tức là đồ thị tri thức. Việc ánh xạ giữa những thuộc tính được tạo ra trên cơ sở cần thiết, ví dụ như để giải quyết các câu hỏi kinh doanh cụ thể và bản thân chúng có thể được biểu diễn trong một biểu đồ tri thức. . Nhiều tổ chức tài chính (financial institutions) quan tâm tới việc hình thành một đồ thị tri thức công ty, mà kết hợp được dữ liệu khách hàng nội bộ với dữ liệu có giấy phép từ các bên thứ ba. Một vài ví dụ về các kho dữ liệu bên thứ ba bao gồm Dunn &amp; Bradstreet, S &amp;P 500, … Một ví dụ sử dụng một đồ thị tri thức công ty là trong việc đánh giá rủi ro trong khi đưa ra các quyết định cho vay. Dữ liệu bên ngoài bao gồm thông tin như các nhà cung cấp của một công ty. Nếu một công ty đang rơi vào tình trạng tài chính khó khăn, nó tăng rủi ro cho vay của các nhà cung cấp/ đầu tư của công ty đó. Để kết hợp dữ liệu bên ngoài này với dữ liệu nội bộ, người ta phải liên hệ được những lược đồ bên ngoài với lược đồ nội bộ công ty. Hơn nữa, tên công ty sử dụng trong các nguồn bên ngoài phải có mối quan hệ với định danh khách hàng tương ứng, được sử dụng bởi các tổ chức tài chính. Trong khi sử dụng một đồ thị tri thức là một hướng tiếp cận tích hợp dữ liệu, việc xác định các mối quan hệ có thể được hoãn lại cho đến khi chúng thật sự cần. . 4. Đồ thị tri thức trong Trí tuệ nhân tạo . Đồ thị tri thức, hay được biết đến như mạng ngữ nghĩa (semantic network), đã được sử dụng trong việc biểu diễn trong Trí tuệ nhân tạo từ những ngày đầu tiên của lĩnh vực này. Trải qua nhiều năm, mạng ngữ nghĩa (semantic networks) được phát triển thành nhiều biểu diễn khác nhau như Conceptual Graphs, Description Logics và Rules Languages. Để nắm bắt những tri thức không chắc chắn, mô hình đồ thị xác suất (probabilistic graphical models) được phát minh. . Một ứng dụng được biết đến rộng rãi trong việc biểu diễn ngôn ngữ bắt nguồn từ mạng ngữ nghĩa (semantic networks) trong việc nắm bắt các Ontology (bản thể). Một Ontology là đặc tả (formal) chính thức về việc hình thành khái niệm của một miền (domain). Ontology đóng vai trò quan trọng trong trao đổi thông tin và trong việc nắm bắt tri thức tìm ân trong một miền có thể sử dụng cho việc luận và trả lời câu hỏi (answering question). . World Wide Web Consortium (W3C) được chuẩn hoá thành một họ của những biểu diễn tri thức ngôn ngữ mà bây giờ được sử dụng rộng rãi cho việc nắm bắt tri thức trên mạng Internet. Chúng ta sẽ đề cập một ngôn ngữ như thể trong phần tiếp theo, Resource Description Frame (RDF). Họ ngôn ngữ này bao gồm Web Ontology Language (OWL) và Semantic Web Rule Language (SWRL). . Giao hoà với việc biểu diễn tri thức, một thách thức chính trong AI là nút thắc thu nhận thông tin, tức là làm thế nào có thể nắm bắt tri thức trong biểu diễn được chọn trong một bối cảnh đang nở rộng. Những phương pháp tiếp cận sơ khai, dựa trên kỹ thuật tri thức (knowledge engineering). Cố gắng để tự động hoá các phần trong kỹ thuật tri thức dẫn đến những kỹ thuật như học quy nạp (inductive learning) và thế hệ hiện tại của Máy học. . Do đó, như một điều tự nhiên, đồ thị tri thức được sử dụng như một biểu diễn được lựa chọn trong lữu trữ tri thức được học một cách tự động. Ngày càng có nhiều sự quan tâm đến việc tận dụng miền tri thức được thể hiện trong đồ thị tri thức để cải thiện Máy học. . 4.1 Đồ thị tri thức như đầu ra của Máy học . Chúng ta sẽ xem xét làm thế nào mà đồ thị được sử dụng như là một mục tiêu biểu diễn đầu ra trong các thuật toán Xử lý ngôn ngữ tự nhiên và Thị giác máy tính. . Rút trích thực thể và rút trích quan hệ từ văn bản là hai tác vụ cơ sở trong Xử lý ngôn ngữ tự nhiên. Việc rút trích thông tin từ nhiều phần trong văn bản cần có mối tương quan và đồ thị tri thức cung cấp một phương tiện tự nhiên để thực hiện mục đích như vậy. . Ví dụ, từ một câu như sau: . “Albert Einstein was a German-born theoretical physicist who developed the theory of relativity.” . Chúng ta có thể rút trích những thực thể Albert Einstein, Germany, Theoretical Physicist, và Theory of Relativity, những quan hệ born in, occupation and developed. . Khi đoạn trích này của đồ thị tri thức được kết hợp vào một đồ thị tri thức lớn hơn, chúng ta sẽ nhận được các liên kết bổ sung (được hiển thị bằng các cạnh chấm chấm), chẳng hạn như Nhà vật lý lý Thuyết (Theoretical Physicist) là một loại Nhà vật lý (Physictist), nghiên cứu Vật lý và Lý Thuyết Tương Đối (Theory of Relativity) là một nhánh của Vật lý. . . Thị giác máy tính (Nguyên văn: A holy grail of Computer vision, :))chén thánh này vjp pro quá mình cũng khum biết nói sao, hj!) là sự hiểu biết về hình ảnh, hình thành một mô hình, mà có thể định danh, nhận diện vật thể (detect objects), mô tả thuộc tính (attributes) của chúng, và nhận dạng quan hệ của chúng. Sự hiểu biến về khung cảnh thế giới cho cho phép các ứng dụng quan trọng như tìm kiếm hình ảnh (image search), trả lời câu hỏi (question answering) và tương tác với robot (robotic interactions). Nhiều tiến bộ đã đạt được trong những năm gần đây hướng tới mục tiêu này, bao gồm phân loại hình ảnh (image classification) và phát hiện đối tượng (object detection). . . Lấy ví dụ, từ một ảnh phía trên, một hệ thống tri thức hình ảnh nên tổ chức một đồ thị tri thức như phía bên phải. Các nút (node) trong đồ thị tri thức là đầu ra của một bộ phát hiện đối tượng. Những nghiên cứu gần đây trong Thị giác máy tính đang tập trung vào phát triển những kỹ thuật có thể dự đoán chính xác mối quan hệ giữa những đối tượng, ví dụ như, người đàn ông kia đang cần một cái xô, và chú ngựa đang ăn từ cái xô đó, … Đồ thị tri thức ở bên phải là một ví dụ của một đồ thị tri thức (tui hơi lú rồi) . 4.2 Đồ thị tri thức như đầu vào của Máy học . Những mô hình máy học sâu phổ biến (Deep Machine Learning Models) dựa trên đầu vào dữ liệu số, những ký hiệu hoặc cấu trúc rời rạc trước tiên nên được chuyển đổi về dạng biểu diễn số. Embeddings (nhúng, nghe chuối quá, nên mình giữa lại nguyên gốc) biến đổi một ký tự đầu vào thành một vector (mảng nếu 1 chiều, ma trận nếu 2 chiều, tổng quát thì tensor) số học như một biểu diễn đã trở thành sự lựa chọn cho những mô hình máy học. Chúng ta sẽ giải thích những khái niệm này và mối quan hệ của nó với đồ thị tri thức bằng cách lấy ví dụ về word embeddings và graph embeddings. . Word embeddings được phát triển cho việc tính toán độ tương đồng giữa những từ. Để hiểu word embeddings, chúng ta xem xét một tập những câu sau đây: . I like knowledge graphs. . I like databases. . I enjoy running. . Trong những câu trong tập hợp trên, chúng ta sẽ đếm xem một từ xuất hiện kế bên một từ cách bao nhiêu lần và lưu lại kết quả vào một ma trận. Ví dụ, từ I xuất hiện kế bên từ like hai lần, kế bên từ enjoy một lần và không lần với tất cả những từ còn lại .                   . counts | I | like | enjoy | knowledge | graphs | databases | running | . | . I | 0 | 2 | 1 | 0 | 0 | 0 | 0 | 0 | . like | 2 | 0 | 0 | 1 | 0 | 1 | 0 | 0 | . enjoy | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | . knowledge | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | . graphs | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | . databases | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1 | . running | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | . . | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 0 | . Chúng ta nói rằng ý nghĩa của mỗi từ được biểu diễn bởi vector dòng tương ứng với từ đó. Để tính toán độ tương đồng giữa các từ, chúng ta có thể dễ dàng tính toán độ tương đồng giữa những vectors tương ứng với chúng. Trong thực tế, chúng ta quan tâm trong văn bản mà có thể chứa hàng triệu từ và hy vong có biểu diễn thể biểu diễn gọn hơn. Vì ma trận trên là một ma trận thưa, chúng ta có thể sử dụng những kỹ thuật từ Đại số Tuyến tính (như, SVD - singular value decompsition) để giảm chiều dữ liệu. Kết quả cho ra vector tương ứng với từ được gọi là word embedding. Thông thường thì word embedding sử dụng trong ngày nay dựa trên những vectors có độ dài khoảng 200. . Có rất nhiều biến thể và phần mở rộng của ý tưởng cơ bản được trình bày ở đây. Các kỹ thuật tồn tại để tự động học word embedding cho bất kỳ văn bản nhất định nào. . Việc sử dụng word embedding cải thiện hiệu suất của rất nhiều tác vụ Xử lý ngôn ngữ tự nhiên bao gồm rút trích thực thể (entity extraction), rút trích quan hệ (relation extraction), phân tích cú pháp (parsing), truy xuất văn bản (passage retrieval), … Một trong những ứng dụng phổ biến nhất của word embedding là trong tự động hoàn thành các câu truy vấn tìm kiếm. Word embedding cung cấp cho chúng ta một cách dễ dàng trong việc dự đoán các từ có khả năng tuần theo truy vấn một phần mà người dùng nhập . Một văn bản là một chuỗi của những từ, và word embeddings tính toán đồng hiện (co-occurrences) cửa những từ trong đó, chúng ta có thể quan sát văn bản như một đồ thị tri thức mà mỗi từ là một nút (node) và những cạnh liên kết có hướng giữa mỗi từ này với từ khác. Graph Embeddings tổng quát hoá khái niệm này cho một cấu trúc mạng tổng quát. Mục đích và tiếp cận, tuy nhiên vẫn tiếp tục giống nhau: biểu diễn mỗi node trong một đồ thị tri thức bởi một vector, do đó độ tương đồng giữa những node có thể được tính toán như một hiệu giữa các vector tương ứng với chúng. Những vector cho mỗi node được gọi là Graph Embeddings . Để tính toán knowledge graph embedding, chúng ta định nghĩa một phương thức cho việc mã hoá mỗi nút trong một đồ thị thành một vector, một hàm để tính toán độ tương đồng giữa những nút (node), sau đó tối ưu hàm mã hoá (encoding function). Việc mã hoá một nút thành một vector được gọi là node embedding . Một hàm mã hoá có thể được sử dụng là random-walk của đồ thị tri thức (thường là 32 đến 64 random-walk) và tính toán đếm đồng hiện của những node trong đồ thị tri thức tạo ra một ma trận tương tự như đếm đồng hiện của những từ trong văn bản. Có rất nhiều phương pháp cơ bản để tính toán knowledge graph embedding. Giống như chúng ta muốn mã hoá một node thành một vector, chúng ta cũng có thể mã hoá toàn bộ đồ thị thành một vector, mà được hiểu là graph embedding. Ở đây có nhiều tiếp cận tính toán graph embedding, nhưng có lẽ tiếp cận đơn giản nhất là thêm vector cho mỗi node trong đồ thị và thu được một vector biểu diễn cho toàn bộ đồ thị. . Giải thích graph embedding bằng cách giải tính word embedding trước tiên là cách dễ nhất để hiểu chúng và cách sử dụng của chúng. Graph Embedding là một trường hợp tổng quát cho word embeddings. Chúng là một con đường để một đầu vào tri thức thể hiện trong một đồ thị tri thức vào một thuật toán Máy học. Graph Embeddings không quy nạp biểu diễn tri thức, mà là cách biến biểu diễn ký hiệu thành biểu diễn số để dùng cho một thuật toán Máy học. . Chúng ta tính toán knowledge graph embeddings một lần, chúng có thể được sử dụng cho rất nhiều ứng dụng. Một cách sử dụng rõ ràng của knowledge graph embeddings được tính toán từ đồ thị tình bạn là giới thiệu những người bạn mới. Một nhiệm vụ nâng cao hơn liên quan đến dự đoán liên kết (tức là khả năng liên kết giữa hai nút). Dự đoán liên kết trong biểu đồ công ty có thể được sử dụng để xác định khách hàng mới tiềm năng. . 5. Tổng kết . Đồ thị là một cấu trúc cơ bản trong Toán học Rời Rạc (Discrete Mathematics) và có nhiều ứng dụng trong nhiều lĩnh vực của Khoa học Máy tính (Computer Science). Công dụng đáng chú ý của đồ thị trong biểu diễn tri thức và cơ sở dữ liệu tri thức ở dạng dữ liệu đồ thị (data graphs), taxonomies, ontologies. Một cách truyền thống, những ứng dụng như thế này dựa trên thiết kế top down. Như một đồ thị tri thức (knowledge graph) là một đồ thị hữu hướng được gán nhãn (Directed Labeled Graphs), chúng ta có thể tận dụng lý thuyết. thuật toán và cài đặt từ nhiều hệ thống dựa trên đồ thị trong Khoa học Máy tính. . Sự gia tăng gần đây trong việc sử dụng đồ thị tri thức dựa trên ba tiến bộ khác nhau: . - (1) Dữ liệu liên kết và chia sẻ trên web . - (2) Tính toán đồ thị trên dữ liệu . - (3) Những quá trình trong Xử lý ngôn ngữ tự nhiên và Thị giác để rút trích quan hệ từ văn bản và hình ảnh . Một điểm chung giữa ba tiến bộ này là quy mô. Đồ thị tri thức hiện nay có quy mô chưa từng có. Chúng ta đã chú nhận thấy rằng một phiên bản gần đây của Wikidata đã có hơn 80 triệu đối tượng, và hơn 1 tỉ quan hệ. Nhiều đồ thị tri thức công nghiệp ngày càng lớn hơn, lấy ví dụ như, một phiên bản gần đây của đồ thị tri thức Google đã có hơn 570 triệu thực thể, và hơn 18 tỉ quan hệ. Quy mô lớn của đồ thị tri thức tạo ra sự hiệu quả và khả năng mở rộng của các thuật toán đồ thị là điều tối quan trọng. . Việc tổ chức thông tin trên web, và trong nhều ứng dụng tích hợp dữ liệu, nó thật sự khó để đưa ra một thiết kế top-down của một lược đồ. Các ứng dụng Máy học dựa trên dữ liệu có sẵn mà có thể dự đoán hữu ích từ nó. Những sử dụng bottom-up của đồ thị tri thức không làm giảm giá trị của thiết kế từ trên xuống của lược đồ hoặc ontology. Thật vậy, dự án Wikidata tận dụng các ontology. để đảm bảo chất lượng dữ liệu, và hầu hết các dự án tích hợp dữ liệu doanh nghiệp ủng hộ việc xác định lược đồ trên cơ sở cần thiết. Ứng dụng Máy học cũng hưởng lợi ích đáng kể với việc sử dụng nguồn onotology dồi dào cho việc tạo ra các suy diễn từ thông tin mà đã học được cho dù một ontology toàn cục hay một lược đồ không yêu cầu ngay từ đầu. . Word-Embeddings và Graph-Embedding tận dụng cấu trúc một đồ thị trong dữ liệu đầu vào, nhưng chúng cần phải tổng quát hơn đồ thị tri thức ở chỗ không rõ ràng và rõ ràng cho một lược đồ hay một ontology. Ví dụ, graph embeddings có thể được sử dụng trên khắp mạnh được định nghĩa bởi trao đổi gói tin giữa các nút trên mạng Internet, và sau đó được sử dụng trong các thuật toán máy học để dự đoán các nút mạo danh. Ngược lại, với đồ thị tri thức Wikidata, đồ thị tri thức trong doanh nghiệp, và trong biểu diễn đầu ra của các thuật toán máy học, một lược đồ hay ontology có thể đóng vai trò trung tâm. . Chúng ta kết lại bằng cách quan sát sự gia tăng quan tâm về đồ thị tri thức gần đây chủ yếu được thúc đẩy bởi các yêu cầu bottom-up của một số ứng dụng kinh doanh hấp dẫn. Đồ thị tri thức trong những ứng dụng này có thể chắn chắn hưởng lợi ích từ những công trình kinh điển từ những kỹ thuật thiết kế biểu diễn top-down, và thực tế, chúng ta có thể hình dung rằng cả hai hướng này sẽ cùng hội tụ với nhau. . Bài tập: . …Sẽ cập nhật sau… . Bài giảng gốc: https://web.stanford.edu/class/cs520/2020/notes/What_is_a_Knowledge_Graph.html .",
            "url": "https://nhutnamhcmus.github.io/lenux-notebooks/2021/06/25/what-is-knowledge-graph.html",
            "relUrl": "/2021/06/25/what-is-knowledge-graph.html",
            "date": " • Jun 25, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://nhutnamhcmus.github.io/lenux-notebooks/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://nhutnamhcmus.github.io/lenux-notebooks/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": ". My full name is Le Nhut Nam (Vietnamese format). I am a junior student who majoring in Computer Science at the VNU-HCM, University of Science. . My fields of interest are Data Science and Computer Vision especially in Digital Image &amp; Video processing. Currently, I’m focusing on research Graph Theory, Graph Convolution Neural Networks. . Besides that, I also learn some new technologies by watching Youtube, reading articles, etc. I have a good knowledge about C/C++, Python 3. . Aside from that, I also know basics concept in Java, but I do not use it much, but it is a mandatory programming language in my curriculum so I can review it quickly for working purposes. My foreign language skill is not quite excellent at all but I think I have a good skill at reading &amp; listing. I like to making friends and drink coffee. . This website is powered by fastpages 1 and its content can be written in English or Vietnamese depend on me. I just want to share what I learned, found and researched during my working. I hope these articles can be someone who gets stuck in the field which I am researching. ^^! . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://nhutnamhcmus.github.io/lenux-notebooks/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://nhutnamhcmus.github.io/lenux-notebooks/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}
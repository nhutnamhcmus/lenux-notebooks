<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>How To Create A Knowledge Graph From Text | Lenux Notebooks</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="How To Create A Knowledge Graph From Text" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="ĐỒ THỊ TRI THỨC - KNOWLEDGE GRAPH" />
<meta property="og:description" content="ĐỒ THỊ TRI THỨC - KNOWLEDGE GRAPH" />
<link rel="canonical" href="https://nhutnamhcmus.github.io/lenux-notebooks/2021/06/27/how-to-create-a-knowledge-graph-from-text.html" />
<meta property="og:url" content="https://nhutnamhcmus.github.io/lenux-notebooks/2021/06/27/how-to-create-a-knowledge-graph-from-text.html" />
<meta property="og:site_name" content="Lenux Notebooks" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-06-27T00:00:00-05:00" />
<script type="application/ld+json">
{"url":"https://nhutnamhcmus.github.io/lenux-notebooks/2021/06/27/how-to-create-a-knowledge-graph-from-text.html","@type":"BlogPosting","headline":"How To Create A Knowledge Graph From Text","dateModified":"2021-06-27T00:00:00-05:00","datePublished":"2021-06-27T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://nhutnamhcmus.github.io/lenux-notebooks/2021/06/27/how-to-create-a-knowledge-graph-from-text.html"},"description":"ĐỒ THỊ TRI THỨC - KNOWLEDGE GRAPH","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/lenux-notebooks/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://nhutnamhcmus.github.io/lenux-notebooks/feed.xml" title="Lenux Notebooks" /><link rel="shortcut icon" type="image/x-icon" href="/lenux-notebooks/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/lenux-notebooks/">Lenux Notebooks</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/lenux-notebooks/about/">About Me</a><a class="page-link" href="/lenux-notebooks/search/">Search</a><a class="page-link" href="/lenux-notebooks/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">How To Create A Knowledge Graph From Text</h1><p class="post-meta post-meta-title"><time class="dt-published" datetime="2021-06-27T00:00:00-05:00" itemprop="datePublished">
        Jun 27, 2021
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      27 min read
    
</span></p>

    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul class="section-nav">
<li class="toc-entry toc-h1"><a href="#how-to-create-a-knowledge-graph-from-text">HOW TO CREATE A KNOWLEDGE GRAPH FROM TEXT</a>
<ul>
<li class="toc-entry toc-h2"><a href="#1-giới-thiệu">1. Giới thiệu</a></li>
<li class="toc-entry toc-h2"><a href="#2-tổng-quan-về-mô-hình-ngôn-ngữ---overview-of-language-models">2. Tổng quan về mô hình ngôn ngữ - Overview of Language Models</a></li>
<li class="toc-entry toc-h2"><a href="#3-rút-trích-thực-thể---entity-extraction">3. Rút trích thực thể - Entity Extraction</a>
<ul>
<li class="toc-entry toc-h3"><a href="#31-ví-dụ-về-rút-trích-thực-thể---an-example-of-entity-extraction">3.1 Ví dụ về rút trích thực thể - An Example of Entity Extraction</a></li>
<li class="toc-entry toc-h3"><a href="#32-những-phương-pháp-tiếp-cận-cho-rút-trích-thực-thể---approaches-to-entity-extraction">3.2 Những phương pháp tiếp cận cho rút trích thực thể - Approaches to Entity Extraction</a></li>
<li class="toc-entry toc-h3"><a href="#33-những-thách-thức-trong-rút-trích-thực-thể---challenges-in-entity-extraction">3.3 Những thách thức trong rút trích thực thể - Challenges in Entity Extraction</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#4-rút-trích-quan-hệ---relation-extraction">4. Rút trích quan hệ - Relation Extraction</a>
<ul>
<li class="toc-entry toc-h3"><a href="#41-ví-dụ-về-rút-trích-quan-hệ---examples-of-relation-extraction">4.1 Ví dụ về rút trích quan hệ - Examples of Relation Extraction</a></li>
<li class="toc-entry toc-h3"><a href="#42-những-phương-pháp-tiếp-cận-cho-rút-trích-quan-hệ---approaches-to-relation-extraction">4.2 Những phương pháp tiếp cận cho rút trích quan hệ - Approaches to Relation Extraction</a></li>
<li class="toc-entry toc-h3"><a href="#43-những-thách-thức-trong-rút-trích-quan-hệ">4.3 Những thách thức trong rút trích quan hệ</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#5-tổng-kết">5. Tổng kết</a></li>
</ul>
</li>
</ul><p><strong>ĐỒ THỊ TRI THỨC - KNOWLEDGE GRAPH</strong></p>

<table>
  <tbody>
    <tr>
      <td>Đây là bản dịch từ Course CS520: Knowledge Graphs</td>
      <td>Data Models, Knowledge Acquisition, Inference and Applications</td>
    </tr>
  </tbody>
</table>

<p>Department of Computer Science, Stanford University, Spring 2021</p>

<p>Knowledge graphs have emerged as a compelling abstraction for organizing world’s structured knowledge over the internet, capturing relationships among key entities of interest to enterprises, and a way to integrate information extracted from multiple data sources. Knowledge graphs have also started to play a central role in machine learning and natural language processing as a method to incorporate world knowledge, as a target knowledge representation for extracted knowledge, and for explaining what is being learned. This class is a graduate level research seminar and will include lectures on knowledge graph topics (e.g., data models, creation, inference, access) and invited lectures from prominent researchers and industry practitioners. The seminar emphasizes synthesis of AI, database systems and HCI in creating integrated intelligent systems centered around knowledge graphs.</p>

<p>Mục đích: Là tìm hiểu cũng như trau dồi kiến thức chuyên môn trong lĩnh vực Knowledge Graph cũng như từ vựng tiếng Anh. Không vì mục đích kinh doanh hay bất cứ mục đích về lợi nhuận, tất cả là vì mục đích chia sẻ kiến thức và học tập.</p>

<p>Mọi thông tin về những chủ đề được note lại có thể tìm thấy ở đây:</p>

<p>https://web.stanford.edu/class/cs520/2020/notes/Table_Of_Contents.html</p>

<p>Video của các buổi seminar trên địa chỉ Youtube:</p>

<p>https://www.youtube.com/playlist?list=PLDhh0lALedc5paY4N3NRZ3j_ui9foL7Qc</p>

<p>Mọi vấn đề về dịch thuật, thuật ngữ xin để lại comment hoặc gửi về địa chỉ email: lenam.fithcmus@gmail.com với tiêu đề</p>

<p>[ISSUES OF KG TRANSLATION]</p>

<h1 id="how-to-create-a-knowledge-graph-from-text">
<a class="anchor" href="#how-to-create-a-knowledge-graph-from-text" aria-hidden="true"><span class="octicon octicon-link"></span></a>HOW TO CREATE A KNOWLEDGE GRAPH FROM TEXT</h1>

<p><strong>LÀM THẾ NÀO KHỞI TẠO MỘT ĐỒ THI TRI THỨC TỪ VĂN BẢN</strong></p>

<h2 id="1-giới-thiệu">
<a class="anchor" href="#1-gi%E1%BB%9Bi-thi%E1%BB%87u" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. Giới thiệu</h2>

<p>Những nguồn dữ liệu văn bản giống như tin tức kinh doanh và tài chính, những hồ sơ SEC, và những trang web như Wall Street Journal, chứa thông tin có giá trị cao cho những tác vụ kinh doanh như nghiên cứu thị trường - market research, kinh doanh thông minh - business intelligence, … Chúng ta có thể sử dụng Xử lý ngôn ngữ tự nhiên (Natural Language Processing -NLP) để xử lý những nguồn dữ liệu, và khởi tạo đồ thị tri thức để có thể hỗ trợ nhiều loại phân tích. Tuy nhiên, NLP là một công nghệ chuyên biệt (specialized) và rất phức tạp (sophisticated) và mục đích của chúng ta không phải cung cấp một phạm vi toàn diện và chi tiết về nó. Mục đích của chúng ta ở đây là dựa vào những khái niệm cơ sở của NLP mà có thể hữu ích trong nhiều mối quan tâm chính và mục tiêu chính vẫn là khởi tạo một đồ thị tri thức. Một số nhà cung cấp đã tạo ra các dịch vụ kinh doanh xoay quanh việc xử lý văn bản ngôn ngữ tự nhiên và cung cấp dữ liệu có cấu trúc cho những người khác để tiêu thụ.</p>

<p>Có ba tác vụ Xử lý ngôn ngữ tự nhiên - NLP task liên hệ trực tiếp đến xây dựng đồ thị tri thức (knowledge graph construction):</p>

<p>- (1) Entity Extraction - Rút trích thực thể</p>

<p>- (2) Relation Extraction - Rút trích quan hệ</p>

<p>- (3) Entity Resolution - Phân giải thực thể</p>

<p>Entity Extraction - Rút trích thực thể là tác vụ định danh những thực thể chính (key entities) được quan tâm (ví dụ: Organizations - Tổ chức, People - Con người, Place - Nơi chốn, …) từ văn bản. Những thực thể này thông thường tạo nên nút (node) trong một đồ thị tri thức.</p>

<p>Relation Extraction - Rút trích quan hệ là tác vụ mà khi được cho hai thực thể quan tâm, và một số văn bản, chúng rút trích ra những quan hệ giữa chúng (ví dụ: net sales, management team information, … ) từ văn bản. Thỉnh thoảng, rút trích quan hệ cũng được dùng để rút trích những thuộc tính của một thực thể được cho trước. Mối quan hệ và những thuộc tính được rút trích thông thường sẽ trở thành những mối quan hệ hoặc những thuộc tính nút trong đồ thị tri thức của chúng ta.</p>

<p>Entity Resolution - Phân giải thực thể là tác vụ định danh xem nhiều đề cập trong một văn bản có tham chiếu đến cùng một thực thể hay không. Ví dụ như, trong một đoạn văn bản, “John Smith”, “He” và “Her father” có thể tất cả cùng tham chiếu đến cùng một thực thể.</p>

<p>Trong chương này, chúng ta sẽ tìm hiểu một cái nhìn tổng quan về những kỹ thuật được sử dụng trong rút trích thực thể (Entity Extraction ) và quan hệ (Relation Extraction). Chúng ta sẽ không thảo luận về phân giải thực thể - entity resolution trong phần thảo luận này bởi vì nó là một đề tài nâng cao so với phạm vi trình bày hiện tại :)) Hầu hết những kỹ thuật cho rút trích thực thể và quan hệ, mà phổ biến hiện nay, dựa trên điều chỉnh với một mô hình ngôn ngữ được huấn luyện từ trước (pre-trained language model) trong tác vụ đang được thực hiện. Với mục đích của chúng ta, chúng ta coi những mô hình ngôn ngữ được huấn luyện từ trước (pre-trained language model) và những kỹ thuật máy học (machine learning techniques) như những chiếc hộp đen có sẵn để sử dụng như những món hàng bán sẵn ngoài chợ (off-the-shelf commodities). Quá trình này trong Xử lý ngôn ngữ tự nhiên - NLP và Máy học - Machine Learning cho phép những người tạo ra đồ thị tri thức tập trung vào sản phẩm cuối cùng, và cung cấp những dữ liệu huấn luyện và đánh giá thích hợp mà cần thiết cho sự điều chỉnh của mô hình ngôn ngữ (language models). Chúng ta sẽ bắt đầu với một tổng quan về mô hình ngôn ngữ và sao đó mô tả chi tiết các tác vụ rút trích thực thể và rút trích quan hệ.</p>

<h2 id="2-tổng-quan-về-mô-hình-ngôn-ngữ---overview-of-language-models">
<a class="anchor" href="#2-t%E1%BB%95ng-quan-v%E1%BB%81-m%C3%B4-h%C3%ACnh-ng%C3%B4n-ng%E1%BB%AF---overview-of-language-models" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. Tổng quan về mô hình ngôn ngữ - Overview of Language Models</h2>

<p>Mô hình ngôn ngữ là tác vụ dự đoán xem từ nào xuất hiện kế tiếp trong một văn bản. Ví dụ, cho một câu: “students opened their”, một mô hình ngôn ngữ sẽ dự đoán từ kế tiếp mà có thể hoàn thành câu này. Trong trường hợp này, từ kế tiếp có thể là book, exam, laptop, …</p>

<p>Tổng quát hơn, cho một tập hợp những từ $x_1, x_2, …, x_{n-1}$, một mô hình ngôn ngữ dự đoán xác suất $P(x_n \|\ x_1, x_2, …, x_{n-1})$, trong đó $x_n$ là một từ bất kỳ trong bộ từ vựng. Mô hình ngôn ngữ có thể được sử dụng rỗng rãi trong tự động hoàn thành yêu cầu tìm kiếm trên web, trong tự động chỉnh sửa từ trong xử lý từ, …</p>

<p>Mô hình ngôn ngữ hiện đại được tạo ra bằng cách huấn luyện một mô hình Học sâu (Deep Learning Model), như là Recurring Neural Network, trên một kho ngữ liệu văn bản cực lớn. Nhiều biến thể của các mô hình ngôn ngữ được huấn luyện trướccó sẵn như những sản phẩm mã nguồn mở có thể được tinh chỉnh cho mục đính của những tác vụ xác định đang thực hiện. Vì chúng ta đang thảo luận những kỹ thuật cho rút trích thực thể và rút trích quan hệ, chúng ta cũng sẽ mô tả làm thế nào mà mô hình ngôn ngữ có thể được tinh chỉnh cho những tác vụ này.</p>

<h2 id="3-rút-trích-thực-thể---entity-extraction">
<a class="anchor" href="#3-r%C3%BAt-tr%C3%ADch-th%E1%BB%B1c-th%E1%BB%83---entity-extraction" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. Rút trích thực thể - Entity Extraction</h2>

<p>Chúng ta sẽ bắt đầu bằng cách xem xét một ví dụ cụ thể về rút trích thực thể và sau đó tìm hiểu tổng quan những cách tiếp cận khác nhau cho rút trích thực thể và kết lại phần này bằng thảo luận về một số thách thức trong việc thực hiện tốt ở tác vụ này.</p>

<h3 id="31-ví-dụ-về-rút-trích-thực-thể---an-example-of-entity-extraction">
<a class="anchor" href="#31-v%C3%AD-d%E1%BB%A5-v%E1%BB%81-r%C3%BAt-tr%C3%ADch-th%E1%BB%B1c-th%E1%BB%83---an-example-of-entity-extraction" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.1 Ví dụ về rút trích thực thể - An Example of Entity Extraction</h3>

<p>Chúng ta hãy xem xét một mẫu văn bản nhỏ từ một câu chuyện tin tức sau đây:</p>

<p>Cecilia Love, 52, a retired police investigator who lives in Massachusetts, said she paid around $370 a ticket with tax for nonstop United Airlines flights to Sacramento from Boston for her niece’s high school graduation in June, 2020.</p>

<p>Chúng ta sẽ xem xét những thực thể named trong đoạn văn bản phía trên. Một thực thể named là bất cứ thứ gì có thể được tham chiều với một tên thích hợp: a person - một người, a location - một địa điểm, an organization - một tổ chức, … Việc xác định một thực thể được đặt tên thường được mở rộng để bao gồm những thứ không phải là thực thể, bao gồm ngày, giờ và các loại biểu thức khác liên quan đến thời gian và thậm chí cả biểu thức số học, ví dụ: giá</p>

<p>[<sub>PER</sub>Cecilia Love], 52, a retired police investigator who lives in [<sub>LOC</sub>New Jersey], said she paid around [MONEY $370] a ticket with tax for nonstop [<sub>ORG</sub>United Airlines] flight to [<sub>LOC</sub>Sacramento] from [<sub>LOC</sub>Boston] for her niece’s high school graduation in [<sub>TIME</sub> June, 2020].</p>

<p>Đoạn văn bản chứa 7 thực thể được đặt tên, một trong số đó là một người - a person (được chỉ định bởi PER), ba trong số đó là địa điểm - location (được chỉ định bởi LOC), một trong số đó là tiền - money (được chỉ định bởi MONEY), một trong đó là tổ chức - organization (được chỉ định bởi ORG) và một trong đó là thời gian - time (được chỉ định bởi TIME). Phục thuộc vào phạm vi của ứng dụng, chúng ta có thể thêm nhiều hơn hoặc ít hơn những kiểu thuộc tính được đặt tên. Ví dụ, trong tác vụ định danh những thuật ngữ khoá trong một văn bản, chỉ có một loại thực thể biểu diễn một cụm từ khóa.</p>

<p>Tác vụ rút trích thực thể hữu ích trong nhiều ứng dụng. Ví dụ như, trong trả lời câu hỏi - question answering, nó có thể giúp lấy ra câu trả lời từ một đoạn văn bản được truy xuất. Trong một ứng dụng xử lý từ, nó có thể giúp trong liên kết một cách tự động những thực thể xuất hiện trong văn bản với những thông tin được thêm vào (như định nghĩa, dữ kiện, …) về những thực thể đó.</p>

<h3 id="32-những-phương-pháp-tiếp-cận-cho-rút-trích-thực-thể---approaches-to-entity-extraction">
<a class="anchor" href="#32-nh%E1%BB%AFng-ph%C6%B0%C6%A1ng-ph%C3%A1p-ti%E1%BA%BFp-c%E1%BA%ADn-cho-r%C3%BAt-tr%C3%ADch-th%E1%BB%B1c-th%E1%BB%83---approaches-to-entity-extraction" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.2 Những phương pháp tiếp cận cho rút trích thực thể - Approaches to Entity Extraction</h3>

<p>Đầu tiên và quan trọng nhất, chúng ta có thể xem rút trích thực thể như một vấn đề gán nhãn. Chúng ta liên hệ một nhãn (label) với mỗi từ, và tác vụ này trở thành việc dự đoán nhãn. Chúng ta có thể thực hiện rút trích thực thể bằng ba phương pháp tiếp cận:</p>

<p>- (1) Sequence labeling</p>

<p>- (2) Deep Learning Models</p>

<p>- (3) Rule-based Approaches</p>

<p>Chúng ta sẽ điểm qua từng phương pháp tiếp cận một</p>

<p>Để tạo điều kiện cho việc gán nhãn, chúng ta thêm vào một lược đồ gán nhãn được biết đến với tên là BIOES trong đó</p>

<p>- B đại diện cho the beginning of an entity - Bắt đầu một thực thể</p>

<p>- I đại diện cho the interior of an entity - Nội dung của một thực thể</p>

<p>- O đại diện cho a word that is not part of an entity - Một từ không nằm trong một thực thể</p>

<p>- E đại diện cho the end of an entity - Kết thúc một thực thể</p>

<p>- S đại diện cho a single word entity - Một từ đơn mô tả thực thể</p>

<p>Lấy một ví dụ, những trong đoạn văn bản phía trên sẽ được gán nhãn như bảng được cho ở bên dưới</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Cecilia</td>
      <td>B</td>
      <td>Love</td>
      <td>E</td>
      <td>,</td>
      <td>O</td>
      <td>52</td>
      <td>O</td>
      <td>,</td>
      <td>O</td>
    </tr>
    <tr>
      <td>a</td>
      <td>O</td>
      <td>retired</td>
      <td>O</td>
      <td>police</td>
      <td>O</td>
      <td>investigator</td>
      <td>O</td>
      <td>who</td>
      <td>O</td>
    </tr>
    <tr>
      <td>lives</td>
      <td>O</td>
      <td>in</td>
      <td>O</td>
      <td>Massachusetts</td>
      <td>S</td>
      <td>,</td>
      <td>O</td>
      <td>said</td>
      <td>O</td>
    </tr>
    <tr>
      <td>she</td>
      <td>O</td>
      <td>paid</td>
      <td>O</td>
      <td>around</td>
      <td>O</td>
      <td>$370</td>
      <td>S</td>
      <td>a</td>
      <td>O</td>
    </tr>
    <tr>
      <td>ticket</td>
      <td>O</td>
      <td>with</td>
      <td>O</td>
      <td>tax</td>
      <td>O</td>
      <td>for</td>
      <td>O</td>
      <td>nonstop</td>
      <td>O</td>
    </tr>
    <tr>
      <td>Untied</td>
      <td>B</td>
      <td>Airlines</td>
      <td>E</td>
      <td>flights</td>
      <td>O</td>
      <td>to</td>
      <td>O</td>
      <td>Sacramento</td>
      <td>S</td>
    </tr>
    <tr>
      <td>from</td>
      <td>O</td>
      <td>Boston</td>
      <td>S</td>
      <td>for</td>
      <td>O</td>
      <td>her</td>
      <td>O</td>
      <td>niece’s</td>
      <td>O</td>
    </tr>
    <tr>
      <td>high</td>
      <td>O</td>
      <td>school</td>
      <td>O</td>
      <td>graduation</td>
      <td>O</td>
      <td>in</td>
      <td>O</td>
      <td>June</td>
      <td>B</td>
    </tr>
    <tr>
      <td>,</td>
      <td>I</td>
      <td>2020</td>
      <td>E</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>Với phương pháp tiếp cận Sequence Labeling - Chuỗi gán nhãn, chúng ta huấn luyện một thuật toán máy học (Machine Learning Algorithm), ví dụ như Conditional Random Fields - Trường điều kiện ngẫu nhiên), sử dụng những đặc trưng (features) như: part of speech - đoạn giọng nói, presence of the word in a list of standard words - hiện diện của một từ trong một danh sách từ chuẩn hoá, word embeddings, word base form, từ liệu có chứa một tiền tố (prefix) hay hậu tố (suffix), liệu từ có được in hoa toàn bộ, … Cần có sự nổ lực đáng để trong Feature Engineering - Kỹ thuật đặc trưng, bởi vì hiệu suất của việc lựa chọn những đặc trưng cụ thể và thuật toán máy học có thể thay đổi bởi phạm vi xem xét.</p>

<p>Với phương pháp tiếp cận Deep Learning - Học Sâu, ở đây không cần những kỹ thuật đặc trưng - feature engineering, và chúng ta đơn giản đưa word embeddings vào một mô hình ngôn ngữ (language model). Thay vì dự đoán xem từ kế tiếp là gì, mô hình ngôn ngữ bây giờ dự đoán một trong năm nhãn (tag) (B, I, O, E, S) cần cho việc nhận dạng thực thể (entity recognition). Để điều chính mô hình ngôn ngữ cho một tác vụ mới, đầu tiên chúng là huấn luyện trước nó sử dụng kho ngữ liệu cho miền đang xem xét, và sau đó huấn luyện nó cho tác vụ đang thực hiện. Trong những tác vụ xác định của mô hình ngôn ngữ, chúng ta cung cấp quá trình huấn luyện bằng cách thêm một token phân biệt (distinguished token) [CLS] mà đại diện cho điểm bắt đầu một thực thể (the beginning of an entity), và một token phân biệt thứ hai [SEP] đại diện cho điểm kết thúc một thực thể (the end of an entity). Quá trình huấn luyện cho phép mô hình dự đoán những nhãn phân biệt (distinguished tags) này để phản hồi một văn bản đầu vào. Những dự đoán như vậy là đủ cho chúng ta để tạo ra một trong năm nhãn cho mỗi từ.</p>

<p>Cuối cùng, với phương pháp tiếp cận Rule-Based - Dựa trên luật, một luật gán nhãn xác định (ne specifies labeling rules) trong một ngôn ngữ truy vấn hình thức (formal query language). Những luật này có thể bao gồm regular expression - biểu thức chính quy, references to dictionaries - tham chiếu tư điển, semantic constraints - ràng buộc ngữ nghĩa, và cũng có thể liên qua để bộ tự động rút trích và những cấu trúc bảng tham chiếu. Những luật này cũng có thể liên quan đến những module máy học cho những tác vụ cụ thể. Áp dụng luật có thể là một chuỗi trình tự theo cách mà đầu tiên chúng ta sử dụng những luật có precision cao (high precision rules), sau đó là tra cứu trong một danh sách tên chuẩn hoá, sau đó là dựa trên kinh nghiệm ngôn ngữ - language-based heuristics, và nếu sau tất cả đều thất bại, thì dùng để những kỹ thuật máy học xác suất (probabilistic machine learning techniques)</p>

<h3 id="33-những-thách-thức-trong-rút-trích-thực-thể---challenges-in-entity-extraction">
<a class="anchor" href="#33-nh%E1%BB%AFng-th%C3%A1ch-th%E1%BB%A9c-trong-r%C3%BAt-tr%C3%ADch-th%E1%BB%B1c-th%E1%BB%83---challenges-in-entity-extraction" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.3 Những thách thức trong rút trích thực thể - Challenges in Entity Extraction</h3>

<p>Mặc dù với những tác vụ xác định, các bộ rút trích thực thể (entity extractors) có thể cho thấy precision và recall trên 90% nhưng đạt được một hiệu suất tốt qua tất cả những miền (across all the domains) có thể là một thách thức. Trong phần này, chúng ta đề cập một thách thức mà chúng ta phải đối mặt trong quá trình rút trích thực thể .</p>

<p>Trong khi gán nhãn quan hệ với lớp của chúng, có rất nhiều trường hợp nhập nhằng (numerous cases of ambiguity). Ví dụ như, cho một thực thể Louis Vuitton, nó có thể tham chiếu đến một người - a person, hoặc một tổ chức - an organization, hoặc sản phẩm thương mai - am commercial product. Không thể giải quyết những vấn đề như sự nhập nhằng nếu như không tính đến ngữ cảnh một cách đáng kể.</p>

<p>Với cách sử dụng một mô hình học máy (machine learning model), chúng ta lượng dữ liệu cực kỳ to lớn. Trong thực tế, dữ liệu thường không có sẵn hoặc phần lớn chúng chưa hoàn thiện. Khi chúng ta huấn luyện mô hình sử dụng dữ liệu không hoàn thiện, nó sẽ ảnh hưởng nghiêm trọng đến hiệu suất.</p>

<p>Một trong những biến thể của rút trích thực thể là định danh những cụm từ khoá trong văn bản. Vì những cụm từ khoá là không giới hạn ở một số lớp, tác vụ định danh những lớp xác định tương ứng với một cụm từ khoá có thể trở nên thách thức hơn. Thỉnh thoảng, những cụm từ khoá quá phức tạp (overly complex) (ví dụ: duplication of a cell by fission), và đôi khi quá chung chung (too general) (ví dụ như: Attach) làm cho tác vụ này quá khó để mà áp dụng một kỹ thuật thống nhất trên diện rộng.</p>

<p>Những thực thể có thể xuất hiện ở nhiều hình dạng khác nhau (different surface forms), ví dụ như: synonyms - từ đồng nghĩa, acronyms - từ viết tắt, plurals - dạng số nhiều và morphological variations - các biến thể hình thái :)))))))))????. Nói chung, rút trích thực thể cần chú trọng về tri thức từ vựng (lexical knowledge) mà thường không tồn tại khi vào một lĩnh vực/ miền mới. Do đó, việc cải thiện hiệu năng của rút trích thực thể, rút trích từ vựng (lexicon extraction) trở thành một tác vụ liên quan thiết yếu.</p>

<h2 id="4-rút-trích-quan-hệ---relation-extraction">
<a class="anchor" href="#4-r%C3%BAt-tr%C3%ADch-quan-h%E1%BB%87---relation-extraction" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. Rút trích quan hệ - Relation Extraction</h2>

<p>Chúng ta sẽ bắt đầu bằng cách đề cặp một vài ví dụ cụ thể về rút trích quan hệ, sau đó tìm hiểu một cách tổng quan về những phương pháp tiếp cận khác nhau cho rút trích quan hệ, và kết lại phần này bằng cách thảo thuận một số thách thức làm sao đạt hiệu suất tốt với tác vụ này.</p>

<h3 id="41-ví-dụ-về-rút-trích-quan-hệ---examples-of-relation-extraction">
<a class="anchor" href="#41-v%C3%AD-d%E1%BB%A5-v%E1%BB%81-r%C3%BAt-tr%C3%ADch-quan-h%E1%BB%87---examples-of-relation-extraction" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.1 Ví dụ về rút trích quan hệ - Examples of Relation Extraction</h3>

<p>Xem xét đoạn văn bản từ phần trước, chúng ta có thể rút trích những quan hệ như Cecilia Love <em>lives</em> in Massachusetts, United Airlines <em>flies</em> from Boston và United Airlines <em>flies</em> to Sacramento, … Trong một tác vụ rút trích quan hệ thông thường, những thực thể đã được định danh trước đó, và trong trường hợp này, nó mở rộng tác vụ rút trích thực thể. Những quan hệ sẽ được rút trích cũng được xác định trước đó.</p>

<p>Một thể hiện thể phổ biến của tác vụ rút trích quan hệ là rút trích những thông tin từ Wikipedia Infoboxes. Ứng dụng rõ ràng của tác vụ này là cải thiện kết quả tìm kiếm trên Internet. Wikipedia infoboxes định nghĩa những mối quan hệ như preceded by, succeeded by, children, spouse, … Đạt được một độ chính xác cao (a high accuracy) đối với tác vụ này có thể là một thách thức bởi một lượng lớn những trường khó (corner cases). Ví dụ, Larry King đã kết hôn nhiều lần, do đó bộ rút trích phải có khả năng lấy ra những thông tin khoảng thời gian mà cuộc hôn nhân tồn tại.</p>

<p>Ở đây cũng tồn tại những miền xác định những mối quan hệ. Ví dụ, Unified Medical Language Systems hỗ trợ những mối quan hệ như causes, treats, disrupts, … Ngoại trừ những quan hệ chuẩn hoá như subclass-of, has_part, những mối quan hệ sẽ được rút trích là những miền xác định và thường yêu cầu một số thiết kế từ trước. Có một số phương pháp tiếp cận để rút trích quan hệ mà không yêu cầu lựa chọn những quan hệ từ trước, nhưng tính hữu ích của những phương pháp như vậy trong thực tế được phát hiện là bị giới hạn.</p>

<h3 id="42-những-phương-pháp-tiếp-cận-cho-rút-trích-quan-hệ---approaches-to-relation-extraction">
<a class="anchor" href="#42-nh%E1%BB%AFng-ph%C6%B0%C6%A1ng-ph%C3%A1p-ti%E1%BA%BFp-c%E1%BA%ADn-cho-r%C3%BAt-tr%C3%ADch-quan-h%E1%BB%87---approaches-to-relation-extraction" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.2 Những phương pháp tiếp cận cho rút trích quan hệ - Approaches to Relation Extraction</h3>

<p>Có ba phương pháp diện rộng để rút trích quan hệ:</p>

<p>- (1) syntactic patterns</p>

<p>- (2) various forms of supervised machine learning</p>

<p>- (3) unsupervised machine learning</p>

<p>Như được đề cập từ phần trước, unsupervised machine learning bị giới hạn sử dụng trong thực tế. Do đó chúng ta sẽ xem xét chủ yếu việc sử dụng syntactic patterns và supervised machine learning cho việc rút trích quan hệ.</p>

<p>Một phương pháp tiếp cận kinh điển cho rút trích quan hệ dựa trên syntactic patterns được biết đến như Hearst Patterns. Ví dụ, xem xét câu dưới đây:</p>

<p>The bow lute, such as the Bambara ndang, is plucked and has an individual curved neck for each string.</p>

<p>Cho dù chúng ta chưa từng được nghe đến Bambara ndang, chúng ta vẫn có thể suy luận nó là một loại đàn nguyệt hình cung (a kind of bow lute, lute là một danh từ có nghĩa là đàn nguyệt, đờn tỳ bà, bow: cây cung). Tổng quát hơn, chúng ta có thể định danh syntactic patterns - mẫu cú pháp mà có những chỉ số cao về subclass của mối quan hệ. Năm mẫu cú pháp sau đây đã xuất hiện khá lâu và cực kỳ hiệu quan trong thực tế.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Pattern Name</td>
      <td>Example</td>
    </tr>
    <tr>
      <td>such as</td>
      <td>… works by authors such as Herric, Goldsmith, and Shakespear …</td>
    </tr>
    <tr>
      <td>or other</td>
      <td>Bruises, wounds, broken bones, or other injuries …</td>
    </tr>
    <tr>
      <td>and other</td>
      <td>.. temples, treasuries, and other Civic Buildings, …</td>
    </tr>
    <tr>
      <td>including</td>
      <td>All common law countries including Canada and England …</td>
    </tr>
    <tr>
      <td>especially</td>
      <td>Most European countries especially France, England, and Spain, …</td>
    </tr>
  </tbody>
</table>

<p>Chúng ta có thể khám pháp những mẫu cú pháp mới cho bất kỳ mối quan hệ nào như sau. Đầu tiên, chúng thu gom những mẫu cho mối quan hệ được cho là đúng. Sau đó, chúng ta tìm những câu mà mối quan hệ là đúng. Bằng cách xác định những điểm chung thông qua những câu đó, chúng ta có thể định nghĩa ra được một mẫu mới. Chúng ta có thể kiểm tra những mẫu (patterns) dựa trên kho ngữ liệu. Một thuật toán như thế được gọi là Dual Iterative Pattern Relation Expansion (DIPRE).</p>

<p>Chúng ta cụ thể hoá nguyên lý hoạt động của nó bằng một vấn đề của việc rút trích cặp (author, title) từ một kho ngữ liệu. Chúng ta bắt đầu với một tập các cặp (author, title) đã được biết, và chúng ta tìm tất cả số lần xuất hiện của chúng trong bộ ngữ liệu, và từ những thứ đó chúng ta tạo ra nhiều mẫu hơn. Thuật toán tiếp tục một cách đệ quy bằng cách sử dụng những mẫu mới để khám phá nhiều sách hơn, và từ việc khám phá những mẫu mới của chúng. Một ví dụ cụ thể, cho một cặp (William Shakespear, The Comedy of Errors), và những câu sau:</p>

<p>- The Comedy of Errors, by William Shakespeare, was …</p>

<p>- The Comedy of Errors, by William Shakespeare, is …</p>

<p>- The Comedy of Errors, one of William Shakespeare’s earliest attempts …</p>

<p>- The Comedy of Errors, one of William Shakespeare’s most …</p>

<p>Chúng ta có thể thu được những mẫu (patterns) sau:</p>

<p>- $?x , by ?y$</p>

<p>- $?x , \text{one of } ?y’s$</p>

<p>Bằng cách sử dụng những mẫu mới thu được, quá trình rút trích tiếp tục một cách đệ quy.</p>

<p>Phương pháp tiếp cận supervised - có giám sát cho rút trích quan hệ cần dữ liệu huấn luyện phong phú. Bất cứ khi nào dữ liệu huấn luyện là sẵn có, nhiều thuật toán học có sẵn (the off-tbe-shelf) có thể được huấn luyện. Nhưng, trong trường hợp không đủ dữ liệu, tiếp cận giám sát yếu (weak supervision approaches) trở nên phổ biến để giải quyết yêu cầu về dữ liệu. Ý tưởng cơ bản trong weak supervision là sử dụng nhiều hàm gán nhãn gần đúng (several approximate labeling functions) mà có thể tạo ra dữ liệu huấn luyện một cách tự động. Những nhãn yếu (weak labels) này có thể được kết hợp bằng cách sử dụng một hàm xác suất (probabilistic function)</p>

<p>Một ví dụ về một hàm gán nhãn yếu (a weak labeling function), xem xét quan hệ has_part. Với quan hệ này, nó không có khả năng để phát triển những mẫu cú pháp (syntactic patterns) của loại được đề xuất như trên. Một hàm gán nhãn yếu (weak labeling function) có thể có cho mối quan hệ này là đầu tiên tạo ra một phân tích cú pháp phụ thuộc cho câu, và sau đó tìm kiếm hai node trong phân tích mà có một đường đi chiều dài một chứa động từ has hoặc have. Với mối quan hệ taxonomic (mối quan hệ phân loại), một hàm gán nhãn yếu (weak labeling function) bổ sung nếu hai thực thể kết thúc với cùng một từ cơ sở nhưng một trong chúng có một cụm bổ nghĩa ( additional modifier) đứng trước nó, điều này gợi ý một taxonomic relation (ví dụ như: eukaryotic cell SUBCLASS cell).</p>

<p>Để điều chỉnh một mô hình ngôn ngữ cho tác vụ rút trích quan hệ, chúng ta thay đổi biểu diễn đầu vào của một câu để mà mỗi một thuật ngữ cá thể được đánh dấu một cách rõ ràng. Ví dụ: chúng ta đưa vào một câu như [“All”, “[TERM1-START]”, “cells”, “[TERM1-END]”, “have”, “a”, “[TERM2-START]”, “cell” “membrane”, “[TERM2-END]”, “.”], và kỳ vọng mô hình cho ra phân phố xác suất trên những mối quan hệ khác nhau, điều này có thể tồn tại hai thuật ngữ. Mối quan hệ dự đoán được phụ thuộc vào dữ liệu huấn luyện đầu vào.</p>

<h3 id="43-những-thách-thức-trong-rút-trích-quan-hệ">
<a class="anchor" href="#43-nh%E1%BB%AFng-th%C3%A1ch-th%E1%BB%A9c-trong-r%C3%BAt-tr%C3%ADch-quan-h%E1%BB%87" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.3 Những thách thức trong rút trích quan hệ</h3>

<p>Thách thức chính trong rút trích quan hệ là có được lượng dữ liệu huấn luyện cần thiết. Phương pháp tiếp cận giám sát yếu (weak supervision approach) khá là hứa hẹn bởi dữ liệu huấn luyện không cần phải hoàn thiện. Chúng ta có thể dùng đến những nguồn như Wikidata và Wordnet như một nguồn dữ liệu cho việc định nghĩa những hàm gán nhãn yếu (weak labeling functions). Phát triển một phương pháp tiếp cận mới cho weak labeling functions là một chủ đề đã và đang tiến hành nghiên cứu.</p>

<p>Chúng ta cũng cần có một quy trình làm việc (workflow) tốt để mà xác nhận những kết quả từ các bộ rút trích. Những bộ rút trích thường xuyên được tạo ra bởi cộng đồng (crowdsourcing). Chúng ta cũng có thể ưu tiên xác nhận những quan hệ rút trích được mà có độ tin cậy thấp. Phát triển các vòng lặp active learning là một thách thức khác hiện đang được nghiên cứu.</p>

<h2 id="5-tổng-kết">
<a class="anchor" href="#5-t%E1%BB%95ng-k%E1%BA%BFt" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. Tổng kết</h2>

<p>Với chương này, chúng ta đề cập đến vấn đề khởi tạo một đồ thị tri thức bằng cách xử lý văn bản. Chúng ta điểm qua hai vấn đề cơ bản là rút trích thực thể (entity extraction) và (relation extracion). Với cả hai tác vụ này, những công trình trước đây tập trung vào xác định những quy tác thủ công và cú pháp cho việc rút trích. Những phương pháp tiếp cận gần đây dựa trên điều đỉnh mô hình ngôn ngữ được huấn luyện sẵn (pre-trained language models) và tinh chỉnh chúng cho những bộ ngữ liệu cụ thể ở công việc đang xử lý.</p>

<p>Với cả rút trích thực thể và rút trích quan hệ, cách tiếp cận phổ biến nhất hiện nay là điều chỉnh một mô hình ngôn ngữ được tạo ra trước bằng cách sử dụng Học Sâu (Deep Learning). Cũng có những phương pháp tiếp cận, dựa trên cú pháp (syntactic) hay dựa trên luật (rule-based) cũng đóng vai trò quan trong trong boostrapping dữ liệu huấn luyện cần cho mô hình Học Sâu (Deep Learning). Việc xác nhận đầu ra của rút trích tiếp tục là một thách thức.</p>

<p>Vấn đề liên kết thực thể (entity linking) hay phân giải thực thể (entity resolution) là một vấn đề quan trong không kém trong việc khởi tạo đồ thị tri thức, nhưng chúng ta không đề cập đến nó trong phần thảo luận này bởi hai lý do:</p>

<p>- Lý do thứ nhất, chúng ta tin rằng thách thức cho việc có được hiệu năng tốt là nằm ở rút trích thực thể (entity extraction) và rút trích quan hệ (relation extraction), chính nó là một rào cản đáng kể</p>

<p>- Lý do thứ hai, một điều kiện tiên quyết để có một hiệu suất tốt trên liên kết thực thể (entity linking) là có sẵn một vốn từ vựng tốt</p>

<p>Với những lý do này, phân giải thực thể (entity resolution) là một kỹ thuật nâng cao (an advanced technique) và nó có thể hoặc không là nút thắc trong giải quyết vấn đề khởi tạo đồ thị.</p>

<p><strong>Bài tập:</strong></p>

<p>…Sẽ cập nhật sau…</p>

<p>Bài giảng gốc: https://web.stanford.edu/class/cs520/2020/notes/How_To_Create_A_Knowledge_Graph_From_Text.html</p>

  </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="nhutnamhcmus/lenux-notebooks"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/lenux-notebooks/2021/06/27/how-to-create-a-knowledge-graph-from-text.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/lenux-notebooks/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/lenux-notebooks/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/lenux-notebooks/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>An easy to use blogging platform with support for Jupyter Notebooks.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/nhutnamhcmus" title="nhutnamhcmus"><svg class="svg-icon grey"><use xlink:href="/lenux-notebooks/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://twitter.com/Namlee298" title="Namlee298"><svg class="svg-icon grey"><use xlink:href="/lenux-notebooks/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
